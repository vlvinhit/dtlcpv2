/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.30/esri/copyright.txt for details.
*/
import{g as e,T as t}from"./UpdateTracking2D.js";import{T as s,g as r,m as i,p as a,H as n,a as o,L as c,P as h,M as l,C as u,b as m,O as d,c as f,d as p,D as _,F as g}from"./PieChartMeshWriter.js";import{p as x}from"./ensureType.js";import{a as y}from"./screenUtils.js";import{a as v,t as M}from"./mat2d.js";import{c as P}from"./mat2df32.js";import{g as w,k as b,i as I,b as S,e as L}from"./vec2.js";import{f as k}from"./vec2f32.js";import{c as z}from"./vec2f64.js";import{h as B,a as E}from"./featureConversionUtils.js";import{O as A}from"./OptimizedGeometry.js";import{g as D,a as j}from"./shapingUtils.js";import{B as T}from"./BoundingBox.js";import{L as F,b as G}from"./dataViewUtils.js";import{m as R}from"./constants.js";import{i as O,clone as V}from"../core/lang.js";import C from"../core/Error.js";import{L as Z}from"./Logger.js";import{a as W}from"./grouping.js";import{A as q}from"./AttributeStore.js";function N(e,t,s){return e[0]=t[0]-s[0],e[1]=t[1]-s[1],e}function U(e,t){return Math.sqrt(e*e+t*t)}function X(e){const t=U(e[0],e[1]);e[0]/=t,e[1]/=t}function Y(e){return e.length-1}function $(e,t,s=1){let[r,i]=function(e,t){return e[t+1]}(e,t);return[r,i]=[Math.round(r),Math.round(i)],Math.sqrt(r*r+i*i)*s}class H{constructor(e,t,s,r,i){this._segments=e,this._index=t,this._distance=s,this._xStart=r,this._yStart=i,this._done=!1}static create(e){return new H(e,0,0,e[0][0],e[0][1])}clone(){return new H(this._segments,this._index,this._distance,this.xStart,this.yStart)}equals(e){return this._index===e._index||e._index===this._index-1&&(0===this._distance||1===e._distance)||e._index===this._index+1&&(1===this._distance||0===e._distance)}leq(e){return this._index<e._index||this._index===e._index&&this._distance<=e._distance}geq(e){return this._index>e._index||this._index===e._index&&this._distance>=e._distance}get _segment(){return this._segments[this._index+1]}get angle(){const e=this.dy,t=(0*e+-1*-this.dx)/(1*this.length);let s=Math.acos(t);return e>0&&(s=2*Math.PI-s),s}get xStart(){return this._xStart}get yStart(){return this._yStart}get x(){return this.xStart+this.distance*this.dx}get y(){return this.yStart+this.distance*this.dy}get dx(){return this._segment[0]}get dy(){return this._segment[1]}get xMidpoint(){return this.xStart+.5*this.dx}get yMidpoint(){return this.yStart+.5*this.dy}get xEnd(){return this.xStart+this.dx}get yEnd(){return this.yStart+this.dy}get length(){const{dx:e,dy:t}=this;return Math.sqrt(e*e+t*t)}get remainingLength(){return this.length*(1-this._distance)}get backwardLength(){return this.length*this._distance}get distance(){return this._distance}get done(){return this._done}hasPrev(){return this._index-1>=0}hasNext(){return this._index+1<Y(this._segments)}next(){return this.hasNext()?(this._xStart+=this.dx,this._yStart+=this.dy,this._distance=0,this._index+=1,this):null}prev(){return this.hasPrev()?(this._index-=1,this._xStart-=this.dx,this._yStart-=this.dy,this._distance=1,this):(this._done=!0,null)}_seekBackwards(e,t){const s=this.backwardLength;if(e<=s)return this._distance=(s-e)/this.length,this;let r=this.backwardLength;for(;this.prev();){if(r+this.length>e)return this._seekBackwards(e-r);r+=this.length}return this._distance=0,t?this:null}seek(e,t=!1){if(e<0)return this._seekBackwards(Math.abs(e),t);if(e<=this.remainingLength)return this._distance=(this.backwardLength+e)/this.length,this;let s=this.remainingLength;for(;this.next();){if(s+this.length>e)return this.seek(e-s,t);s+=this.length}return this._distance=1,t?this:null}}function Q(e,t,s,r=!0){const i=function(e){let t=0;for(let s=0;s<Y(e);s++)t+=$(e,s);return t}(e),a=H.create(e),n=i/2;if(!r)return a.seek(n),void(Math.abs(a.x)<R&&Math.abs(a.y)<R&&s(a.clone(),0,n+0*t,i));const o=Math.max((i-t)/2,0),c=Math.floor(o/t),h=n-c*t;a.seek(h);for(let e=-c;e<=c;e++)Math.abs(a.x)<R&&Math.abs(a.y)<R&&s(a.clone(),e,n+e*t,i),a.seek(t)}function J(e,t){const s=t;for(let t=0;t<e.length;t++){let r=e[t];K(r,s);const i=[];i.push(r[0]);for(let e=1;e<r.length;e++){const[t,s]=r[e-1],[a,n]=r[e],o=a-t,c=n-s;i.push([o,c])}e[t]=i,r=i}return e}function K(e,t){const s=1e-6;if(t<=0)return;const r=e.length;if(r<3)return;const i=[];let a=0;i.push(0);for(let t=1;t<r;t++)a+=(n=e[t],o=e[t-1],U(n[0]-o[0],n[1]-o[1])),i.push(a);var n,o;t=Math.min(t,.2*a);const c=[];c.push(e[0][0]),c.push(e[0][1]);const h=e[r-1][0],l=e[r-1][1],u=N([0,0],e[0],e[1]);X(u),e[0][0]+=t*u[0],e[0][1]+=t*u[1],N(u,e[r-1],e[r-2]),X(u),e[r-1][0]+=t*u[0],e[r-1][1]+=t*u[1];for(let e=1;e<r;e++)i[e]+=t;i[r-1]+=t;const m=.5*t;for(let a=1;a<r-1;a++){let n=0,o=0,h=0;for(let r=a-1;r>=0&&!(i[r+1]<i[a]-m);r--){const c=m+i[r+1]-i[a],l=i[r+1]-i[r],u=i[a]-i[r]<m?1:c/l;if(Math.abs(u)<s)break;const d=u*u,f=u*c-.5*d*l,p=u*l/t,_=e[r+1],g=e[r][0]-_[0],x=e[r][1]-_[1];n+=p/f*(_[0]*u*c+.5*d*(c*g-l*_[0])-d*u*l*g/3),o+=p/f*(_[1]*u*c+.5*d*(c*x-l*_[1])-d*u*l*x/3),h+=p}for(let c=a+1;c<r&&!(i[c-1]>i[a]+m);c++){const r=m-i[c-1]+i[a],l=i[c]-i[c-1],u=i[c]-i[a]<m?1:r/l;if(Math.abs(u)<s)break;const d=u*u,f=u*r-.5*d*l,p=u*l/t,_=e[c-1],g=e[c][0]-_[0],x=e[c][1]-_[1];n+=p/f*(_[0]*u*r+.5*d*(r*g-l*_[0])-d*u*l*g/3),o+=p/f*(_[1]*u*r+.5*d*(r*x-l*_[1])-d*u*l*x/3),h+=p}c.push(n/h),c.push(o/h)}c.push(h),c.push(l);for(let t=0,s=0;t<r;t++)e[t][0]=c[s++],e[t][1]=c[s++]}const ee=x((e=>{let t=0;if(0===e)return 1/0;for(;!(e%2);)t++,e/=2;return t}));class te extends s{constructor(){super(...arguments),this._zoomLevel=0}_write(e,t,s,r){if(this._zoomLevel=r||0,null!=s)throw new Error("InternalError: EffectGeometry not support for LabelMeshWriter");switch(t.geometryType){case"esriGeometryPoint":{const s=t.readXForDisplay(),r=t.readYForDisplay();return this._writePoint(e,s,r,t)}case"esriGeometryEnvelope":case"esriGeometryPolygon":case"esriGeometryMultipoint":{const s=t.readCentroidForDisplay();if(!s)return;const[r,i]=s.coords;return this._writePoint(e,r,i,t)}case"esriGeometryPolyline":this._writeLines(e,t)}}_writePoint(t,s,r,i){const a=this._getShaping();if(!a)return;let n=this._getPointReferenceBounds();n||(n={offsetX:0,offsetY:0,size:0});const o=a.boundsT,c=D(this.evaluatedMeshParams.horizontalAlignment),h=j(this.evaluatedMeshParams.verticalAlignment),l=this.evaluatedMeshParams.scaleInfo?.maxScale??0,u=this.evaluatedMeshParams.scaleInfo?.minScale??0,m=e(i.getDisplayId());t.metricStart(new F(m,s,r,c,h,l,u,n)),t.metricBoxWrite(o),this._writeGlyphs(t,i.getDisplayId(),s,r,a,0,n),t.metricEnd()}_getPointReferenceBounds(){if(!this._references)return null;for(const e of this._references){const t=e.getBoundsInfo();if(t)return t}return null}_writeLines(e,t){const{scaleInfo:s,verticalAlignment:i}=this.evaluatedMeshParams,a=this.evaluatedMeshParams.repeatLabelDistance||128,n=this._getShaping("middle");if(!n)return;const o=(e,t,s,r)=>this._placeSubdivGlyphs(e,t,s,r),c=(n.bounds.width+a)/2;this._current={out:e,id:t.getDisplayId(),shaping:n,zoomRange:r(s,this.getTileInfo()),referenceBounds:this._getPointReferenceBounds()||{offsetX:0,offsetY:0,size:0},offsetDirection:null},this._verticalPlacement="bottom"===i?"above":"top"===i?"below":null,this._verticalPlacement?this._writeAboveAndBelowAlong(t,o,c):this._writeCenterAlong(t,o,c)}_writeAboveAndBelowAlong(e,t,s){const{repeatLabel:r,fontSize:i}=this.evaluatedMeshParams,{shaping:a}=this._current,n=y(i),o=e.readGeometryForDisplay();if(!o)return;const c=new A;B(c,o,!1,!1,"esriGeometryPolyline",1);const h=se(new A,c,n),l=se(new A,c,-n),u=E(l,"esriGeometryPolyline",!1,!1),m=J(E(h,"esriGeometryPolyline",!1,!1).paths,a.bounds.width),d=J(u.paths,a.bounds.width);this._current.offsetDirection="above";for(const e of m)Q(e,s,t,!!r);this._current.offsetDirection="below";for(const e of d)Q(e,s,t,!!r)}_writeCenterAlong(e,t,s){const{repeatLabel:r}=this.evaluatedMeshParams,{shaping:i}=this._current,a=J(e.readLegacyGeometryForDisplay().paths,i.bounds.width);for(const e of a)Q(e,s,t,!!r)}_placeSubdivGlyphs(e,t,s,r){const{allowOverrun:a,labelPosition:n,repeatLabelDistance:o}=this.evaluatedMeshParams,c=this._current.zoomRange[0],h=ee(t),l=this._current.shaping.bounds.width/2,u=Math.sqrt(o||128)/2,m=Math.min(s,r-s),d=this._current.shaping.isMultiline?i:Math.log2(m/(u+l/2)),f=0===t?d:Math.min(h,d),p=Math.max(c,this._zoomLevel+1-f),_=this._zoomLevel-p,g=this._current.shaping.bounds.width/2*2**_;this._current.shaping.isMultiline?0===t&&this._placeStraight(e,p):a&&_<0?this._placeStraightAlong(e,c):"parallel"===n?this._placeStraightAlong(e,p):"curved"===n&&this._placeCurved(e,p,g)}_placeStraight(t,s){const{out:r,id:i,shaping:a,referenceBounds:n}=this._current,{x:o,y:c}=t,h=e(i),l=this.evaluatedMeshParams.scaleInfo?.maxScale??0,u=this.evaluatedMeshParams.scaleInfo?.minScale??0;r.metricStart(new F(h,t.x,t.y,0,0,l,u,null)),r.metricBoxWrite(a.boundsT);const m=t.angle*(180/Math.PI)%360,d=(t.angle*(180/Math.PI)+180)%360;this._writeGlyphs(r,i,o,c,a,0,n,{clipAngle:m,mapAligned:!0,isLineLabel:!0,minZoom:s}),this._writeGlyphs(r,i,o,c,a,0,n,{clipAngle:d,mapAligned:!0,isLineLabel:!0,minZoom:s}),r.metricEnd()}_placeCurved(t,s,r){const{out:i,id:a}=this._current,n=t.clone(),o=t.angle*(180/Math.PI)%360,c=(t.angle*(180/Math.PI)+180)%360,h=e(a),l=this.evaluatedMeshParams.scaleInfo?.maxScale??0,u=this.evaluatedMeshParams.scaleInfo?.minScale??0;i.metricStart(new F(h,t.x,t.y,0,0,l,u,null)),this._verticalPlacement&&this._verticalPlacement!==this._current.offsetDirection||(this._placeFirst(n,s,1,o),this._placeBack(t,n,s,r,1,o),this._placeForward(t,n,s,r,1,o)),this._verticalPlacement&&this._verticalPlacement===this._current.offsetDirection||(this._placeFirst(n,s,0,c),this._placeBack(t,n,s,r,0,c),this._placeForward(t,n,s,r,0,c)),i.metricEnd()}_placeStraightAlong(t,s){const{out:r,id:a,shaping:n,zoomRange:o,referenceBounds:c}=this._current,{boxBorderLineColor:h,boxBackgroundColor:l}=this.evaluatedMeshParams,u=t.clone(),m=t.angle*(180/Math.PI)%360,d=(t.angle*(180/Math.PI)+180)%360;if(n.glyphs.length>0&&(h||l)){const e=Math.max(s,o[0],0),h=Math.min(i,o[1]),l=v(P(),-t.angle),u={minZoom:e,maxZoom:h,clipAngle:m,mapAligned:!0,isLineLabel:!0},f=y(this.evaluatedMeshParams.offsetX),p=y(this.evaluatedMeshParams.offsetY);if(!this._verticalPlacement||this._verticalPlacement===this._current.offsetDirection){const e=k(f,-1*p),[s,i]=n.shapeBackground(M(P(),l,e));r.recordStart(this.instanceId,this.attributeLayout,n.glyphs[0].textureBinding);const o=2*Math.max(s.width,s.height);r.recordBounds(t.x+s.x,t.y+s.y,o,o),this._writeTextBox(r,a,t.x,t.y,i,c,u),r.recordEnd()}if(!this._verticalPlacement||this._verticalPlacement!==this._current.offsetDirection){const e=k(f,p),[s,i]=n.shapeBackground(M(P(),l,e));u.clipAngle=d,r.recordStart(this.instanceId,this.attributeLayout,n.glyphs[0].textureBinding);const o=2*Math.max(s.width,s.height);r.recordBounds(t.x+s.x,t.y+s.y,o,o),this._writeTextBox(r,a,t.x,t.y,i,c,u),r.recordEnd()}}const f=e(a),p=this.evaluatedMeshParams.scaleInfo?.maxScale??0,_=this.evaluatedMeshParams.scaleInfo?.minScale??0;r.metricStart(new F(f,t.x,t.y,0,0,p,_,null)),this._verticalPlacement&&this._verticalPlacement!==this._current.offsetDirection||this._placeFirst(u,s,1,m,!0),this._verticalPlacement&&this._verticalPlacement===this._current.offsetDirection||this._placeFirst(u,s,0,d,!0),r.metricEnd()}_placeBack(e,t,s,r,i,a){const n=e.clone();let o=e.backwardLength+0;for(;n.prev()&&!(o>=r);)this._placeOnSegment(n,t,o,s,-1,i,a),o+=n.length+0}_placeForward(e,t,s,r,i,a){const n=e.clone();let o=e.remainingLength+0;for(;n.next()&&!(o>=r);)this._placeOnSegment(n,t,o,s,1,i,a),o+=n.length+0}_placeFirst(e,t,s,r,a=!1){const{out:n,id:o,shaping:c,zoomRange:h,referenceBounds:l}=this._current,u=c.glyphs;for(const m of u){const u=m.x>c.bounds.x?s:1-s,d=u*e.remainingLength+(1-u)*e.backwardLength,f=Math.abs(m.x+m.width/2-c.bounds.x),p=Math.max(0,this._zoomLevel+Math.log2(f/(d+0))),_=Math.max(t,a?0:p);m.maxZoom=Math.min(h[1],i),m.angle=e.angle+(1-s)*Math.PI,m.minZoom=Math.max(h[0],_),this._writeLineGlyph(n,o,e.x,e.y,c.bounds,m,r,l,!0),s&&this._isVisible(m.minZoom,m.maxZoom)&&n.metricBoxWrite(m.bounds)}}_placeOnSegment(e,t,s,r,i,a,n){const{out:o,id:c,shaping:h,referenceBounds:l}=this._current,u=h.glyphs,m=e.dx/e.length,d=e.dy/e.length,f={x:e.x+s*-i*m,y:e.y+s*-i*d};for(const m of u){const u=m.x>h.bounds.x?a:1-a;if(!(u&&1===i||!u&&-1===i))continue;const d=Math.abs(m.x+m.width/2-h.bounds.x),p=Math.max(0,this._zoomLevel+Math.log2(d/s)-.1),_=Math.max(r,this._zoomLevel+Math.log2(d/(s+e.length+0)));if(0!==p&&(m.angle=e.angle+(1-a)*Math.PI,m.minZoom=_,m.maxZoom=p,this._writeLineGlyph(o,c,f.x,f.y,h.bounds,m,n,l,!0),a&&this._isVisible(m.minZoom,m.maxZoom))){const s=m.bounds,r=e.x-t.x,i=e.y-t.y,a=new T(s.center[0]+r,s.center[1]+i,s.width,s.height);o.metricBoxWrite(a)}}}_writeLineGlyph(e,t,s,r,i,n,o,c,h){const l=s+i.x,u=r+i.y,m=2*(this.evaluatedMeshParams.minPixelBuffer?this.evaluatedMeshParams.minPixelBuffer/this._textMeshTransformProps.fontSize:1),d=Math.max(i.width,i.height)*m;e.recordStart(this.instanceId,this.attributeLayout,n.textureBinding),e.recordBounds(l,u,d,d);const{texcoords:f,offsets:p}=n,_=this._textMeshTransformProps.fontSize;this._writeQuad(e,t,s,r,{texcoords:f,offsets:p,fontSize:_,color:a(this.evaluatedMeshParams.color),isBackground:!1,referenceBounds:c,minZoom:Math.max(this._current.zoomRange[0],n.minZoom),maxZoom:Math.min(this._current.zoomRange[1],n.maxZoom),clipAngle:o,mapAligned:h,isLineLabel:!0}),e.recordEnd()}_isVisible(e,t){const s=this._zoomLevel;return e<=s&&s<=t}}function se(e,t,s){const{coords:r,lengths:i}=t,a=z(),n=z(),o=z(),c=z(),h=z(),l=z();let u=0;for(let t=0;t<i.length;t++){const m=i[t];for(let t=0;t<m;t++){const i=2*(t+u-1),d=2*(t+u),f=2*(t+u+1);t>0?w(a,r[i],r[i+1]):w(a,0,0),w(n,r[d],r[d+1]),t<m-1?w(o,r[f],r[f+1]):w(o,0,0),0===t?w(c,0,0):(b(c,n,a),I(c,c),w(c,c[1],-c[0])),t===m-1?w(h,0,0):(b(h,o,n),I(h,h),w(h,h[1],-h[0])),S(l,c,h),I(l,l);const p=l[0]*h[0]+l[1]*h[1];0!==p&&L(l,l,p),L(l,l,s),e.coords.push(n[0]+l[0],n[1]+l[1])}e.lengths.push(m),u+=m}return e}class re extends q{constructor(e){super(),this._value=e}resize(e){}read(e,t){return this._value}readWithDefault(e,t,s){return this._value}referencesScale(){return!1}referencesGeometry(){return!1}}async function ie(e,t,s=!1){const{defaultValue:r,valueExpressionInfo:i,value:a}=t;if(i){const{expression:a}=i,n=await e.createComputedField({expression:a},s);return n?{...t,computed:n,defaultValue:r}:null}return{...t,computed:new re(a),defaultValue:r}}async function ae(e,t){const{defaultValue:s,valueExpressionInfo:r}=t,{expression:i}=r,a=await e.createComputedField({expression:i});return a?{...t,computed:a,defaultValue:s}:null}const ne=e=>"boolean"!=typeof e&&"number"!=typeof e&&"valueExpressionInfo"in e,oe=e=>e.some((e=>{for(const t in e){const s=e[t];if(ne(s))return!0}return!1}));class ce{static async create(e,t,s){const r={},i=new Map,a=new Map,n=new Map,o=new Map,c=new Map;for(const h in s){const l=s[h];if(null!=l&&"object"==typeof l)if(Array.isArray(l)){if("object"==typeof l[0])throw new Error(`InternalError: Cannot handle ${h}. Nested array params are not supported`);r[h]=l}else if("valueExpressionInfo"in l){if(l.value){r[h]=l.value;continue}const t=await ae(e,l);if(!t){r[h]=l.defaultValue;continue}i.set(h,t),r[h]=null}else switch(l.type){case"cim-effect-infos":if(l.effectInfos.some((e=>e.overrides.length))){a.set(h,{effects:await Promise.all(l.effectInfos.map((async t=>{const s=t.overrides.map((t=>ie(e,t)));return{effect:t.effect,compiledOverrides:(await Promise.all(s)).filter(O)}})))});break}r[h]=l.effectInfos.map((e=>e.effect));break;case"cim-marker-placement-param":l.overrides.length&&n.set(h,{placementInfo:l,compiledOverrides:(await Promise.all(l.overrides.map((t=>ie(e,t))))).filter(O)}),r[h]=l.placement;break;case"text-rasterization-param":{if(l.overrides.length){const t=l.overrides.map((t=>ie(e,t,l.useLegacyLabelEvaluationRules)));o.set(h,{compiledOverrides:(await Promise.all(t)).filter(O),rasterizationParam:l,objectIdToResourceId:new Map});continue}const s={type:"cim-rasterization-info",resource:l.resource};r[h]=await t.fetchResourceImmediate(s)??null;break}case"sprite-rasterization-param":{if(l.overrides.length){const t=l.overrides.map((t=>ie(e,t)));o.set(h,{compiledOverrides:(await Promise.all(t)).filter(O),rasterizationParam:l,objectIdToResourceId:new Map});continue}if("animated"===l.resource.type){o.set(h,{compiledOverrides:[],rasterizationParam:l,objectIdToResourceId:new Map});continue}const s={type:"cim-rasterization-info",resource:l.resource};r[h]=await t.fetchResourceImmediate(s)??null;break}case"cim-marker-transform-param":{const{params:t}=l;if(oe(t)){const s={compiledMarkerInfos:[]};await Promise.all(t.map((async t=>{const r={props:{}};for(const s in t)if(ne(t[s])){const i=await ae(e,t[s]);r.compiledExpressionMap||(r.compiledExpressionMap=new Map);const a=r.compiledExpressionMap;i&&a.set(s,i)}else r.props[s]=t[s];s.compiledMarkerInfos.push(r)}))),c.set(h,s)}else r[h]={type:"cim-marker-transform-info",infos:t};break}default:r[h]=l}else r[h]=l}return new ce(s,r,i,a,n,o,c)}constructor(e,t,s,r,i,a,n){this.inputMeshParams=e,this._resolvedMeshParams=t,this._dynamicProperties=s,this._dynamicEffectProperties=r,this._dynamicPlacementProperties=i,this._dynamicAsyncProperties=a,this._dynamicTransformProperties=n,this.evaluator=e=>e}get hasDynamicProperties(){return!!(this._dynamicProperties.size||this._dynamicAsyncProperties.size||this._dynamicEffectProperties.size||this._dynamicTransformProperties.size||this._dynamicPlacementProperties.size)}get evaluatedMeshParams(){return this._evaluatedMeshParams||(this._evaluatedMeshParams=this.evaluator(this._resolvedMeshParams)),this._evaluatedMeshParams}enqueueRequest(e,t,s){for(const r of this._dynamicAsyncProperties.values()){const i=V(r.rasterizationParam.resource);"animated"===r.rasterizationParam.resource.type&&r.rasterizationParam.resource.randomizeStartTime&&(i.primitiveName="__RESERVED__PRIMITIVE__NAME__",i.startGroup=W(t.getObjectId()||0));for(const{primitiveName:e,propertyName:a,computed:n,defaultValue:o,valueExpressionInfo:c}of r.compiledOverrides)try{const c="animated"===r.rasterizationParam.resource.type?i.primitiveName:e;G(i,c,a,n,t,s,o)}catch(t){Z.getLogger("esri.views.2d.engine.webgl.shaderGraph.techniques.mesh.MeshWriterInputEvaluator").errorOnce(new C("invalid-arcade-expression",`Encountered an error when evaluating the arcade expression '${c?.expression}' (primitive: '${e}', property: '${a}')`,t))}const a=e.enqueueRequest({type:"cim-rasterization-info",resource:i});r.objectIdToResourceId.set(t.getObjectId(),a)}}evaluateMeshParams(e,t,s){for(const[e,r]of this._dynamicProperties.entries())this._resolvedMeshParams[e]=r.computed.readWithDefault(t,s,r.defaultValue);for(const[e,r]of this._dynamicPlacementProperties.entries())for(const{computed:i,defaultValue:a,propertyName:n}of r.compiledOverrides){const o=i.readWithDefault(t,s,a);r.placementInfo.placement[n]=o,this._resolvedMeshParams[e]=r.placementInfo.placement}for(const[e,r]of this._dynamicEffectProperties.entries())for(const i of r.effects){for(const{computed:e,defaultValue:r,propertyName:a}of i.compiledOverrides){const n=e.readWithDefault(t,s,r);i.effect[a]=n}this._resolvedMeshParams[e]=r.effects.map((e=>e.effect))}for(const[e,r]of this._dynamicTransformProperties.entries()){const i={type:"cim-marker-transform-info",infos:[]};for(const e of r.compiledMarkerInfos){const r={...e.props};if(e.compiledExpressionMap)for(const[i,a]of e.compiledExpressionMap){const e=a.computed.readWithDefault(t,s,a.defaultValue);r[i]="number"==typeof e||"boolean"==typeof e?e:a.defaultValue}i.infos.push(r)}this._resolvedMeshParams[e]=i}for(const[s,r]of this._dynamicAsyncProperties.entries()){const i=r.objectIdToResourceId.get(t.getObjectId());if(null==i)continue;const a=e.getResource(i);this._resolvedMeshParams[s]=a}return this._evaluatedMeshParams=this.evaluator(this._resolvedMeshParams),this.evaluatedMeshParams}}class he{async createMeshWriter(e,t,s,r){const i=this._getMeshWriter(r.techniqueType),a=await ce.create(e,t,r.inputParams),n=new i(r.id,a,r.optionalAttributes,s);return await n.loadDependencies(),n}_getMeshWriter(e){switch(e){case t.Fill:return g;case t.DotDensity:return _;case t.ComplexFill:return p;case t.PatternFill:return f;case t.OutlineFill:return d;case t.PatternOutlineFill:return m;case t.ComplexOutlineFill:return u;case t.Marker:return l;case t.PieChart:return h;case t.Text:return s;case t.Line:return c;case t.TexturedLine:return o;case t.Heatmap:return n;case t.Label:return te;case t.Test:throw new Error("Internal Error: Found invalid mesh writer")}}}export{re as D,he as M};
