/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.30/esri/copyright.txt for details.
*/
import{D as t}from"./enums.js";import{a as e}from"./screenUtils.js";import{d as s,e as r,S as i,G as o,f as n}from"./CIMSymbolHelper.js";import{T as a,G as c,j as u}from"./GeometryUtils.js";import{b as l,a as p,e as h,p as f,s as d,f as x,h as m,i as y,j as _,M as g}from"./UpdateTracking2D.js";import{i as k,E as P,s as S,t as b,F as w,G as v,m as T,g as E}from"./definitions.js";import{h as M}from"../core/lang.js";import{t as I,l as N}from"./libtess.js";import{v as D,p as A,i as z,h as Y}from"./dataViewUtils.js";import{c as B}from"./mathUtils.js";import{b as G,c as F,s as L}from"./shapingUtils.js";import{o as R}from"./utils7.js";import{L as O}from"./TurboLine.js";import"./earcut.js";import{O as C}from"./OptimizedGeometry.js";import{c as W,t as U,r as H}from"./mat2d.js";import{c as V}from"./mat2df32.js";import{t as X}from"./vec2.js";import{m as Z}from"./constants.js";import{L as j,C as q,a as Q,J,b as K}from"./enums2.js";import $ from"../Color.js";import tt from"../core/Error.js";import{L as et}from"./Logger.js";import{c as st}from"../geometry/Polygon.js";function rt(t,e,s,r,i,o,n){Et=0;const a=(r-s)*o,c=i&&i.length,u=c?(i[0]-s)*o:a;let l,p,h,f,d,x=it(e,s,0,0,u,o,!0);if(x&&x.next!==x.prev){if(c&&(x=function(t,e,s,r,i,o){const n=new Array;for(let i=0,a=r.length;i<a;i++){const c=it(t,e,0,r[i]*o,i<a-1?r[i+1]*o:s*o,o,!1);c===c.next&&(c.steiner=!0),n.push(pt(c))}n.sort(kt);for(const t of n)i=ht(t,i);return i}(e,s,r,i,x,o)),a>80*o){l=h=e[0+s*o],p=f=e[1+s*o];for(let t=o;t<u;t+=o){const r=e[t+s*o],i=e[t+1+s*o];l=Math.min(l,r),p=Math.min(p,i),h=Math.max(h,r),f=Math.max(f,i)}d=Math.max(h-l,f-p),d=0!==d?1/d:0}nt(x,t,o,l,p,d,n,0)}}function it(t,e,s,r,i,o,n){let a;if(n===function(t,e,s,r,i,o){let n=0;for(let s=r,a=i-o;s<i;s+=o)n+=(t[a+e*o]-t[s+e*o])*(t[s+1+e*o]+t[a+1+e*o]),a=s;return n}(t,e,0,r,i,o)>0)for(let s=r;s<i;s+=o)a=ut(s+e*o,t[s+e*o],t[s+1+e*o],a);else for(let s=i-o;s>=r;s-=o)a=ut(s+e*o,t[s+e*o],t[s+1+e*o],a);return a&&gt(a,a.next)&&(lt(a),a=a.next),a}function ot(t,e=t){if(!t)return t;let s,r=t;do{if(s=!1,r.steiner||!gt(r,r.next)&&0!==dt(r.prev,r,r.next))r=r.next;else{if(lt(r),r=e=r.prev,r===r.next)break;s=!0}}while(s||r!==e);return e}function nt(t,e,s,r,i,o,n,a){if(!t)return;!a&&o&&(t=ft(t,r,i,o));let c=t;for(;t.prev!==t.next;){const u=t.prev,l=t.next;if(o?ct(t,r,i,o):at(t))e.push(u.index/s+n),e.push(t.index/s+n),e.push(l.index/s+n),lt(t),t=l.next,c=l.next;else if((t=l)===c){a?1===a?nt(t=Pt(t,e,s,n),e,s,r,i,o,n,2):2===a&&St(t,e,s,r,i,o,n):nt(ot(t),e,s,r,i,o,n,1);break}}}function at(t){const e=t.prev,s=t,r=t.next;if(dt(e,s,r)>=0)return!1;let i=t.next.next;const o=i;let n=0;for(;i!==t.prev&&(0===n||i!==o);){if(n++,mt(e.x,e.y,s.x,s.y,r.x,r.y,i.x,i.y)&&dt(i.prev,i,i.next)>=0)return!1;i=i.next}return!0}function ct(t,e,s,r){const i=t.prev,o=t,n=t.next;if(dt(i,o,n)>=0)return!1;const a=i.x<o.x?i.x<n.x?i.x:n.x:o.x<n.x?o.x:n.x,c=i.y<o.y?i.y<n.y?i.y:n.y:o.y<n.y?o.y:n.y,u=i.x>o.x?i.x>n.x?i.x:n.x:o.x>n.x?o.x:n.x,l=i.y>o.y?i.y>n.y?i.y:n.y:o.y>n.y?o.y:n.y,p=_t(a,c,e,s,r),h=_t(u,l,e,s,r);let f=t.prevZ,d=t.nextZ;for(;f&&f.z>=p&&d&&d.z<=h;){if(f!==t.prev&&f!==t.next&&mt(i.x,i.y,o.x,o.y,n.x,n.y,f.x,f.y)&&dt(f.prev,f,f.next)>=0)return!1;if(f=f.prevZ,d!==t.prev&&d!==t.next&&mt(i.x,i.y,o.x,o.y,n.x,n.y,d.x,d.y)&&dt(d.prev,d,d.next)>=0)return!1;d=d.nextZ}for(;f&&f.z>=p;){if(f!==t.prev&&f!==t.next&&mt(i.x,i.y,o.x,o.y,n.x,n.y,f.x,f.y)&&dt(f.prev,f,f.next)>=0)return!1;f=f.prevZ}for(;d&&d.z<=h;){if(d!==t.prev&&d!==t.next&&mt(i.x,i.y,o.x,o.y,n.x,n.y,d.x,d.y)&&dt(d.prev,d,d.next)>=0)return!1;d=d.nextZ}return!0}function ut(t,e,s,r){const i=vt.create(t,e,s);return r?(i.next=r.next,i.prev=r,r.next.prev=i,r.next=i):(i.prev=i,i.next=i),i}function lt(t){t.next.prev=t.prev,t.prev.next=t.next,t.prevZ&&(t.prevZ.nextZ=t.nextZ),t.nextZ&&(t.nextZ.prevZ=t.prevZ)}function pt(t){let e=t,s=t;do{(e.x<s.x||e.x===s.x&&e.y<s.y)&&(s=e),e=e.next}while(e!==t);return s}function ht(t,e){const s=function(t,e){let s=e;const r=t.x,i=t.y;let o,n=-1/0;do{if(i<=s.y&&i>=s.next.y&&s.next.y!==s.y){const t=s.x+(i-s.y)*(s.next.x-s.x)/(s.next.y-s.y);if(t<=r&&t>n){if(n=t,t===r){if(i===s.y)return s;if(i===s.next.y)return s.next}o=s.x<s.next.x?s:s.next}}s=s.next}while(s!==e);if(!o)return null;if(r===n)return o.prev;const a=o,c=o.x,u=o.y;let l,p=1/0;for(s=o.next;s!==a;)r>=s.x&&s.x>=c&&r!==s.x&&mt(i<u?r:n,i,c,u,i<u?n:r,i,s.x,s.y)&&(l=Math.abs(i-s.y)/(r-s.x),(l<p||l===p&&s.x>o.x)&&yt(s,t)&&(o=s,p=l)),s=s.next;return o}(t,e);if(!s)return e;const r=wt(s,t);return ot(r,r.next),ot(s,s.next)}function ft(t,e,s,r){let i;for(;i!==t;i=i.next){if(i=i||t,null===i.z&&(i.z=_t(i.x,i.y,e,s,r)),i.prev.next!==i||i.next.prev!==i)return i.prev.next=i,i.next.prev=i,ft(t,e,s,r);i.prevZ=i.prev,i.nextZ=i.next}return t.prevZ.nextZ=null,t.prevZ=null,function(t){let e,s=1;for(;;){let r,i=t;t=null,e=null;let o=0;for(;i;){o++,r=i;let n=0;for(;n<s&&r;n++)r=r.nextZ;let a=s;for(;n>0||a>0&&r;){let s;0===n?(s=r,r=r.nextZ,a--):0!==a&&r?i.z<=r.z?(s=i,i=i.nextZ,n--):(s=r,r=r.nextZ,a--):(s=i,i=i.nextZ,n--),e?e.nextZ=s:t=s,s.prevZ=e,e=s}i=r}if(e.nextZ=null,s*=2,o<2)return t}}(t)}function dt(t,e,s){return(e.y-t.y)*(s.x-e.x)-(e.x-t.x)*(s.y-e.y)}function xt(t,e,s,r){return!!(gt(t,e)&&gt(s,r)||gt(t,r)&&gt(s,e))||dt(t,e,s)>0!=dt(t,e,r)>0&&dt(s,r,t)>0!=dt(s,r,e)>0}function mt(t,e,s,r,i,o,n,a){return(i-n)*(e-a)-(t-n)*(o-a)>=0&&(t-n)*(r-a)-(s-n)*(e-a)>=0&&(s-n)*(o-a)-(i-n)*(r-a)>=0}function yt(t,e){return dt(t.prev,t,t.next)<0?dt(t,e,t.next)>=0&&dt(t,t.prev,e)>=0:dt(t,e,t.prev)<0||dt(t,t.next,e)<0}function _t(t,e,s,r,i){return(t=1431655765&((t=858993459&((t=252645135&((t=16711935&((t=32767*(t-s)*i)|t<<8))|t<<4))|t<<2))|t<<1))|(e=1431655765&((e=858993459&((e=252645135&((e=16711935&((e=32767*(e-r)*i)|e<<8))|e<<4))|e<<2))|e<<1))<<1}function gt(t,e){return t.x===e.x&&t.y===e.y}function kt(t,e){return t.x-e.x}function Pt(t,e,s,r){let i=t;do{const o=i.prev,n=i.next.next;!gt(o,n)&&xt(o,i,i.next,n)&&yt(o,n)&&yt(n,o)&&(e.push(o.index/s+r),e.push(i.index/s+r),e.push(n.index/s+r),lt(i),lt(i.next),i=t=n),i=i.next}while(i!==t);return i}function St(t,e,s,r,i,o,n){let a=t;do{let t=a.next.next;for(;t!==a.prev;){if(a.index!==t.index&&bt(a,t)){let c=wt(a,t);return a=ot(a,a.next),c=ot(c,c.next),nt(a,e,s,r,i,o,n,0),void nt(c,e,s,r,i,o,n,0)}t=t.next}a=a.next}while(a!==t)}function bt(t,e){return t.next.index!==e.index&&t.prev.index!==e.index&&!function(t,e){let s=t;do{if(s.index!==t.index&&s.next.index!==t.index&&s.index!==e.index&&s.next.index!==e.index&&xt(s,s.next,t,e))return!0;s=s.next}while(s!==t);return!1}(t,e)&&yt(t,e)&&yt(e,t)&&function(t,e){let s=t,r=!1;const i=(t.x+e.x)/2,o=(t.y+e.y)/2;do{s.y>o!=s.next.y>o&&s.next.y!==s.y&&i<(s.next.x-s.x)*(o-s.y)/(s.next.y-s.y)+s.x&&(r=!r),s=s.next}while(s!==t);return r}(t,e)}function wt(t,e){const s=vt.create(t.index,t.x,t.y),r=vt.create(e.index,e.x,e.y),i=t.next,o=e.prev;return t.next=e,e.prev=t,s.next=i,i.prev=s,r.next=s,s.prev=r,o.next=r,r.prev=o,r}class vt{constructor(){this.index=0,this.x=0,this.y=0,this.prev=null,this.next=null,this.z=null,this.prevZ=null,this.nextZ=null,this.steiner=!1}static create(t,e,s){const r=Et<Tt.length?Tt[Et++]:new vt;return r.index=t,r.x=e,r.y=s,r.prev=null,r.next=null,r.z=null,r.prevZ=null,r.nextZ=null,r.steiner=!1,r}}const Tt=[];let Et=0;for(let t=0;t<8096;t++)Tt.push(new vt);const Mt=new a(0,0,0,1,0),It=new a(0,0,0,1,0);function Nt(t,e,s){let r=0;for(let i=1;i<s;i++){const s=t[2*(e+i-1)],o=t[2*(e+i-1)+1];r+=(t[2*(e+i)]-s)*(t[2*(e+i)+1]+o)}return r}function Dt(t,e,s,r,i){let o=0;for(let n=s;n<r;n+=3){const s=2*(t[n]-i),r=2*(t[n+1]-i),a=2*(t[n+2]-i);o+=Math.abs((e[s]-e[a])*(e[r+1]-e[s+1])-(e[s]-e[r])*(e[a+1]-e[s+1]))}return o}function At(t,e){if(null==t)return null;if(!function(t,e,s){let r=0;for(let e=0;e<t.lengths.length;e++){const i=t.lengths[e];for(let e=0;e<i;e++){const i=t.coords[2*(e+r)],o=t.coords[2*(e+r)+1];if(i<-128||i>s||o<-128||o>s)return!0}r+=i}return!1}(t,0,k+128))return t;Mt.setPixelMargin(e),Mt.reset(c.Polygon);let s=0;for(let e=0;e<t.lengths.length;e++){const r=t.lengths[e];let i=t.coords[2*(0+s)],o=t.coords[2*(0+s)+1];Mt.moveTo(i,o);for(let e=1;e<r;e++)i=t.coords[2*(e+s)],o=t.coords[2*(e+s)+1],Mt.lineTo(i,o);Mt.close(),s+=r}const r=Mt.result(!1);if(!r)return null;const i=[],o=[];for(const t of r){let e=0;for(const s of t)o.push(s.x),o.push(s.y),e++;i.push(e)}return new C(i,o)}Mt.setExtent(k),It.setExtent(k);const zt=96/72;class Yt{static executeEffects(t,e,o,n){const a=zt,c=s(t);let u=new i(e);for(const e of t){const t=r(e);t&&(u=t.execute(u,e,a,o,n,c))}return u}static applyEffects(t,e,n){if(!t)return e;const a=s(t);let c,u=new i(o.fromJSONCIM(e));for(const e of t){const t=r(e);t&&(u=t.execute(u,e,1,null,n,a))}const l=[];let p=null;for(;c=u.next();)l.push(...st(c)),p=c.geometryType;return 0===l.length||null===p?null:"esriGeometryPolygon"===p?{rings:l}:{paths:l}}}let Bt=null;function Gt(){return Bt}function Ft(e){switch(e){case t.BYTE:case t.UNSIGNED_BYTE:return 1;case t.SHORT:case t.UNSIGNED_SHORT:case t.HALF_FLOAT:return 2;case t.FLOAT:case t.INT:case t.UNSIGNED_INT:return 4}}class Lt{static fromVertexSpec(t,e){const{attributes:s,optionalAttributes:r}=t;let i,o,n;const a=[];for(const t in s){const e=s[t];"position"===e.pack?i={...e,name:t,offset:0}:"id"===e.pack?o={...e,name:t,offset:4}:"bitset"===t?n={...e,name:t,offset:7}:a.push({...e,name:t})}for(const t in r)if(!0===e[t]){const e=r[t];a.push({...e,name:t})}const c=function(t){const e=[],s=[],r=[];for(const i of t){const t=Ft(i.type)*i.count;switch(t%2||t%4||4){case 4:e.push(i);continue;case 2:s.push(i);continue;case 1:r.push(i);continue;default:throw new Error("Found unexpected dataType byte count")}}return e.push(...s),e.push(...r),e}(a),u=[];let l=8,p=1;for(const t of c)u.push({...t,offset:l}),l+=Ft(t.type)*t.count,t.packAlternating&&(p=Math.max(t.packAlternating.count,p));const h=Uint32Array.BYTES_PER_ELEMENT,f=l%h;return new Lt(i,o,n,u,l+(f?h-f:0),p)}constructor(t,e,s,r,i,o){this.position=t,this.id=e,this.bitset=s,this.standardAttributes=r,this.stride=i,this.packVertexCount=o,r.push(s),this._attributes=[t,e,s,...r]}get attributeLayout(){if(!this._attributeLayout){const t=D(this._attributes),e=this._attributes.map((t=>({name:t.name,count:t.count,offset:t.offset,type:t.type,packPrecisionFactor:t.packPrecisionFactor,normalized:t.normalized??!1})));this._attributeLayout={attributes:e,hash:t,stride:this.stride}}return this._attributeLayout}}class Rt{static fromVertexSpec(t,e){const s=Lt.fromVertexSpec(t,e);return new Rt(s)}constructor(t){this._spec=t,this._packed=new Uint8Array(this._spec.stride*this._spec.packVertexCount),this._packedU32View=new Uint32Array(this._packed.buffer),this._dataView=new DataView(this._packed.buffer)}get attributeLayout(){return this._spec.attributeLayout}get stride(){return this._spec.stride}writeVertex(t,e,s,r,i,o){for(let t=0;t<this._spec.packVertexCount;t++){const n=t*this._spec.stride;this._packPosition(s,r,n),this._packId(e,n);const a=this._spec.bitset;if(o){if(a.packTessellation){const t=a.packTessellation(o,i);this._pack(t,a,n)}for(const t of this._spec.standardAttributes)if(null!=t.packTessellation){const e=t.packTessellation(o,i);this._pack(e,t,n)}else if(t.packAlternating?.packTessellation){const e=t.packAlternating.packTessellation(o,i);for(let s=0;s<this._spec.packVertexCount;s++){const r=e[s];this._pack(r,t,s*this._spec.stride)}}}}t.vertexWriteRegion(this._packedU32View)}pack(t,e){for(const s of this._spec.standardAttributes)if(s.pack&&"string"!=typeof s.pack){const r=s.pack(t,e);for(let t=0;t<this._spec.packVertexCount;t++)this._pack(r,s,t*this._spec.stride)}else if(s.packAlternating?.pack){const r=s.packAlternating.pack(t,e);for(let t=0;t<this._spec.packVertexCount;t++){const e=r[t];this._pack(e,s,t*this._spec.stride)}}}_packPosition(t,e,s){const{offset:r}=this._spec.position,i=this._spec.position.packPrecisionFactor??1,o=z(t*i,e*i);this._dataView.setUint32(s+r,o,!0)}_packId(t,e){const s=t*(this._spec.id.packPrecisionFactor??1),r=4278190080&this._dataView.getUint32(e+this._spec.id.offset,!0);this._dataView.setUint32(e+this._spec.id.offset,s|r,!0)}_pack(t,e,s){A(this._dataView,t,e,s)}}class Ot{constructor(t,e,s,r){this._instanceId=t,this._evaluator=e,this._enabledOptionalAttributes=s,this._viewParams=r,this._evaluator.evaluator=t=>this.vertexSpec.createComputedParams(t)}get _vertexPack(){if(!this._cachedVertexPack){const t=Rt.fromVertexSpec(this.vertexSpec,this._enabledOptionalAttributes);this._evaluator.hasDynamicProperties||t.pack(this._evaluator.evaluatedMeshParams,this._viewParams),this._cachedVertexPack=t}return this._cachedVertexPack}get evaluatedMeshParams(){return this._evaluator.evaluatedMeshParams}get hasEffects(){return!!this.evaluatedMeshParams.effects}get instanceId(){return this._instanceId}get attributeLayout(){return this._vertexPack.attributeLayout}setReferences(t){this._references=t}getBoundsInfo(){return null}getTileInfo(){return this._viewParams.tileInfo}async loadDependencies(){(function(t){if(!t)return!1;for(const e of t)switch(e.effect.type){case"CIMGeometricEffectBuffer":case"CIMGeometricEffectOffset":case"CIMGeometricEffectDonut":return!0}return!1})(this._evaluator.inputMeshParams.effects?.effectInfos)&&await async function(){Bt=await import("./geometryEngineJSON.js").then((t=>t.g))}()}enqueueRequest(t,e,s){this._evaluator.hasDynamicProperties&&this._evaluator.enqueueRequest(t,e,s)}write(t,e,s,r,i){this.ensurePacked(e,s,r);const n=this.evaluatedMeshParams.effects;if(!n||0===n.length)return void this._write(t,s,void 0,i);const a=s.readGeometryForDisplay()?.clone();if(!a)return;const c=o.fromOptimizedCIM(a,s.geometryType),u=Gt();c.invertY();const l=t.id||"",p=Yt.executeEffects(n,c,l,u);let h;for(;h=p.next();)h.invertY(),this._write(t,s,h,i)}ensurePacked(t,e,s){if(!this._evaluator.hasDynamicProperties)return;const r=this._evaluator.evaluateMeshParams(t,e,s);this._vertexPack.pack(r,this._viewParams)}_writeVertex(t,e,s,r,i){const o=this.evaluatedMeshParams;this._vertexPack.writeVertex(t,e,s,r,o,i)}}const Ct=M("featurelayer-fast-triangulation-enabled");class Wt extends Ot{async loadDependencies(){await Promise.all([super.loadDependencies(),N()])}_write(t,e,s){const r=s?.asOptimized()??e.readGeometryForDisplay(),i=this._clip(r);i&&(t.recordStart(this.instanceId,this.attributeLayout),this._writeGeometry(t,e,i),t.recordEnd())}_clip(t){return t?At(t,this.hasEffects?256:8):null}_writeGeometry(t,e,s){const r=s.maxLength>100,i=[],o=this.createTesselationParams(e);if(!r&&Ct&&function(t,e){const{coords:s,lengths:r,hasIndeterminateRingOrder:i}=e,o=t;if(i)return!1;let n=0;for(let t=0;t<r.length;){let e=t,i=r[t],a=Nt(s,n,i);const c=[];for(;++e<r.length;){const t=r[e],o=Nt(s,n+i,t);if(!(o>0))break;a+=o,c.push(n+i),i+=t}const u=o.length;rt(o,s,n,n+i,c,2,0);const l=Dt(o,s,u,o.length,0),p=Math.abs(a);if(Math.abs((l-p)/Math.max(1e-7,p))>1e-5)return o.length=0,!1;t=e,n+=i}return!0}(i,s))return void(i.length&&this._writeVertices(t,e,s.coords,o,i));const n=function(t){const{coords:e,lengths:s}=t,{buffer:r}=I(e,s);return r}(s);this._writeVertices(t,e,n,o)}_writeVertices(t,e,s,r,i){const o=e.getDisplayId(),n=t.vertexCount(),a=this.hasEffects;let c=0;if(i)for(const e of i){const i=s[2*e],n=s[2*e+1];a&&t.recordBounds(i,n,0,0),this._writeVertex(t,o,i,n,r),c++}else for(let e=0;e<s.length;e+=2){const i=Math.round(s[e]),n=Math.round(s[e+1]);a&&t.recordBounds(i,n,0,0),this._writeVertex(t,o,i,n,r),c++}t.indexEnsureSize(c);for(let e=0;e<c;e++)t.indexWrite(e+n)}}const Ut={createComputedParams:t=>t,optionalAttributes:{},attributes:{id:{type:t.UNSIGNED_BYTE,count:3,pack:"id"},bitset:{type:t.UNSIGNED_BYTE,count:1},pos:{type:t.SHORT,count:2,pack:"position",packPrecisionFactor:10},inverseArea:{type:t.FLOAT,count:1,packTessellation:({inverseArea:t})=>t}}};class Ht extends Wt{constructor(){super(...arguments),this.vertexSpec=Ut}createTesselationParams(t){return{inverseArea:1/t.readGeometryArea()}}}function Vt(t,e){return[!!t?.minScale&&e.scaleToZoom(t.minScale)||0,!!t?.maxScale&&e.scaleToZoom(t.maxScale)||100]}function Xt(t){return 1<<t}function Zt(t){let e=0;for(const[s,r]of t)r&&(e|=1<<s);return e}function jt(t){let e;if(!t)return[0,0,0,0];if("string"==typeof t){const s=$.fromString(t);if(!s)return et.getLogger("esri.views.2d.engine.webgl.shaderGraph.techniques.meshWriterUtils").errorOnce(new tt("mapview:mesh-processing","Unable to parse string into color",{color:t})),[0,0,0,0];e=s.toArray()}else e=t;const[s,r,i,o]=e;return[s*(o/255),r*(o/255),i*(o/255),o]}function qt(t,e){return Math.round(Math.min(Math.sqrt(t*e),255))}function Qt(t,e){return Math.round(t*e)/e}const Jt={createComputedParams:t=>t,optionalAttributes:{zoomRange:{type:t.SHORT,count:2,packPrecisionFactor:P,pack:({scaleInfo:t},{tileInfo:e})=>Vt(t,e)}},attributes:{id:{type:t.UNSIGNED_BYTE,count:3,pack:"id"},bitset:{type:t.UNSIGNED_BYTE,count:1},pos:{type:t.SHORT,count:2,pack:"position",packPrecisionFactor:10},color:{type:t.UNSIGNED_BYTE,count:4,normalized:!0,pack:({color:t})=>jt(t)}}};class Kt extends Wt{constructor(){super(...arguments),this.vertexSpec=Jt}createTesselationParams(t){return null}}const $t={createComputedParams:t=>t,optionalAttributes:Jt.optionalAttributes,attributes:{...Jt.attributes,tlbr:{count:4,type:t.UNSIGNED_SHORT,pack:({sprite:t})=>{const{rect:e,width:s,height:r}=t,i=e.x+S,o=e.y+S;return[i,o,i+s,o+r]}},inverseRasterizationScale:{count:1,type:t.BYTE,packPrecisionFactor:16,pack:({sprite:t})=>1/t.rasterizationScale}}};class te extends Kt{constructor(){super(...arguments),this.vertexSpec=$t}_write(t,e,s){const r=s?.asOptimized()??e.readGeometryForDisplay(),i=this._clip(r);if(!i)return;const o=this.evaluatedMeshParams.sprite?.textureBinding;t.recordStart(this.instanceId,this.attributeLayout,o),this._writeGeometry(t,e,i),t.recordEnd()}}function ee(t){const{sprite:s,aspectRatio:r,scaleProportionally:i}=t,o=e(t.height),n=o>0?o:s.height;let a=o*r;return a<=0?a=s.width:i&&(a*=s.width/s.height),{width:a,height:n}}function se(t){const{applyRandomOffset:e,sampleAlphaOnly:s}=t;return Zt([[l,e],[p,s]])}const re={createComputedParams:t=>t,optionalAttributes:$t.optionalAttributes,attributes:{...$t.attributes,bitset:{count:1,type:t.UNSIGNED_BYTE,pack:se},width:{count:1,type:t.HALF_FLOAT,pack:t=>ee(t).width},height:{count:1,type:t.HALF_FLOAT,pack:t=>ee(t).height},offset:{count:2,type:t.HALF_FLOAT,pack:({offsetX:t,offsetY:s})=>[e(t),-e(s)]},scale:{count:2,type:t.UNSIGNED_BYTE,packPrecisionFactor:16,pack:({scaleX:t,scaleY:e})=>[t,e]},angle:{count:1,type:t.UNSIGNED_BYTE,pack:({angle:t})=>u(t)}}};class ie extends te{constructor(){super(...arguments),this.vertexSpec=re}}class oe{constructor(){this.extrusionOffsetX=0,this.extrusionOffsetY=0,this.normalX=0,this.normalY=0,this.directionX=0,this.directionY=0,this.distance=0}}const ne={createComputedParams:t=>t,optionalAttributes:{zoomRange:{type:t.SHORT,count:2,packPrecisionFactor:P,pack:({scaleInfo:t},{tileInfo:e})=>Vt(t,e)}},attributes:{id:{type:t.UNSIGNED_BYTE,count:3,pack:"id"},pos:{type:t.SHORT,count:2,pack:"position",packPrecisionFactor:10},bitset:{type:t.UNSIGNED_BYTE,count:1},color:{type:t.UNSIGNED_BYTE,count:4,normalized:!0,pack:({color:t})=>jt(t)},offset:{type:t.BYTE,count:2,packPrecisionFactor:16,packTessellation:({extrusionOffsetX:t,extrusionOffsetY:e})=>[Qt(t,16),Qt(e,16)]},normal:{type:t.BYTE,count:2,packPrecisionFactor:16,packTessellation:({normalX:t,normalY:e})=>[Qt(t,16),Qt(e,16)]},halfWidth:{type:t.HALF_FLOAT,count:1,pack:({width:t})=>e(.5*t)},referenceHalfWidth:{type:t.HALF_FLOAT,count:1,pack:({referenceWidth:t})=>e(.5*t)}}};class ae{constructor(){this.id=0,this.bitset=0,this.indexCount=0,this.vertexCount=0,this.vertexFrom=0,this.vertexBounds=0}}class ce extends Ot{constructor(t,e,s,r){super(t,e,s,r),this.vertexSpec=ne,this._currentWrite=new ae,this._tessellationOptions={halfWidth:0,pixelCoordRatio:1,offset:0,wrapDistance:65535,textured:!1},this._tessParams=new oe,this._initializeTessellator()}writeLineVertices(t,e,s){const r=this._getLines(e);null!=r&&this._writeVertices(t,s,r)}_initializeTessellator(){this._lineTessellator=new O(this._writeTesselatedVertex.bind(this),this._writeTriangle.bind(this),!0)}_write(t,e,s){const r=s??o.fromFeatureSetReaderCIM(e);r&&this._writeGeometry(t,e,r)}_writeGeometry(t,e,s,r){t.recordStart(this.instanceId,this.attributeLayout,r),this.writeLineVertices(t,s,e),t.recordEnd()}_getLines(t){return function(t,e){It.setPixelMargin(e);const s=It,r=-e,i=k+e;let o=[],n=!1;if(!t.nextPath())return null;let a=!0;for(;a;){t.seekPathStart();const e=[];if(!t.pathSize)return null;s.reset(c.LineString),t.nextPoint();let u=t.x,l=t.y;if(n)s.moveTo(u,l);else{if(u<r||u>i||l<r||l>i){n=!0;continue}e.push({x:u,y:l})}let p=!1;for(;t.nextPoint();)if(u=t.x,l=t.y,n)s.lineTo(u,l);else{if(u<r||u>i||l<r||l>i){p=!0;break}e.push({x:u,y:l})}if(p)n=!0;else{if(n){const t=s.resultWithStarts();if(t)for(const e of t)o.push(e)}else o.push({line:e,start:0});a=t.nextPath(),n=!1}}return o=o.filter((t=>t.line.length>1)),0===o.length?null:o}(t,Y(this.evaluatedMeshParams))}_writeVertices(t,s,r){const{_currentWrite:i,_tessellationOptions:o,evaluatedMeshParams:n}=this,{width:a,capType:c,joinType:u,miterLimit:l,hasSizeVV:p}=n,h=e(.5*a);o.halfWidth=h,o.capType=function(t){switch(t){case"butt":case j.Butt:return q.BUTT;case"round":case j.Round:return q.ROUND;case"square":case j.Square:return q.SQUARE}}(c),o.joinType=function(t){switch(t){case"bevel":case Q.Bevel:return J.BEVEL;case"miter":case Q.Miter:return J.MITER;case"round":case Q.Round:return J.ROUND}}(u),o.miterLimit=l;const f=!p;i.out=t,i.id=s.getDisplayId(),i.vertexCount=0,i.indexCount=0,i.vertexFrom=t.vertexCount(),i.vertexBounds=f&&h<b?0:1;for(const{line:t,start:e}of r)o.initialDistance=e%65535,this._lineTessellator.tessellate(t,o,f)}_writeTesselatedVertex(t,e,s,r,i,o,n,a,c,u,l){const{out:p,id:h,vertexBounds:f}=this._currentWrite;return this.hasEffects&&p.recordBounds(t,e,f,f),this._tessParams.extrusionOffsetX=n,this._tessParams.extrusionOffsetY=a,this._tessParams.normalX=c,this._tessParams.normalY=u,this._tessParams.directionX=i,this._tessParams.directionY=o,this._tessParams.distance=l,this._writeVertex(p,h,t,e,this._tessParams),this._currentWrite.vertexFrom+this._currentWrite.vertexCount++}_writeTriangle(t,e,s){const{out:r}=this._currentWrite;r.indexEnsureSize(3),r.indexWrite(t),r.indexWrite(e),r.indexWrite(s),this._currentWrite.indexCount+=3}}const ue={createComputedParams:t=>t,optionalAttributes:ne.optionalAttributes,attributes:{...ne.attributes,bitset:{type:t.UNSIGNED_BYTE,count:1,pack:t=>0},color:{type:t.UNSIGNED_BYTE,count:4,normalized:!0,pack:({color:t})=>jt(t)}}},le={createComputedParams:t=>t,optionalAttributes:ne.optionalAttributes,attributes:{...ne.attributes,bitset:{type:t.UNSIGNED_BYTE,count:1,pack:t=>Zt([[h,!0]])},color:{type:t.UNSIGNED_BYTE,count:4,normalized:!0,pack:({outlineColor:t})=>jt(t)}}};class pe extends ce{constructor(){super(...arguments),this.vertexSpec=le}}class he extends Kt{constructor(t,e,s,r){super(t,e,s,r),this.vertexSpec=ue,this._lineMeshWriter=this._createOutlineWriter(t,e,s,r)}_createOutlineWriter(t,e,s,r){return new pe(t,e,s,r)}_write(t,e,s){const r=s?.asOptimized()??e.readGeometryForDisplay(),i=this._clip(r);i&&(t.recordStart(this.instanceId,this.attributeLayout),this._writeGeometry(t,e,i),this._lineMeshWriter.writeLineVertices(t,o.fromOptimizedCIM(i,"esriGeometryPolyline"),e),t.recordEnd())}_clip(t){return t?At(t,Y(this.evaluatedMeshParams)):null}ensurePacked(t,e,s){super.ensurePacked(t,e,s),this._lineMeshWriter.ensurePacked(t,e,s)}enqueueRequest(t,e,s){super.enqueueRequest(t,e,s),this._lineMeshWriter.enqueueRequest(t,e,s)}async loadDependencies(){await Promise.all([super.loadDependencies(),this._lineMeshWriter.loadDependencies()])}}const fe=re,de=le,xe={createComputedParams:t=>t,optionalAttributes:fe.optionalAttributes,attributes:{...fe.attributes,bitset:{type:t.UNSIGNED_BYTE,count:1,pack:t=>se(t)},aux1:{count:1,type:t.HALF_FLOAT,pack:t=>ee(t).width},aux2:{count:1,type:t.HALF_FLOAT,pack:t=>ee(t).height},aux3:{count:2,type:t.HALF_FLOAT,pack:({offsetX:t,offsetY:s})=>[e(t),e(s)]},aux4:{count:2,type:t.UNSIGNED_BYTE,pack:({scaleX:t,scaleY:e})=>[t*f,e*f]}}},me={createComputedParams:t=>t,optionalAttributes:fe.optionalAttributes,attributes:{...fe.attributes,color:de.attributes.color,bitset:{type:t.UNSIGNED_BYTE,count:1,pack:t=>Zt([[h,!0]])},aux1:{count:1,type:t.HALF_FLOAT,pack:t=>e(.5*t.width)},aux2:{count:1,type:t.HALF_FLOAT,pack:t=>e(.5*t.referenceWidth)},aux3:{count:2,type:t.HALF_FLOAT,packTessellation:({extrusionOffsetX:t,extrusionOffsetY:e})=>[t,e]},aux4:{count:2,type:t.UNSIGNED_BYTE,packTessellation:({normalX:t,normalY:e})=>[t*f+d,e*f+d]}}};class ye extends pe{constructor(){super(...arguments),this.vertexSpec=me}}class _e extends he{constructor(){super(...arguments),this.vertexSpec=xe}_createOutlineWriter(t,e,s,r){return new ye(t,e,s,r)}_write(t,e,s){const r=s?.asOptimized()??e.readGeometryForDisplay(),i=this._clip(r);if(!i)return;const n=this.evaluatedMeshParams.sprite?.textureBinding;t.recordStart(this.instanceId,this.attributeLayout,n),this._writeGeometry(t,e,i),this._lineMeshWriter.writeLineVertices(t,o.fromOptimizedCIM(i,"esriGeometryPolyline"),e),t.recordEnd()}ensurePacked(t,e,s){super.ensurePacked(t,e,s),this._lineMeshWriter.ensurePacked(t,e,s)}enqueueRequest(t,e,s){super.enqueueRequest(t,e,s),this._lineMeshWriter.enqueueRequest(t,e,s)}async loadDependencies(){await Promise.all([super.loadDependencies(),this._lineMeshWriter.loadDependencies()])}}const ge={optionalAttributes:$t.optionalAttributes,createComputedParams:t=>t,attributes:{...$t.attributes,...ue.attributes}},ke={optionalAttributes:$t.optionalAttributes,createComputedParams:t=>t,attributes:{...$t.attributes,...le.attributes}};class Pe extends pe{constructor(){super(...arguments),this.vertexSpec=ke}}class Se extends he{constructor(){super(...arguments),this.vertexSpec=ge}_createOutlineWriter(t,e,s,r){return new Pe(t,e,s,r)}_write(t,e,s){const r=s?.asOptimized()??e.readGeometryForDisplay(),i=this._clip(r);if(!i)return;const n=this.evaluatedMeshParams.sprite?.textureBinding;t.recordStart(this.instanceId,this.attributeLayout,n),this._writeGeometry(t,e,i),this._lineMeshWriter.writeLineVertices(t,o.fromOptimizedCIM(i,"esriGeometryPolyline"),e),t.recordEnd()}ensurePacked(t,e,s){super.ensurePacked(t,e,s),this._lineMeshWriter.ensurePacked(t,e,s)}enqueueRequest(t,e,s){super.enqueueRequest(t,e,s),this._lineMeshWriter.enqueueRequest(t,e,s)}async loadDependencies(){await Promise.all([super.loadDependencies(),this._lineMeshWriter.loadDependencies()])}}const be={createComputedParams:t=>t,optionalAttributes:{},attributes:{pos:{type:t.SHORT,count:2,pack:"position",packPrecisionFactor:10},id:{type:t.UNSIGNED_BYTE,count:3,pack:"id"},bitset:{type:t.UNSIGNED_BYTE,count:1},offset:{type:t.BYTE,count:2,packAlternating:{count:4,pack:()=>[[-1,-1],[1,-1],[-1,1],[1,1]]}}}};class we extends Ot{constructor(){super(...arguments),this.vertexSpec=be}_write(t,e){t.recordStart(this.instanceId,this.attributeLayout);const s=e.getDisplayId();if("esriGeometryPoint"===e.geometryType){const r=e.readXForDisplay(),i=e.readYForDisplay();this._writeQuad(t,s,r,i)}else if("esriGeometryMultipoint"===e.geometryType){const r=e.readGeometryForDisplay();r?.forEachVertex(((e,r)=>{e>=0&&e<=512&&r>=0&&r<=512&&this._writeQuad(t,s,e,r)}))}t.recordEnd()}_writeQuad(t,e,s,r){const i=t.vertexCount();this._writeVertex(t,e,s,r),t.indexWrite(i+0),t.indexWrite(i+1),t.indexWrite(i+2),t.indexWrite(i+1),t.indexWrite(i+3),t.indexWrite(i+2)}}class ve{static getPlacement(t,e,s,r,i,o){const a=n(s);return a?(-1===e&&t.invertY(),a.execute(t,s,r,i,o)):null}}class Te{constructor(t){const{offsetX:e,offsetY:s,postAngle:r,fontSize:i,scaleFactor:o,transforms:n}=t;if(this.offsetX=e,this.offsetY=s,this.postAngle=r,this.fontSize=Math.min(i,96),this.transforms=n,n&&n.infos.length>1){const t=R(i,r,!1,e,s,n);this.fontSize=Math.min(t.size,96),this.postAngle=t.rotation,this.offsetX=t.offsetX,this.offsetY=t.offsetY}o&&(this.fontSize*=o,this.offsetX*=o,this.offsetY*=o)}}const Ee=28,Me=[4,4],Ie=[16,4],Ne={topLeft:Ie,topRight:Ie,bottomLeft:Ie,bottomRight:Ie},De=[4,2],Ae=[4,6],ze={topLeft:De,topRight:De,bottomLeft:Ae,bottomRight:Ae},Ye={topLeft:De,topRight:Ae,bottomLeft:De,bottomRight:Ae},Be={topLeft:Ae,topRight:Ae,bottomLeft:Me,bottomRight:Me},Ge={topLeft:Me,topRight:Me,bottomLeft:Ae,bottomRight:Ae},Fe={topLeft:Ae,topRight:Me,bottomLeft:Ae,bottomRight:Me},Le={topLeft:Me,topRight:Ae,bottomLeft:Me,bottomRight:Ae},Re={createComputedParams:t=>t,optionalAttributes:{zoomRange:{type:t.UNSIGNED_SHORT,count:2,packPrecisionFactor:P,packTessellation:({minZoom:t,maxZoom:e})=>[t||0,e||28]},clipAngle:{type:t.UNSIGNED_BYTE,count:1,packTessellation:({clipAngle:t})=>Ce(t||0)},referenceSymbol:{type:t.BYTE,count:4,packPrecisionFactor:1,packTessellation:(t,s)=>{if(!t.referenceBounds)return[0,0,0,0];const r=G(s.horizontalAlignment),i=F(s.verticalAlignment),{offsetX:o,offsetY:n,size:a}=t.referenceBounds;return[e(o),-e(n),e(a),r+1<<2|i+1]}}},attributes:{pos:{type:t.SHORT,count:2,pack:"position",packPrecisionFactor:10},id:{type:t.UNSIGNED_BYTE,count:3,pack:"id"},bitset:{type:t.UNSIGNED_BYTE,count:1,packTessellation:({isBackground:t,mapAligned:e})=>Zt([[x,t],[m,!!e]])},offset:{type:t.SHORT,count:2,packPrecisionFactor:8,packAlternating:{count:4,packTessellation:({offsets:t})=>{const{bottomLeft:e,bottomRight:s,topLeft:r,topRight:i}=t;return[r,i,e,s]}}},textureUV:{type:t.SHORT,count:2,packPrecisionFactor:4,packAlternating:{count:4,packTessellation:({texcoords:t})=>{const{bottomLeft:e,bottomRight:s,topLeft:r,topRight:i}=t;return[r,i,e,s]}}},color:{type:t.UNSIGNED_BYTE,count:4,normalized:!0,packTessellation:({color:t})=>t},fontSize:{type:t.UNSIGNED_SHORT,count:1,packPrecisionFactor:4,packTessellation:({fontSize:t})=>e(t)},referenceSize:{type:t.UNSIGNED_BYTE,count:1,packPrecisionFactor:4,packTessellation:({fontSize:t},{referenceSize:s})=>e(s??t)},haloColor:{type:t.UNSIGNED_BYTE,count:4,normalized:!0,pack:({haloColor:t})=>jt(t)},haloFontSize:{type:t.UNSIGNED_SHORT,count:1,packPrecisionFactor:4,pack:({haloFontSize:t})=>e(t)}}};class Oe extends Ot{constructor(){super(...arguments),this.vertexSpec=Re,this._textMeshParamsPropsInitialized=!1}ensurePacked(t,e,s){super.ensurePacked(t,e,s),this._textMeshParamsPropsInitialized&&!this._evaluator.hasDynamicProperties||(this._textMeshTransformProps=new Te(this.evaluatedMeshParams),this._textMeshParamsPropsInitialized=!0)}_write(t,e,s){const r=this._getShaping();if(!r)return;const i=e.getDisplayId();if(null!=this.evaluatedMeshParams.placement)return this._writePlacedTextMarkers(t,e,r,s);if(s?.nextPath())return s.nextPoint(),this._writeGlyphs(t,i,s.x,s.y,r,0);if("esriGeometryPolygon"===e.geometryType){const s=e.readCentroidForDisplay();if(!s)return;const[o,n]=s.coords;return this._writeGlyphs(t,i,o,n,r,0)}if("esriGeometryMultipoint"===e.geometryType){const s=e.readGeometryForDisplay();return void s?.forEachVertex(((e,s)=>this._writeGlyphs(t,i,e,s,r,0)))}const o=e.readXForDisplay(),n=e.readYForDisplay();return this._writeGlyphs(t,i,o,n,r,0)}_writePlacedTextMarkers(t,s,r,i){const n=i??o.fromFeatureSetReaderCIM(s);if(!n)return;const a=ve.getPlacement(n,-1,this.evaluatedMeshParams.placement,e(1),t.id,Gt());if(!a)return;const c=s.getDisplayId();let u=a.next();for(;null!=u;){const e=u.tx,s=-u.ty,i=-u.getAngle();this._writeGlyphs(t,c,e,s,r,i),u=a.next()}}_getShaping(t){const s=this._textMeshTransformProps,r=this.evaluatedMeshParams;if(!r.glyphs?.glyphs.length)return null;const i=Math.round(e(s.fontSize)),o=e(s.offsetX),n=e(s.offsetY),a=B(e(r.lineWidth),v,w),c=T*B(r.lineHeightRatio,.25,4);return L(r.glyphs,{scale:i/E,angle:s.postAngle,xOffset:o,yOffset:n,horizontalAlignment:r.horizontalAlignment,verticalAlignment:t||r.verticalAlignment,maxLineWidth:a,lineHeight:c,decoration:r.decoration,borderLineSizePx:e(r.boxBorderLineSize),hasBackground:!!r.boxBackgroundColor,useCIMAngleBehavior:r.useCIMAngleBehavior})}_writeGlyphs(t,s,r,i,o,n,a,c){const u=this.evaluatedMeshParams,l=this._textMeshTransformProps,p=l.fontSize,h=e(l.offsetX),f=e(l.offsetY),[d,x]=Vt(u.scaleInfo,this.getTileInfo());0!==n&&o.setRotation(n);const m=o.bounds,y=r+m.x+h,_=i+m.y-f,g=2*(u.minPixelBuffer?u.minPixelBuffer/p:1),k=Math.max(m.width,m.height)*g;o.textBox&&(t.recordStart(this.instanceId,this.attributeLayout,o.glyphs[0].textureBinding),t.recordBounds(y,_,k,k),this._writeTextBox(t,s,r,i,o.textBox,a,c),t.recordEnd());for(const e of o.glyphs){t.recordStart(this.instanceId,this.attributeLayout,e.textureBinding),t.recordBounds(y,_,k,k);const{texcoords:o,offsets:n}=e;this._writeQuad(t,s,r,i,{texcoords:o,offsets:n,fontSize:p,color:jt(u.color),isBackground:!1,referenceBounds:a,minZoom:d,maxZoom:x,...c}),t.recordEnd()}0!==n&&o.setRotation(-n)}_writeTextBox(t,e,s,r,i,o,n){const a=this.evaluatedMeshParams,{fontSize:c}=this._textMeshTransformProps,{boxBackgroundColor:u,boxBorderLineColor:l}=a,p={isBackground:!0,fontSize:c,referenceBounds:o,...n};u&&(this._writeQuad(t,e,s,r,{texcoords:Ne,offsets:i.main,color:jt(u),...p}),l||(this._writeQuad(t,e,s,r,{texcoords:Be,offsets:i.top,color:jt(u),...p}),this._writeQuad(t,e,s,r,{texcoords:Ge,offsets:i.bot,color:jt(u),...p}),this._writeQuad(t,e,s,r,{texcoords:Fe,offsets:i.left,color:jt(u),...p}),this._writeQuad(t,e,s,r,{texcoords:Le,offsets:i.right,color:jt(u),...p}))),l&&(this._writeQuad(t,e,s,r,{texcoords:ze,offsets:i.top,color:jt(l),...p}),this._writeQuad(t,e,s,r,{texcoords:ze,offsets:i.bot,color:jt(l),...p}),this._writeQuad(t,e,s,r,{texcoords:Ye,offsets:i.left,color:jt(l),...p}),this._writeQuad(t,e,s,r,{texcoords:Ye,offsets:i.right,color:jt(l),...p}))}_writeQuad(t,e,s,r,i){const o=t.vertexCount();this._writeVertex(t,e,s,r,i),t.indexWrite(o+0),t.indexWrite(o+1),t.indexWrite(o+2),t.indexWrite(o+1),t.indexWrite(o+3),t.indexWrite(o+2)}}const Ce=t=>Math.round(t*(254/360)),We={createComputedParams:t=>t,optionalAttributes:ne.optionalAttributes,attributes:{...ne.attributes,bitset:{type:t.UNSIGNED_BYTE,count:1,pack:({shouldSampleAlphaOnly:t,shouldScaleDash:e,isSDF:s})=>Zt([[p,t],[y,e],[_,s]])},tlbr:{type:t.UNSIGNED_SHORT,count:4,pack:({sprite:t})=>{const{rect:e,width:s,height:r}=t,i=e.x+S,o=e.y+S;return[i,o,i+s,o+r]}},accumulatedDistance:{type:t.UNSIGNED_SHORT,count:1,packTessellation:({distance:t})=>t},segmentDirection:{type:t.BYTE,count:2,packPrecisionFactor:16,packTessellation:({directionX:t,directionY:e})=>[t,e]}}};class Ue extends ce{constructor(t,e,s,r){super(t,e,s,r),this.vertexSpec=We,this._tessellationOptions.textured=!0}_write(t,e,s){const r=s??o.fromFeatureSetReaderCIM(e);if(!r)return;const{sprite:i}=this.evaluatedMeshParams;this._writeGeometry(t,e,r,i?.textureBinding)}}class He{static from(t){return"width"in t?this.fromSimpleMeshParams(t):this.fromComplexMeshParams(t)}static fromSimpleMeshParams(t){const s=new He(t.sprite,t.color,t.outlineColor,t.minPixelBuffer,t.placement,t.scaleInfo,t.effects),{type:r,width:i,height:o,angle:n,alignment:a,outlineSize:c,referenceSize:u,sprite:l,overrideOutlineColor:p}=t;return s.rawWidth=e(i),s.rawHeight=e(o),s.angle=n,s.alignment=a,s.outlineSize=e(c),s.referenceSize=e(u),s.overrideOutlineColor=p,s.offsetX=e(t.offsetX),s.offsetY=e(t.offsetY),"simple"!==r||l.sdf||(s.rawWidth=l.width,s.rawHeight=l.height),s.sizeRatio=l.sdf?2:1,s._computeSize(t,!1),s}static fromComplexMeshParams(t){const s=new He(t.sprite,t.color,t.outlineColor,t.minPixelBuffer,t.placement,t.scaleInfo,t.effects);let{alignment:r,transforms:i,size:o,scaleX:n,anchorX:a,anchorY:c,angle:u,colorLocked:l,frameHeight:p,widthRatio:h,offsetX:f,offsetY:d,outlineSize:x,referenceSize:m,scaleFactor:y,sizeRatio:_,isAbsoluteAnchorPoint:g,rotateClockwise:k,scaleSymbolsProportionally:P,sprite:S}=t;if(i&&i.infos.length>0){const t=R(o,u,k,f,d,i);o=t.size,u=t.rotation,f=t.offsetX,d=t.offsetY,k=!1}y&&(o*=y,f*=y,d*=y);const b=n*(S.width/S.height);s.alignment=r,s.rawHeight=e(o),s.rawWidth=s.rawHeight*b,s.referenceSize=e(m),s.sizeRatio=_,s.angle=u,s.rotateClockwise=k,s.anchorX=a,s.anchorY=c,s.offsetX=e(f),s.offsetY=e(d),g&&o&&(S.sdf?s.anchorX=a/(o*h):s.anchorX=a/(o*b),s.anchorY=c/o);const w=P&&p?o/p:1;return s.outlineSize=0===x||isNaN(x)?0:e(x)*w,s.scaleSymbolsProportionally=P,s.colorLocked=l,s._computeSize(t,!0),s}constructor(t,e,s,r,i,o,n){this.sprite=t,this.color=e,this.outlineColor=s,this.minPixelBuffer=r,this.placement=i,this.scaleInfo=o,this.effects=n,this.rawWidth=0,this.rawHeight=0,this.angle=0,this.outlineSize=0,this.referenceSize=0,this.sizeRatio=1,this.alignment=K.SCREEN,this.scaleSymbolsProportionally=!1,this.overrideOutlineColor=!1,this.colorLocked=!1,this.anchorX=0,this.anchorY=0,this.computedWidth=0,this.computedHeight=0,this.texXmin=0,this.texYmin=0,this.texXmax=0,this.texYmax=0,this.offsetX=0,this.offsetY=0,this.rotateClockwise=!0}get boundsInfo(){return{size:Math.max(this.computedHeight,this.computedWidth),offsetX:this.offsetX,offsetY:this.offsetY}}_computeSize(t,e){const{sprite:s,hasSizeVV:r}=t,i=!!s.sdf,{rawWidth:o,rawHeight:n,sizeRatio:a,outlineSize:c}=this,u=o*a,l=n*a;if(i&&!r){const t=e&&o>n?u:o,s=n,r=c+2;this.computedWidth=Math.min(t+r,u),this.computedHeight=Math.min(s+r,l)}else this.computedWidth=u,this.computedHeight=l;const p=i?Math.max(s.width,s.height)/Math.max(u,l):1,h=.5*(u-this.computedWidth)*p,f=.5*(l-this.computedHeight)*p,d=s.rect.x+S+h,x=s.rect.y+S+f,m=d+s.width-2*h,y=x+s.height-2*f;this.texXmin=Math.floor(d),this.texYmin=Math.floor(x),this.texXmax=Math.ceil(m),this.texYmax=Math.ceil(y),this.computedWidth*=(this.texXmax-this.texXmin)/(m-d),this.computedHeight*=(this.texYmax-this.texYmin)/(y-x),this.anchorX*=u/this.computedWidth,this.anchorY*=l/this.computedHeight}}const Ve=128/Math.PI,Xe={createComputedParams:t=>He.from(t),optionalAttributes:{zoomRange:{type:t.SHORT,count:2,packPrecisionFactor:P,pack:({scaleInfo:t},{tileInfo:e})=>Vt(t,e)}},attributes:{pos:{type:t.SHORT,count:2,pack:"position",packPrecisionFactor:10},id:{type:t.UNSIGNED_BYTE,count:3,pack:"id"},bitset:{type:t.UNSIGNED_BYTE,count:1,pack:({sprite:t,alignment:e,scaleSymbolsProportionally:s,overrideOutlineColor:r,colorLocked:i})=>{let o=0;return t.sdf&&(o|=Xt(g.bitset.isSDF)),e===K.MAP&&(o|=Xt(g.bitset.isMapAligned)),s&&(o|=Xt(g.bitset.scaleSymbolsProportionally)),r&&(o|=Xt(g.bitset.overrideOutlineColor)),i&&(o|=Xt(g.bitset.colorLocked)),o}},offset:{type:t.SHORT,count:2,packPrecisionFactor:4,packAlternating:{count:4,pack:({angle:t,computedWidth:e,computedHeight:s,anchorX:r,anchorY:i,offsetX:o,offsetY:n,rotateClockwise:a})=>{const c=function(t,e,s,r,i=!1){const o=V(),n=i?1:-1;return W(o),(e||s)&&U(o,o,[e,-s]),r&&H(o,o,.017453292519944444*n*-r),o}(0,o,n,-t,a),u=-(.5+r)*e,l=-(.5-i)*s,p=[u,l],h=[u+e,l],f=[u,l+s],d=[u+e,l+s];return X(p,p,c),X(h,h,c),X(f,f,c),X(d,d,c),[p,h,f,d]}}},textureUV:{type:t.SHORT,count:2,packPrecisionFactor:4,packAlternating:{count:4,pack:({texXmax:t,texXmin:e,texYmax:s,texYmin:r})=>[[e,r],[t,r],[e,s],[t,s]]}},color:{type:t.UNSIGNED_BYTE,count:4,normalized:!0,pack:({color:t})=>jt(t)},outlineColor:{type:t.UNSIGNED_BYTE,count:4,normalized:!0,pack:({outlineColor:t})=>jt(t)},sizing:{type:t.UNSIGNED_BYTE,count:4,pack:({rawWidth:t,rawHeight:e,outlineSize:s,referenceSize:r})=>[qt(Math.max(t,e),128),qt(s,128),qt(r,128),0]},placementAngle:{type:t.UNSIGNED_BYTE,count:1,packTessellation:({placementAngle:t})=>{return e=t*Ve,e%=256,Math.abs(e>=0?e:e+256);var e}},sizeRatio:{type:t.UNSIGNED_SHORT,count:1,packPrecisionFactor:64,pack:({sizeRatio:t})=>t}}};class Ze extends Ot{constructor(){super(...arguments),this.vertexSpec=Xe}getBoundsInfo(){return this.evaluatedMeshParams.boundsInfo}_write(t,e,s){const r=this.evaluatedMeshParams.sprite?.textureBinding,i=e.getDisplayId();t.recordStart(this.instanceId,this.attributeLayout,r);const o=this.evaluatedMeshParams.minPixelBuffer,n=Math.max(this.evaluatedMeshParams.computedWidth,o),a=Math.max(this.evaluatedMeshParams.computedHeight,o),c=this.evaluatedMeshParams.offsetX,u=-this.evaluatedMeshParams.offsetY;if(null!=this.evaluatedMeshParams.placement)this._writePlacedMarkers(t,e,s,n,a);else if(s?.nextPath()){s.nextPoint();const e=s.x,r=s.y;t.recordBounds(e+c,r+u,n,a),this._writeQuad(t,i,e,r)}else if("esriGeometryPolygon"===e.geometryType){const s=e.readCentroidForDisplay();if(!s)return;const[r,o]=s.coords;t.recordBounds(r+c,o+u,n,a),this._writeQuad(t,i,r,o)}else if("esriGeometryPoint"===e.geometryType){const s=e.readXForDisplay(),r=e.readYForDisplay();t.recordBounds(s+c,r+u,n,a),this._writeQuad(t,i,s,r)}else{const s=e.readGeometryForDisplay();s?.forEachVertex(((e,s)=>{t.recordBounds(e+c,s+u,n,a),Math.abs(e)>Z||Math.abs(s)>Z||this._writeQuad(t,i,e,s)}))}t.recordEnd()}_writePlacedMarkers(t,s,r,i,n){const a=r??o.fromFeatureSetReaderCIM(s)?.clone();if(!a)return;const c=ve.getPlacement(a,-1,this.evaluatedMeshParams.placement,e(1),t.id,Gt());if(!c)return;const u=s.getDisplayId();let l=c.next();const p=this.evaluatedMeshParams.offsetX,h=-this.evaluatedMeshParams.offsetY;for(;null!=l;){const e=l.tx,s=-l.ty;if(Math.abs(e)>Z||Math.abs(s)>Z){l=c.next();continue}const r=-l.getAngle();t.recordBounds(e+p,s+h,i,n),this._writeQuad(t,u,e,s,r),l=c.next()}}_writeQuad(t,e,s,r,i){const o=t.vertexCount(),n=null==i?null:{placementAngle:i};this._writeVertex(t,e,s,r,n),t.indexWrite(o+0),t.indexWrite(o+1),t.indexWrite(o+2),t.indexWrite(o+1),t.indexWrite(o+3),t.indexWrite(o+2)}}const je={createComputedParams:t=>t,optionalAttributes:{},attributes:{pos:{type:t.SHORT,count:2,packPrecisionFactor:10,pack:"position"},id:{type:t.UNSIGNED_BYTE,count:3,pack:"id"},bitset:{type:t.UNSIGNED_BYTE,count:1,pack:t=>0},offset:{type:t.SHORT,count:2,packPrecisionFactor:16,packAlternating:{count:4,pack:({size:t})=>{const s=e(t),r=-s/2,i=-s/2;return[[r,i],[r+s,i],[r,i+s],[r+s,i+s]]}}},texCoords:{type:t.SHORT,count:2,packPrecisionFactor:4,packAlternating:{count:4,pack:()=>[[0,1],[1,1],[0,0],[1,0]]}},size:{type:t.UNSIGNED_BYTE,count:2,pack:({size:t})=>[t,t]},referenceSize:{type:t.UNSIGNED_BYTE,count:1,pack:({size:t})=>e(t)},zoomRange:{type:t.UNSIGNED_BYTE,count:2,pack:({scaleInfo:t},{tileInfo:e})=>Vt(t,e)}}};class qe extends Ot{constructor(){super(...arguments),this.vertexSpec=je}_write(t,s){const r=s.getDisplayId(),i=this.evaluatedMeshParams.minPixelBuffer,o=Math.max(e(this.evaluatedMeshParams.size),i);let n,a;if("esriGeometryPoint"===s.geometryType)n=s.readXForDisplay(),a=s.readYForDisplay();else{const t=s.readCentroidForDisplay();if(!t)return;n=t?.coords[0],a=t?.coords[1]}t.recordStart(this.instanceId,this.attributeLayout),t.recordBounds(n,a,o,o);const c=t.vertexCount();this._writeVertex(t,r,n,a),t.indexWrite(c+0),t.indexWrite(c+1),t.indexWrite(c+2),t.indexWrite(c+1),t.indexWrite(c+3),t.indexWrite(c+2),t.recordEnd()}}export{_e as C,Ht as D,Kt as F,we as H,ce as L,Ze as M,he as O,qe as P,Oe as T,Ue as a,Se as b,te as c,ie as d,Yt as e,Vt as g,Ee as m,jt as p};
