/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.30/esri/copyright.txt for details.
*/
import{_ as e}from"./tslib.es6.js";import t from"../request.js";import i from"../core/Accessor.js";import{B as a}from"./ByteSizeUnit.js";import l from"../core/Error.js";import{m as r}from"./handleUtils.js";import{n as s,clone as o,m as n}from"../core/lang.js";import{L as h}from"./LRUCache.js";import{P as c,waitTicks as m}from"../core/scheduling.js";import{isAbortError as f,isAborted as p,onAbort as u,createAbortError as v}from"../core/promiseUtils.js";import{watch as d,initial as y}from"../core/reactiveUtils.js";import{objectToQuery as w}from"../core/urlUtils.js";import{property as b}from"../core/accessorSupport/decorators/property.js";import"./Logger.js";import{subclass as g}from"../core/accessorSupport/decorators/subclass.js";import{T as _}from"./TileKey.js";class A{constructor(e){!function(e){if(!e?.location)throw new l("tilemap:missing-location","Location missing from tilemap response");if(!1===e.valid)throw new l("tilemap:invalid","Tilemap response was marked as invalid");if(!e.data)throw new l("tilemap:missing-data","Data missing from tilemap response");if(!Array.isArray(e.data))throw new l("tilemap:data-mismatch","Data must be an array of numbers");if(e.data.length!==e.location.width*e.location.height)throw new l("tilemap:data-mismatch","Number of data items does not match width/height of tilemap")}(e);const{location:t,data:i}=e;this.location=Object.freeze(o(t));const a=this.location.width,r=this.location.height;let h=!0,c=!0;const m=function(e,t=!1){return e<=s?t?new Array(e).fill(0):new Array(e):new Uint32Array(e)}(Math.ceil(a*r/32));let f=0;for(let e=0;e<i.length;e++){const t=e%32;i[e]?(c=!1,m[f]|=1<<t):h=!1,31===t&&++f}c?(this._availability="unavailable",this.byteSize=40):h?(this._availability="available",this.byteSize=40):(this._availability=m,this.byteSize=40+n(m))}getAvailability(e,t){if("unavailable"===this._availability||"available"===this._availability)return this._availability;const i=(e-this.location.top)*this.location.width+(t-this.location.left),a=i%32,l=i>>5,r=this._availability;return l<0||l>r.length?"unknown":r[l]&1<<a?"available":"unavailable"}static fromDefinition(e,i){const a=e.service.request||t,{row:r,col:s,width:o,height:n}=e,h={query:{f:"json"}};return i=i?{...h,...i}:h,a(function(e){let t;if(e.service.tileServers?.length){const i=e.service.tileServers;t=`${i&&i.length?i[e.row%i.length]:e.service.url}/tilemap/${e.level}/${e.row}/${e.col}/${e.width}/${e.height}`}else t=`${e.service.url}/tilemap/${e.level}/${e.row}/${e.col}/${e.width}/${e.height}`;const i=e.service.query;return i&&(t=`${t}?${i}`),t}(e),i).then((e=>e.data)).catch((e=>{if(422===e?.details?.httpStatus)return{location:{top:r,left:s,width:o,height:n},valid:!0,data:new Array(o*n).fill(0)};throw e})).then((e=>{if(e.location&&(e.location.top!==r||e.location.left!==s||e.location.width!==o||e.location.height!==n))throw new l("tilemap:location-mismatch","Tilemap response for different location than requested",{response:e,definition:{top:r,left:s,width:o,height:n}});return A.fromJSON(e)}))}static fromJSON(e){return Object.freeze(new A(e))}}function T(e){return`${e.level}/${e.row}/${e.col}/${e.width}/${e.height}`}var j;let D=j=class extends i{constructor(e){super(e),this._pendingTilemapRequests={},this.request=t,this.size=32,this._prefetchingEnabled=!0}initialize(){this._tilemapCache=new h(2*a.MEGABYTES),this.addHandles(d((()=>{const{layer:e}=this;return[e?.parsedUrl,e?.tileServers,e?.apiKey,e?.customParameters]}),(()=>this._initializeTilemapDefinition()),y))}get effectiveMinLOD(){return this.minLOD??this.layer.tileInfo.lods[0].level}get effectiveMaxLOD(){return this.maxLOD??this.layer.tileInfo.lods[this.layer.tileInfo.lods.length-1].level}getAvailability(e,t,i){if(!this.layer.tileInfo.lodAt(e)||e<this.effectiveMinLOD||e>this.effectiveMaxLOD)return"unavailable";const a=this._tilemapFromCache(e,t,i,this._tmpTilemapDefinition);return a?a.getAvailability(t,i):"unknown"}fetchAvailability(e,t,i,a){return!this.layer.tileInfo.lodAt(e)||e<this.effectiveMinLOD||e>this.effectiveMaxLOD?Promise.reject(new l("tile-map:tile-unavailable","Tile is not available",{level:e,row:t,col:i})):this._fetchTilemap(e,t,i,a).catch((e=>e)).then((a=>{if(a instanceof A){const r=a.getAvailability(t,i);if("unavailable"===r)throw new l("tile-map:tile-unavailable","Tile is not available",{level:e,row:t,col:i});return r}if(f(a))throw a;return"unknown"}))}fetchAvailabilityUpsample(e,t,i,a,l){a.level=e,a.row=t,a.col=i;const r=this.layer.tileInfo;r.updateTileInfo(a);const s=this.fetchAvailability(e,t,i,l).catch((e=>{if(f(e))throw e;if(r.upsampleTile(a))return this.fetchAvailabilityUpsample(a.level,a.row,a.col,a,l);throw e}));return this._fetchAvailabilityUpsamplePrefetch(a.id,e,t,i,l,s),s}async _fetchAvailabilityUpsamplePrefetch(e,t,i,a,l,s){if(!this._prefetchingEnabled||null==e)return;const o=`prefetch-${e}`;if(this.hasHandles(o))return;const n=new AbortController;s.then((()=>n.abort()),(()=>n.abort()));let h=!1;const c=r((()=>{h||(h=!0,n.abort())}));if(this.addHandles(c,o),await m(10,n.signal).catch((()=>{})),h||(h=!0,this.removeHandles(o)),p(n))return;const f=new _(e,t,i,a),u={...l,signal:n.signal},v=this.layer.tileInfo;for(let e=0;j._prefetches.length<j._maxPrefetch&&v.upsampleTile(f);++e){const e=this.fetchAvailability(f.level,f.row,f.col,u);j._prefetches.push(e);const t=()=>{j._prefetches.removeUnordered(e)};e.then(t,t)}}_fetchTilemap(e,t,i,a){if(!this.layer.tileInfo.lodAt(e)||e<this.effectiveMinLOD||e>this.effectiveMaxLOD)return Promise.reject(new l("tilemap-cache:level-unavailable",`Level ${e} is unavailable in the service`));const r=this._tmpTilemapDefinition,s=this._tilemapFromCache(e,t,i,r);if(s)return Promise.resolve(s);const o=a?.signal;return a={...a,signal:null},new Promise(((e,t)=>{u(o,(()=>t(v())));const i=T(r);let l=this._pendingTilemapRequests[i];if(!l){l=A.fromDefinition(r,a).then((e=>(this._tilemapCache.put(i,e,e.byteSize),e)));const e=()=>{delete this._pendingTilemapRequests[i]};this._pendingTilemapRequests[i]=l,l.then(e,e)}l.then(e,t)}))}_initializeTilemapDefinition(){if(!this.layer.parsedUrl)return;const{parsedUrl:e,apiKey:t,customParameters:i}=this.layer;this._tilemapCache.clear(),this._tmpTilemapDefinition={service:{url:e.path,query:w({...e.query,...i,token:t??e.query?.token}),tileServers:this.layer.tileServers,request:this.request},width:this.size,height:this.size,level:0,row:0,col:0}}_tilemapFromCache(e,t,i,a){a.level=e,a.row=t-t%this.size,a.col=i-i%this.size;const l=T(a);return this._tilemapCache.get(l)}get test(){}};D._maxPrefetch=4,D._prefetches=new c({initialSize:j._maxPrefetch}),e([b({constructOnly:!0})],D.prototype,"layer",void 0),e([b({constructOnly:!0})],D.prototype,"minLOD",void 0),e([b({constructOnly:!0})],D.prototype,"maxLOD",void 0),e([b({constructOnly:!0})],D.prototype,"request",void 0),e([b({constructOnly:!0})],D.prototype,"size",void 0),D=j=e([g("esri.layers.support.TilemapCache")],D);export{D as T};
