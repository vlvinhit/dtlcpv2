/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.30/esri/copyright.txt for details.
*/
import{_ as t}from"./tslib.es6.js";import"../geometry.js";import e from"../Viewpoint.js";import i from"../core/Accessor.js";import s from"../core/Error.js";import{h as o}from"../core/lang.js";import{L as r}from"./Logger.js";import{watch as n,sync as a}from"../core/reactiveUtils.js";import{c as p}from"./screenUtils.js";import{subclass as c,W as h}from"../core/accessorSupport/decorators/subclass.js";import{property as d}from"../core/accessorSupport/decorators/property.js";import{f as l,F as g}from"./unitUtils.js";import v from"../geometry/Point.js";import{project as w}from"../geometry/projection.js";import{g as m,s as u,m as f}from"./vec2.js";import{c as y}from"./vec2f64.js";import{i as _,j,s as x,r as S,k as z,c as R,l as V,m as b,n as N}from"./viewpointUtils.js";import C from"../views/2d/ViewState.js";import G from"../geometry/Extent.js";var P,L;let M=P=class extends i{constructor(){super(...arguments),this.left=0,this.top=0,this.right=0,this.bottom=0}clone(){return new P({left:this.left,top:this.top,right:this.right,bottom:this.bottom})}};t([d()],M.prototype,"left",void 0),t([d()],M.prototype,"top",void 0),t([d()],M.prototype,"right",void 0),t([d()],M.prototype,"bottom",void 0),M=P=t([c("esri.views.2d.PaddedViewState.Padding")],M);let O=L=class extends C{constructor(...t){super(...t),this.paddedViewState=new C,this._updateContent=(()=>{const t=y();return()=>{const e=this._get("size"),i=this._get("padding");if(!e||!i)return;const s=this.paddedViewState;m(t,i.left+i.right,i.top+i.bottom),u(t,e,t),f(s.size,t);const o=s.viewpoint;o&&(this.viewpoint=o)}})(),this.addHandles(n((()=>[this.size,this.padding]),(()=>this._updateContent()),a)),this.padding=new M,this.size=[0,0]}set padding(t){this._set("padding",t||new M)}set viewpoint(t){if(t){this.paddedViewState.viewpoint=t;const e=this._viewpoint2D;if(this._get("padding")){const i=t.clone();_(i,t,this._get("size"),this._get("padding"));const s=i.targetGeometry;e.center[0]=s.x,e.center[1]=s.y,e.rotation=i.rotation,e.scale=i.scale,e.spatialReference=s.spatialReference}else{const i=t.targetGeometry;e.center[0]=i.x,e.center[1]=i.y,e.rotation=t.rotation,e.scale=t.scale,e.spatialReference=i.spatialReference}this._update()}}clone(){return new L({padding:this.padding.clone(),size:this.size.slice(),viewpoint:this.paddedViewState.viewpoint.clone(),pixelRatio:this.pixelRatio})}};t([d()],O.prototype,"paddedViewState",void 0),t([d({type:M})],O.prototype,"padding",null),t([d()],O.prototype,"viewpoint",null),O=L=t([c("esri.views.2d.PaddedViewState")],O);const T=O;let U=class extends i{constructor(t){super(t),this.constraints=null,this.ready=!1,this.resizeAlign="center",this.addHandles([n((()=>this.constraints?.version),(t=>{this.constraints&&t&&this.ready&&(this.state.viewpoint=this.constraints.fit(this.state.paddedViewState.viewpoint))}),a)])}get center(){if(!this.ready)return this._get("center");const{center:t,spatialReference:e}=this.state.paddedViewState;return this.state.commitProperty("id"),new v({x:t[0],y:t[1],spatialReference:e})}set center(t){if(null==t)return;if(!this.ready)return void this._set("center",t);let e;try{e=this._project(t,this.state.spatialReference)}catch(e){return void r.getLogger(this).error(new s("mapview:invalid-center","could not project the value in the view's spatial reference",{input:t,error:e}))}const i=this.viewpoint;j(i,i,e),this.viewpoint=i}get extent(){return this.ready?(this.state.commitProperty("id"),this.state.paddedViewState.extent.clone()):this._get("extent")}set extent(t){if(null==t)return;if(!t.width||!t.height)return void r.getLogger(this).error(new s("mapview:invalid-extent","invalid extent size"));if(!this.ready)return this._set("extent",t),this._set("center",void 0),this._set("viewpoint",void 0),this._set("scale",void 0),void this._set("zoom",void 0);let e;try{e=this._project(t,this.state.spatialReference)}catch(t){return void r.getLogger(this).error(new s("mapview:invalid-extent","could not project the value in the view's spatial reference",{error:t}))}const i=this.viewpoint;x(i,i,e,this.state.size,{constraints:this.constraints}),this.viewpoint=i}get padding(){return this.ready?this.state.padding:this._get("padding")}set padding(t){this.ready?(this.state.padding=t,this._set("padding",this.state.padding)):this._set("padding",t)}get resolution(){return this.ready?(this.state.commitProperty("id"),this.state.resolution):0}get rotation(){return this.ready?(this.state.commitProperty("id"),this.state.rotation):this._get("rotation")}set rotation(t){if(isNaN(t))return;if(!this.ready)return void this._set("rotation",t);const e=this.viewpoint;S(e,e,t),this.viewpoint=e}get scale(){return this.ready?(this.state.commitProperty("id"),this.state.scale):this._get("scale")}set scale(t){if(!t||isNaN(t))return;if(!this.ready){this._set("scale",t),this._set("zoom",void 0);const e=this._get("extent");return void(e&&(this._set("extent",void 0),this._set("center",e.center)))}const e=this.viewpoint;z(e,e,t),this.viewpoint=e}get viewpoint(){return this.ready?this.state.paddedViewState.viewpoint.clone():this._get("viewpoint")}set viewpoint(t){if(null==t)return;if(!this.ready)return this._set("viewpoint",t),this._set("extent",void 0),this._set("center",void 0),this._set("zoom",void 0),void this._set("scale",void 0);let i,o;try{i=this._project(t,this.state.spatialReference),!t.scale||isNaN(t.scale)?o=new s("mapview:invalid-viewpoint",`invalid scale value of ${t.scale}`):null==t.targetGeometry&&(o=new s("mapview:invalid-viewpoint","geometry not defined"))}catch(t){o=new s("mapview:invalid-viewpoint","could not project the value in the view's spatial reference",{error:t})}if(o)return void r.getLogger(this).error(o);this._scaleBeforeChangingSpatialReference=null;const n=new e({targetGeometry:new v,scale:0,rotation:0});R(n,i),this.constraints?.constrain(n,this.state.paddedViewState.viewpoint),this.state.viewpoint=n,this._set("viewpoint",n)}get zoom(){return this.ready?this.constraints?.scaleToZoom(this.scale)??-1:this._get("zoom")}set zoom(t){if(!(t>=0))return;if(!this.ready){this._set("zoom",t),this._set("scale",void 0);const e=this._get("extent");return void(e&&(this._set("extent",void 0),this._set("center",e.center)))}const e=this.constraints?.zoomToScale(t)??0;if(!e)return void this._set("zoom",-1);const i=this.viewpoint;z(i,i,e),this.viewpoint=i,this._set("zoom",this.constraints?.scaleToZoom(this.scale)??-1)}getUserStartupOptions(t){if(!t[0]&&!t[1])return{center:void 0,rotation:void 0,scale:void 0};const{padding:e,constraints:i}=this,s=this._get("center"),o=this._get("extent"),r=this._get("scale"),n=this._get("rotation"),a=this._get("viewpoint"),p=this._get("zoom"),c=null!=p&&null!=i&&i.zoomToScale(p)||void 0;let h,d,l;const g=a?.rotation,v=a?.targetGeometry;"extent"===v?.type?h=v:"point"===v?.type&&(d=v,l=a?.scale);const w=o??h;return{center:s??d??w?.center,rotation:n??g,scale:(r??c??l??(w&&V(w,[t[0]-e.left-e.right,t[1]-e.top-e.bottom])))||void 0}}startup(t,e,i,s){const o=t.targetGeometry;try{this._project(t,i)}catch(e){r.getLogger(this).warn(new h("mapview:startup-projection-error","projection of initial viewpoint to the view's spatial reference, defaulting to the initial viewpoint.",{center:o.toJSON(),spatialReference:i,error:e})),t.targetGeometry=s||new v({x:0,y:0,spatialReference:i})}this.constraints?.fit(t),this._set("state",new T({padding:this.padding,size:e,viewpoint:t})),this._set("ready",!0)}teardown(){this._set("ready",!1);const{center:[t,e],spatialReference:i,rotation:s,scale:o}=this.state.paddedViewState,r=new v({x:t,y:e,spatialReference:i});this._set("viewpoint",null),this._set("extent",null),this._set("center",r),this._set("zoom",-1),this._set("rotation",s),this._set("scale",o),this._set("state",null)}changeSpatialReference(t){const i=this.state.paddedViewState.clone();if(null==this._scaleBeforeChangingSpatialReference)this._scaleBeforeChangingSpatialReference=i.scale;else{const t=i.viewpoint.clone();t.scale=this._scaleBeforeChangingSpatialReference,i.viewpoint=t}const s=i.clone(),[n,a]=i.center;let p=null;try{p=this._project(new v({x:n,y:a,spatialReference:i.spatialReference}),t)}catch(e){g()||r.getLogger(this).warn(new h("mapview:spatial-reference-change","could not project the view's center to the new spatial reference",{center:p?.toJSON(),spatialReference:t,error:e}))}p||(p=new v({x:0,y:0,spatialReference:t}));const c=j(new e({targetGeometry:new v,scale:0,rotation:0}),i.viewpoint,p);s.viewpoint=c;try{const e=20,r=[i.size[0]/2,i.size[1]/2],n=[r[0]+e,r[1]],a=i.toMap([0,0],n),{x:p,y:h}=this._project(new v({x:a[0],y:a[1],spatialReference:i.spatialReference}),t);a[0]=p,a[1]=h,s.toScreen(a,a);const d=b(r,a,n),l=Math.hypot(a[0]-r[0],a[1]-r[1])/e;!Number.isFinite(l)||Math.abs(l)>4?(c.rotation=0,c.targetGeometry=new v({x:0,y:0,spatialReference:t})):(c.scale*=l,c.scale>o("mapview-srswitch-adjust-rotation-scale-threshold")?c.rotation=0:c.rotation+=Number.isFinite(d)?d:0)}catch{}this._get("constraints")?.constrain(c,void 0),this._get("state").viewpoint=c}resize(t,e){if(!this.ready)return;const i=this.state;let s=this.state.paddedViewState.viewpoint;const o=this.state.paddedViewState.size.concat();i.size=[t,e],N(s,s,o,this.state.paddedViewState.size,this.resizeAlign),s=this.constraints?.constrain(s,void 0)??s,this.state.viewpoint=s}toMap(t){if(!this.ready)return null;const[e,i]=this.state.toMap([0,0],[t.x,t.y]),s=this.state.spatialReference;return new v({x:e,y:i,spatialReference:s})}toScreen(t,e){if(!this.ready)return null;const i=this._project(t,this.state.spatialReference),s=[i.x,i.y];return!1===e?.pickClosestTarget||this.state.paddedViewState.wrapMapCoordinate(s,s),this.state.toScreen(s,s),p(s[0],s[1])}_project(t,e){const i=t?.targetGeometry||t;if(!e)return t;if(!i)return null;if(e.imageCoordinateSystem||i.spatialReference?.imageCoordinateSystem)return t;if(l(e,i.spatialReference))return t;const o=w(i,e);if(!o)throw new s("mapview:projection-not-possible","projecting input geometry to target spatial reference returned a null value",{geometry:i,spatialReference:e});return function(t){return"esri.Viewpoint"===t?.declaredClass}(t)?(t.targetGeometry=o,t):o}};t([d({type:v})],U.prototype,"center",null),t([d()],U.prototype,"constraints",void 0),t([d({type:G})],U.prototype,"extent",null),t([d({value:{top:0,right:0,bottom:0,left:0},cast:t=>({top:0,right:0,bottom:0,left:0,...t})})],U.prototype,"padding",null),t([d()],U.prototype,"ready",void 0),t([d()],U.prototype,"resizeAlign",void 0),t([d({readOnly:!0})],U.prototype,"resolution",null),t([d({type:Number})],U.prototype,"rotation",null),t([d({type:Number})],U.prototype,"scale",null),t([d({readOnly:!0})],U.prototype,"state",void 0),t([d({type:e})],U.prototype,"viewpoint",null),t([d()],U.prototype,"zoom",null),U=t([c("esri.views.2d.ViewStateManager")],U);export{T as P,U as V};
