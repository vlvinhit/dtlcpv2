/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.30/esri/copyright.txt for details.
*/
import e from"../Color.js";import t from"../request.js";import r from"../core/Error.js";import{g as o}from"./ensureType.js";import{h as s,r as n}from"./mathUtils.js";import{n as i,f as a}from"./mat3.js";import{c as m}from"./mat3f64.js";import{f as l}from"./vec3f64.js";import{f as p}from"./vec4f64.js";import c from"../geometry/support/MeshComponent.js";import u from"../geometry/support/MeshMaterialMetallicRoughness.js";import f from"../geometry/support/MeshTexture.js";import j from"../geometry/support/MeshTextureTransform.js";import{M as g}from"./MeshVertexAttributes.js";import{s as d}from"./meshVertexSpaceUtils.js";import{d as x,o as y,s as T,n as h,B as v,r as b,a as w,c as M}from"./BufferView.js";import{c as C,d as R,e as A,s as S}from"./vec32.js";import{a as U,n as E,s as B}from"./vec42.js";import{e as O}from"./types.js";import"../core/lang.js";import{c as V}from"./vertexSpaceConversion.js";import{D as $,l as F,c as G,f as P,a as L,n as D,b as I,d as q,e as _,g as z}from"./DefaultMaterial_COLOR_GAMMA.js";import{i as N}from"./resourceUtils3.js";import{T as k}from"./enums.js";import"./colorUtils.js";import"./vec3.js";import"./common.js";import"./Logger.js";import"../config.js";import"../kernel.js";import"../core/urlUtils.js";import"../core/JSONSupport.js";import"./tslib.es6.js";import"../core/Accessor.js";import"../core/Handles.js";import"./maybe.js";import"../core/accessorSupport/decorators/subclass.js";import"./metadata.js";import"./utils.js";import"./handleUtils.js";import"./tracking.js";import"../core/accessorSupport/decorators/property.js";import"./ObservableBase.js";import"../core/scheduling.js";import"../core/promiseUtils.js";import"../core/accessorSupport/decorators/cast.js";import"../geometry/support/MeshMaterial.js";import"./imageUtils.js";import"./reader.js";import"./writer.js";import"./persistableUrlUtils.js";import"../core/Clonable.js";import"../geometry/Point.js";import"../geometry/Geometry.js";import"../geometry/SpatialReference.js";import"./unitUtils.js";import"./jsonMap.js";import"./assets.js";import"../geometry/support/webMercatorUtils.js";import"../geometry/support/MeshGeoreferencedVertexSpace.js";import"./enumeration.js";import"../geometry/support/MeshLocalVertexSpace.js";import"./vec2.js";import"./vec4.js";import"./mat4.js";import"./mat4f64.js";import"./spatialReferenceEllipsoidUtils.js";import"./computeTranslationToOriginAndRotation.js";import"./projectBuffer.js";import"./geodesicConstants.js";import"./projectPointToVector.js";import"../geometry/projection.js";import"./SimpleObservable.js";import"../geometry/Extent.js";import"../geometry/Multipoint.js";import"./zmUtils.js";import"../geometry/Polygon.js";import"./coordsUtils.js";import"./Axis.js";import"./extentUtils.js";import"./aaBoundingRect.js";import"../geometry/Polyline.js";import"../geometry/support/GeographicTransformation.js";import"../geometry/support/GeographicTransformationStep.js";import"./zscale.js";import"./projection.js";import"./DoubleArray.js";import"./asyncUtils.js";import"./Version.js";import"./quat.js";import"./quatf64.js";import"./Indices.js";import"./basicInterfaces.js";function H(e,t){return new e(new ArrayBuffer(t*e.ElementCount*O(e.ElementType)))}async function J(s,i,a){const m=new $(function(e){const r=e?.resolveFile;return r?{busy:!1,request:async(e,o,s)=>{const n=r?.(e)??e,i="image"===o?"image":"binary"===o||"image+type"===o?"array-buffer":"json";return(await t(n,{responseType:i,signal:s?.signal,timeout:0})).data}}:null}(a)),c=(await F(m,i,a,!0)).model,T=c.lods.shift(),h=new Map,b=new Map;c.textures.forEach(((e,t)=>{return h.set(t,new f({data:(N((o=e).data),o.data),wrap:(r=o.parameters.wrap,{horizontal:X(r.s),vertical:X(r.t)})}));var r,o})),c.materials.forEach(((t,r)=>b.set(r,function(t,r){const o=new e((a=t.color,m=t.opacity,p(Y(a[0]),Y(a[1]),Y(a[2]),m))),s=t.emissiveFactor?new e(function(e){return l(Y(e[0]),Y(e[1]),Y(e[2]))}(t.emissiveFactor)):null,i=e=>e?new j({scale:e.scale?[e.scale[0],e.scale[1]]:[1,1],rotation:n(e.rotation??0),offset:e.offset?[e.offset[0],e.offset[1]]:[0,0]}):null;var a,m;return new u({color:o,colorTexture:r.get(t.textureColor),normalTexture:r.get(t.textureNormal),emissiveColor:s,emissiveTexture:r.get(t.textureEmissive),occlusionTexture:r.get(t.textureOcclusion),alphaMode:W(t.alphaMode),alphaCutoff:t.alphaCutoff,doubleSided:t.doubleSided,metallic:t.metallicFactor,roughness:t.roughnessFactor,metallicRoughnessTexture:r.get(t.textureMetallicRoughness),colorTextureTransform:i(t.colorTextureTransform),normalTextureTransform:i(t.normalTextureTransform),occlusionTextureTransform:i(t.occlusionTextureTransform),emissiveTextureTransform:i(t.emissiveTextureTransform),metallicRoughnessTextureTransform:i(t.metallicRoughnessTextureTransform)})}(t,h))));const C=function(e){let t=0;const r={color:!1,tangent:!1,normal:!1,texCoord0:!1},s=new Map,n=new Map,i=[];for(const m of e.parts){const{attributes:{position:e,normal:l,color:p,tangent:c,texCoord0:u}}=m,f=`\n      ${K(e,s)}/\n      ${K(l,s)}/\n      ${K(p,s)}/\n      ${K(c,s)}/\n      ${K(u,s)}/\n      ${a=m.transform,null!=a?a.toString():"-"}\n    `;let j=!1;const g=o(n,f,(()=>(j=!0,{start:t,length:e.count})));j&&(t+=e.count),l&&(r.normal=!0),p&&(r.color=!0),c&&(r.tangent=!0),u&&(r.texCoord0=!0),i.push({gltf:m,writeVertices:j,region:g})}var a;return{vertexAttributes:{position:H(w,t),normal:r.normal?H(v,t):null,tangent:r.tangent?H(x,t):null,color:r.color?H(y,t):null,texCoord0:r.texCoord0?H(M,t):null},parts:i,components:[]}}(T);for(const e of C.parts)Q(C,e,b);const{position:R,normal:A,tangent:S,color:U,texCoord0:E}=C.vertexAttributes,B=d(s,a),O=s.spatialReference.isGeographic?d(s):B,G=V({vertexAttributes:{position:R.typedBuffer,normal:A?.typedBuffer,tangent:S?.typedBuffer},vertexSpace:O,spatialReference:s.spatialReference},B,{allowBufferReuse:!0,sourceUnit:"meters"});if(!G)throw new r("loadGLTFMesh()","Failed to load mesh from glTF due to projection errors");return{transform:null,vertexSpace:B,components:C.components,spatialReference:s.spatialReference,vertexAttributes:new g({...G,color:U?.typedBuffer,uv:E?.typedBuffer})}}function K(e,t){if(null==e)return"-";const r=e.typedBuffer;return`${o(t,r.buffer,(()=>t.size))}/${r.byteOffset}/${r.byteLength}`}function Q(e,t,r){t.writeVertices&&function(e,t){const{position:r,normal:o,tangent:n,color:l,texCoord0:p}=e.vertexAttributes,c=t.region.start,{attributes:u,transform:f}=t.gltf,j=u.position.count;if(C(r.slice(c,j),u.position,f),null!=u.normal&&null!=o){const e=i(m(),f),t=o.slice(c,j);R(t,u.normal,e),s(e)&&A(t,t)}else null!=o&&P(o,0,0,1,{dstIndex:c,count:j});if(null!=u.tangent&&null!=n){const e=a(m(),f),t=n.slice(c,j);U(t,u.tangent,e),s(e)&&E(t,t)}else null!=n&&L(n,0,0,1,1,{dstIndex:c,count:j});if(null!=u.texCoord0&&null!=p?D(p.slice(c,j),u.texCoord0):null!=p&&I(p,0,0,{dstIndex:c,count:j}),null!=u.color&&null!=l){const e=u.color,t=l.slice(c,j);if(4===e.elementCount)e instanceof x?B(t,e,255):e instanceof y?q(t,e):e instanceof T&&B(t,e,1/256);else{L(t,255,255,255,255);const r=h.fromTypedArray(t.typedBuffer,t.typedBufferStride);e instanceof v?S(r,e,255):e instanceof h?_(r,e):e instanceof b&&S(r,e,1/256)}}else null!=l&&L(l.slice(c,j),255,255,255,255)}(e,t);const{indices:o,attributes:n,primitiveType:l,material:p}=t.gltf;let u=G(o||n.position.count,l);const f=t.region.start;if(f){const e=new Uint32Array(u);for(let t=0;t<u.length;t++)e[t]+=f;u=e}e.components.push(new c({name:t.gltf.name,faces:u,material:r.get(p),shading:n.normal?"source":"flat",trustSourceNormals:!0}))}function W(e){switch(e){case"OPAQUE":return"opaque";case"MASK":return"mask";case"BLEND":return"blend"}}function X(e){switch(e){case k.CLAMP_TO_EDGE:return"clamp";case k.MIRRORED_REPEAT:return"mirror";case k.REPEAT:return"repeat"}}function Y(e){return e**(1/z)*255}export{J as loadGLTFMesh};
