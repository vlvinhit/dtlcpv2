/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.30/esri/copyright.txt for details.
*/
import e from"../Color.js";import{i as r}from"./colorUtils2.js";import{clone as t}from"../core/lang.js";import{r as i}from"../layers/support/fieldUtils.js";import{e as s,f as o,h as a,j as n,k as c,l,u as p}from"./utils7.js";import f from"../core/Error.js";import{L as m}from"./Logger.js";import{b as y,u,a as d,c as v}from"./quantizationUtils.js";function b(e,r,t,i,s){if(null==e)return null;const o=e.referencesGeometry()&&s?function(e,r,t){const{transform:i,hasZ:s,hasM:o}=t;M.has(r)||M.set(r,function(e){const r={};switch(e){case"esriGeometryPoint":return(e,t,i,s)=>v(t,r,e,i,s);case"esriGeometryPolygon":return(e,t,i,s)=>d(t,r,e,i,s);case"esriGeometryPolyline":return(e,t,i,s)=>u(t,r,e,i,s);case"esriGeometryMultipoint":return(e,t,i,s)=>y(t,r,e,i,s);default:return m.getLogger("esri.views.2d.support.arcadeOnDemand").error(new f("mapview-arcade",`Unable to handle geometryType: ${e}`)),e=>e}}(r));const a=M.get(r)(e.geometry,i,s,o);return{...e,geometry:a}}(r,i,s):r,a=e.repurposeFeature(o);try{return e.evaluate({...t,$feature:a},e.services)}catch(e){return m.getLogger("esri.views.2d.support.arcadeOnDemand").warn("Feature arcade evaluation failed:",e),null}}const M=new Map,C=e=>{if(!e)return[0,0,0,0];const{r,g:t,b:i,a:s}=e;return[r,t,i,255*s]};class I{static findApplicableOverrides(e,r,t){if(e&&r){if(e.primitiveName){let i=!1;for(const r of t)if(r.primitiveName===e.primitiveName){i=!0;break}if(!i)for(const i of r)i.primitiveName===e.primitiveName&&t.push(i)}switch(e.type){case"CIMPointSymbol":case"CIMLineSymbol":case"CIMPolygonSymbol":if(e.effects)for(const i of e.effects)I.findApplicableOverrides(i,r,t);if(e.symbolLayers)for(const i of e.symbolLayers)I.findApplicableOverrides(i,r,t);break;case"CIMTextSymbol":break;case"CIMSolidStroke":case"CIMPictureStroke":case"CIMGradientStroke":case"CIMSolidFill":case"CIMPictureFill":case"CIMHatchFill":case"CIMGradientFill":case"CIMVectorMarker":case"CIMCharacterMarker":case"CIMPictureMarker":if(e.effects)for(const i of e.effects)I.findApplicableOverrides(i,r,t);if(e.markerPlacement&&I.findApplicableOverrides(e.markerPlacement,r,t),"CIMVectorMarker"===e.type){if(e.markerGraphics)for(const i of e.markerGraphics)I.findApplicableOverrides(i,r,t),I.findApplicableOverrides(i.symbol,r,t)}else"CIMCharacterMarker"===e.type?I.findApplicableOverrides(e.symbol,r,t):"CIMHatchFill"===e.type?I.findApplicableOverrides(e.lineSymbol,r,t):"CIMPictureMarker"===e.type&&I.findApplicableOverrides(e.animatedSymbolProperties,r,t)}}}static findEffectOverrides(e,r){if(!e)return null;if("CIMGeometricEffectDashes"===e.type&&s(e),!r||!e.primitiveName)return{type:"cim-effect-param",effect:e,overrides:[]};const t=o(e),i=e.primitiveName,n=[];for(const e of r)e.primitiveName===i&&n.push(o(e));return{type:"cim-effect-param",effect:t,overrides:a(n)}}static async resolveSymbolOverrides(e,r,i,s,o,a,c){if(!e?.symbol)return null;let{symbol:l,primitiveOverrides:p}=e;const f=!!p;if(!f&&!s)return l;l=t(l),p=t(p);let m=!0;if(r||(r={attributes:{}},m=!1),f){if(m||(p=p.filter((e=>!e.valueExpressionInfo?.expression.includes("$feature")))),c||(p=p.filter((e=>!e.valueExpressionInfo?.expression.includes("$view")))),p.length>0){const e={spatialReference:i,fields:n(r.attributes),geometryType:o};await I.createRenderExpressions(p,e),I.evaluateOverrides(p,r,o??"esriGeometryPoint",a,c)}I.applyOverrides(l,p)}return s&&I.applyDictionaryTextOverrides(l,r,s,null),l}static async createRenderExpressions(e,r){const t=[];for(const s of e){const e=s.valueExpressionInfo;if(!e||I._expressionToRenderExpression.has(e.expression))continue;const o=i(e.expression,r.spatialReference,r.fields);t.push(o),o.then((r=>I._expressionToRenderExpression.set(e.expression,r)))}t.length>0&&await Promise.all(t)}static evaluateOverrides(e,t,i,s,o){const a={$view:{scale:o?.scale}};for(const o of e){o.value&&"object"==typeof o.value&&r(o.value)&&("Color"===o.propertyName||"StrokeColor"===o.propertyName)&&(o.value=C(o.value));const e=o.valueExpressionInfo;if(!e)continue;const n=I._expressionToRenderExpression.get(e.expression);n&&(o.value=b(n,t,a,i,s))}}static applyDictionaryTextOverrides(e,r,t,i,s="Normal"){if(e?.type)switch(e.type){case"CIMPointSymbol":case"CIMLineSymbol":case"CIMPolygonSymbol":case"CIMTextSymbol":{const o=e.symbolLayers;if(!o)return;for(const a of o)a&&"CIMVectorMarker"===a.type&&I.applyDictionaryTextOverrides(a,r,t,i,"CIMTextSymbol"===e.type?e.textCase:s)}break;case"CIMVectorMarker":{const s=e.markerGraphics;if(!s)return;for(const e of s)e&&I.applyDictionaryTextOverrides(e,r,t,i)}break;case"CIMMarkerGraphic":{const o=e.textString;if(o&&o.includes("[")){const a=c(o,t);e.textString=l(r,a,i,s)}}}}static applyOverrides(e,r,t,i){if(e.primitiveName)for(const s of r)if(s.primitiveName===e.primitiveName){const r=p(s.propertyName);if(i&&i.push({cim:e,nocapPropertyName:r,value:e[r]}),t){let r=!1;for(const i of t)i.primitiveName===e.primitiveName&&(r=!0);r||t.push(s)}null!=s.value&&(e[r]=s.value)}switch(e.type){case"CIMPointSymbol":case"CIMLineSymbol":case"CIMPolygonSymbol":if(e.effects)for(const s of e.effects)I.applyOverrides(s,r,t,i);if(e.symbolLayers)for(const s of e.symbolLayers)I.applyOverrides(s,r,t,i);break;case"CIMTextSymbol":break;case"CIMSolidStroke":case"CIMSolidFill":case"CIMVectorMarker":if(e.effects)for(const s of e.effects)I.applyOverrides(s,r,t,i);if("CIMVectorMarker"===e.type&&e.markerGraphics)for(const s of e.markerGraphics)I.applyOverrides(s,r,t,i),I.applyOverrides(s.symbol,r,t,i)}}static restoreOverrides(e){for(const r of e)r.cim[r.nocapPropertyName]=r.value}static buildOverrideKey(e){let r="";for(const t of e)void 0!==t.value&&(r+=`${t.primitiveName}${t.propertyName}${JSON.stringify(t.value)}`);return r}static toValue(r,t){if("DashTemplate"===r)return t.split(" ").map((e=>Number(e)));if("Color"===r){const r=new e(t).toRgba();return r[3]*=255,r}return t}}I._expressionToRenderExpression=new Map;export{I as O,b as c};
