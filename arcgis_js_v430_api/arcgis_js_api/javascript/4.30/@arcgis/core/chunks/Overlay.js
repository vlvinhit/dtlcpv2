/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.30/esri/copyright.txt for details.
*/
import e from"../core/Error.js";import{o as t}from"../core/promiseUtils.js";import{L as s}from"./Logger.js";import{f as r}from"./maybe.js";import{g as i}from"./perspectiveUtils.js";import{watch as n,when as o,initial as a}from"../core/reactiveUtils.js";import{c as l}from"./mat3f64.js";import{g as m}from"./vec2.js";import{c as h}from"./vec2f64.js";import{A as p}from"./enums2.js";import{D as d}from"./DisplayObject.js";import{p as u}from"./utils22.js";import{B as c}from"./BufferObject.js";import{T as f,P as w,U as y}from"./enums.js";import{a as v,T as _}from"./Texture.js";import{V as g}from"./VertexArrayObject.js";const x=[1,1],V=l(),j={none:p.None,loop:p.Loop,oscillate:p.Oscillate};class A extends d{constructor(i){super(),this.elementView=i,this.isWrapAround=!1,this.wrapAroundShift=0,this.perspectiveTransform=h(),this._playHandle=null,this._vertices=new Float32Array(20),this._handles=[],this._handles.push(n((()=>this.elementView.element.opacity),(e=>this.opacity=e),a),n((()=>[this.elementView.coords]),(()=>{this.requestRender()}),a),n((()=>["animationOptions"in this.elementView.element&&this.elementView.element.animationOptions]),(()=>{this._playHandle?.remove(),this.texture=r(this.texture),this.requestRender()}),a),o((()=>this.elementView.element.loaded),(()=>{const e=this.elementView.element;this.ready(),"video"===e.type&&null!=e.content&&this._handles.push(t(e.content,"play",(()=>this.requestRender())))}),a)),i.element.load().catch((t=>{s.getLogger("esri.views.2d.layers.MediaLayerView2D").error(new e("element-load-error","Element cannot be displayed",{element:i,error:t}))}))}getMesh(e){throw new Error("Method not implemented.")}destroy(){this._playHandle?.remove(),this._handles.forEach((e=>e.remove())),this.texture=r(this.texture)}get textureSize(){return x}get dvsMat3(){return this.parent.dvsMat3}beforeRender(e){const{context:t}=e,s=this.elementView.element.content;if(null!=s){const e=s instanceof HTMLImageElement,i=s instanceof HTMLVideoElement,n=e?s.naturalWidth:i?s.videoWidth:s.width,o=e?s.naturalHeight:i?s.videoHeight:s.height;if(this._updatePerspectiveTransform(n,o),this.texture)i&&!s.paused&&(this.texture.setData(s),this.requestRender(),this.texture.generateMipmap());else{const e=new v;if(e.wrapMode=f.CLAMP_TO_EDGE,e.preMultiplyAlpha=!0,e.width=n,e.height=o,"getFrame"in s){const i=s=>{this.texture?this.texture.setData(s):this.texture=new _(t,e,s),this.requestRender()};"animationOptions"in this.elementView.element&&(this._playHandle=u(s,(r=this.elementView.element.animationOptions)?{...r,playAnimation:r.playing,repeatType:r.repeatType?j[r.repeatType]:void 0}:{},null,i))}else this.texture=new _(t,e,s);this.texture.generateMipmap(),i&&!s.paused&&this.requestRender()}}var r;super.beforeRender(e)}_createTransforms(){return null}draw(e){e.drawArrays(w.TRIANGLE_STRIP,0,4)}updateDrawCoords(e,t,s,r){const{coords:i,bounds:n}=this.elementView;if(null==i||null==n)return;const[o,a,l,m]=i.rings[0],h=this._vertices,{x:p,y:d}=e;h.set([a[0]-p,a[1]-d,o[0]-p,o[1]-d,l[0]-p,l[1]-d,m[0]-p,m[1]-d]);let u=t;if(r){const[e,,t]=n,{worldWidth:s,xBounds:i}=r,[o,a]=i;e<o&&t>o?u=s:t>a&&e<a&&(u=-s)}this.wrapAroundShift=u,this.isWrapAround=0!==u}getVAO(e,t,s){if(null==this.elementView.coords)return null;const r=this._vertices;if(this._vao)this._geometryVbo.setData(r);else{this._geometryVbo=c.createVertex(e,y.DYNAMIC_DRAW,r);const i=c.createVertex(e,y.STATIC_DRAW,new Uint16Array([0,0,0,1,1,0,1,1,1,1,0,0,0,0,0,1,1,0,1,1]));this._vao=new g(e,s,t,{geometry:this._geometryVbo,tex:i})}return this._vao}_updatePerspectiveTransform(e,t){const s=this._vertices;i(V,[0,0,e,0,0,t,e,t],[s[0],s[1],s[4],s[5],s[2],s[3],s[6],s[7]]),m(this.perspectiveTransform,V[6]/V[8]*e,V[7]/V[8]*t)}}export{A as O};
