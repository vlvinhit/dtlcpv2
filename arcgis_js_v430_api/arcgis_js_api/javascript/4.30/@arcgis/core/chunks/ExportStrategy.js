/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.30/esri/copyright.txt for details.
*/
import{_ as t}from"./tslib.es6.js";import e from"../core/Accessor.js";import"../core/lang.js";import{debounce as i,throwIfAborted as o,throwIfAbortError as r,eachAlways as s}from"../core/promiseUtils.js";import{property as a}from"../core/accessorSupport/decorators/property.js";import"./Logger.js";import{subclass as n}from"../core/accessorSupport/decorators/subclass.js";import{c as p,t as h}from"./aaBoundingRect.js";import{j as c}from"./unitUtils.js";import d from"../layers/support/TileInfo.js";import{B as m}from"./Bitmap.js";import{T as l}from"./TileStrategy.js";import{T as u}from"./TileKey2.js";const g=Math.PI/180,f=p(),y=[0,0],x=new u(0,0,0,0);let M=class extends e{constructor(t){super(t),this._imagePromise=null,this.bitmaps=[],this.hidpi=!1,this.imageMaxWidth=2048,this.imageMaxHeight=2048,this.imageRotationSupported=!1,this.imageNormalizationSupported=!1,this.update=i((async(t,e)=>{if(o(e),!t.stationary||this.destroyed)return;const i=t.state,s=c(i.spatialReference),a=this.hidpi?t.pixelRatio:1,n=i.worldScreenWidth>0,p=n&&this.imageNormalizationSupported&&i.worldScreenWidth<i.size[0],h=Math.round((this.imageMaxWidth??0)/a),d=Math.round((this.imageMaxHeight??0)/a);p?(y[0]=i.worldScreenWidth,y[1]=i.size[1]):this.imageRotationSupported?(y[0]=i.size[0],y[1]=i.size[1]):function(t,e){const i=e.rotation*g,o=Math.abs(Math.cos(i)),r=Math.abs(Math.sin(i)),[s,a]=e.size;t[0]=Math.round(a*r+s*o),t[1]=Math.round(a*o+s*r)}(y,i);const m=Math.floor(y[0])>h||Math.floor(y[1])>d,l=s&&(i.extent.xmin<s.valid[0]||i.extent.xmax>s.valid[1]),u=!this.imageNormalizationSupported&&l,f=!m&&!u,x=this.imageRotationSupported?i.rotation:0,M=this.container.children.slice();if(f){const t=p?i.paddedViewState.center:i.center;this._imagePromise=this._singleExport(i,y,t,i.resolution,x,a,e)}else{let t=Math.min(h,d);n&&(t=Math.min(i.worldScreenWidth,t),t=Math.round(i.worldScreenWidth/Math.ceil(i.worldScreenWidth/t))),this._imagePromise=this._tiledExport(i,t,a,e)}try{const t=await this._imagePromise??[];o(e);const i=[];if(this._imagePromise=null,this.destroyed)return;this.bitmaps=t;for(const e of M)t.includes(e)||i.push(e.fadeOut().then((()=>{e.remove(),e.destroy()})));for(const e of t)i.push(e.fadeIn());await Promise.all(i)}catch(t){this._imagePromise=null,r(t)}}),5e3),this.updateExports=i((async t=>{const e=[];for(const i of this.container.children){if(!i.visible||!i.stage)return;e.push(t(i).then((()=>{i.invalidateTexture(),i.requestRender()})))}this._imagePromise=s(e).then((()=>this._imagePromise=null)),await this._imagePromise}))}destroy(){this.bitmaps.forEach((t=>t.destroy())),this.bitmaps=[]}get updating(){return!this.destroyed&&null!==this._imagePromise}async _export(t,e,i,r,s,a){const n=await this.fetchSource(t,Math.floor(e*s),Math.floor(i*s),{rotation:r,pixelRatio:s,signal:a});o(a);const p=new m(null,!0);return p.x=t.xmin,p.y=t.ymax,p.resolution=t.width/e,p.rotation=r,p.pixelRatio=s,p.opacity=0,this.container.addChild(p),await p.setSourceAsync(n,a),o(a),p}async _singleExport(t,e,i,o,r,s,a){!function(t,e,i,o){const[r,s]=e,[a,n]=o,p=.5*i;t[0]=r-p*a,t[1]=s-p*n,t[2]=r+p*a,t[3]=s+p*n}(f,i,o,e);const n=h(f,t.spatialReference);return[await this._export(n,e[0],e[1],r,s,a)]}_tiledExport(t,e,i,o){const r=d.create({size:e,spatialReference:t.spatialReference,scales:[t.scale]}),s=new l(r),a=s.getTileCoverage(t);if(!a)return null;const n=[];return a.forEach(((r,a,p,c)=>{x.set(r,a,p,0),s.getTileBounds(f,x);const d=h(f,t.spatialReference);n.push(this._export(d,e,e,0,i,o).then((t=>(0!==c&&(x.set(r,a,p,c),s.getTileBounds(f,x),t.x=f[0],t.y=f[3]),t))))})),Promise.all(n)}};t([a()],M.prototype,"_imagePromise",void 0),t([a()],M.prototype,"bitmaps",void 0),t([a()],M.prototype,"container",void 0),t([a()],M.prototype,"fetchSource",void 0),t([a()],M.prototype,"hidpi",void 0),t([a()],M.prototype,"imageMaxWidth",void 0),t([a()],M.prototype,"imageMaxHeight",void 0),t([a()],M.prototype,"imageRotationSupported",void 0),t([a()],M.prototype,"imageNormalizationSupported",void 0),t([a()],M.prototype,"requestUpdate",void 0),t([a()],M.prototype,"updating",null),M=t([n("esri.views.2d.layers.support.ExportStrategy")],M);const S=M;export{S as E};
