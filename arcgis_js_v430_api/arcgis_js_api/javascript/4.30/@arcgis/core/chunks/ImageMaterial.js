/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.30/esri/copyright.txt for details.
*/
import{b as t}from"./BufferView.js";import{c as e,S as s,i as a,d as r}from"./Matrix4PassUniform.js";import{C as i}from"./basicInterfaces.js";import{G as o}from"./GLTextureMaterial.js";import{a as n}from"./Material.js";import{S as p,d as l,e as c,m as u,g as d,h,C as f,i as m,D as g,R as v,j as P,P as _,o as y,k as T,l as E,p as I,s as O,q as S,r as b,t as C,u as A,O as x}from"./StencilUtils.js";import{a as D}from"./Util.js";import{V as w}from"./VertexAttribute.js";import{D as j,w as N,a as R}from"./RayIntersections.js";import{P as V}from"./DefaultLayouts.js";import{T as M}from"./TriangleMaterial.js";import{_ as L}from"./tslib.es6.js";import{g as U}from"./interfaces3.js";import{p as F}from"./ShaderTechniqueConfiguration.js";import{T as B}from"./OutputHighlight.glsl.js";import{g as G}from"./enums.js";import{s as $,m as z,c as W,d as q,a as H}from"./renderState.js";const k=Object.freeze(Object.defineProperty({__proto__:null,build:function(t){const a=new p,{vertex:r,fragment:i}=a;return l(r,t),a.include(B,t),a.attributes.add(w.POSITION,"vec3"),a.attributes.add(w.UV0,"vec2"),t.perspectiveInterpolation&&a.attributes.add(w.PERSPECTIVEDIVIDE,"float"),a.varyings.add("vpos","vec3"),t.multipassEnabled&&a.varyings.add("depth","float"),r.code.add(U`
    void main(void) {
      vpos = position;
      ${t.multipassEnabled?"depth = (view * vec4(vpos, 1.0)).z;":""}
      vTexCoord = uv0;
      gl_Position = transformPosition(proj, view, vpos);

      ${t.perspectiveInterpolation?"gl_Position *= perspectiveDivide;":""}
    }
  `),a.include(c,t),a.include(u,t),i.uniforms.add(new d("tex",(t=>t.texture)),new e("opacity",(t=>t.opacity))),a.varyings.add("vTexCoord","vec2"),t.transparencyPassType===h.ColorAlpha&&(a.outputs.add("fragColor","vec4",0),a.outputs.add("fragAlpha","float",1)),i.include(f),i.code.add(U`
    void main() {
      discardBySlice(vpos);
      ${t.multipassEnabled?"terrainDepthTest(depth);":""}
      fragColor = texture(tex, vTexCoord) * opacity;

      if (fragColor.a < ${U.float(m)}) {
        discard;
      }

      fragColor = highlightSlice(fragColor, vpos);
      ${t.transparencyPassType===h.ColorAlpha?U`
              fragColor = premultiplyAlpha(fragColor);
              fragAlpha = fragColor.a;`:""}
      ${t.output===s.ObjectAndLayerIdColor?U`
              fragColor = vec4(0,0,0,1);`:""}
    }
    `),a}},Symbol.toStringTag,{value:"Module"}));class Q extends P{initializeProgram(t){return new _(t.rctx,Q.shader.get().build(this.configuration),X)}_setPipelineState(t,e){const a=this.configuration,r=t===h.NONE,i=t===h.FrontFace;return z({blending:a.output===s.Color&&a.transparent?r?J:y(t):null,culling:W(a.cullFace),depthTest:{func:T(t)},depthWrite:r?a.writeDepth?q:null:E(t),drawBuffers:I(t),colorWrite:H,stencilWrite:a.hasOccludees?O:null,stencilTest:a.hasOccludees?e?S:b:null,polygonOffset:r||i?null:C(a.enableOffset)})}initializePipeline(){return this._occludeePipelineState=this._setPipelineState(this.configuration.transparencyPassType,!0),this._setPipelineState(this.configuration.transparencyPassType,!1)}getPipeline(t){return t?this._occludeePipelineState:super.getPipeline()}}Q.shader=new v(k,(()=>Promise.resolve().then((()=>k))));const J=$(G.ONE,G.ONE_MINUS_SRC_ALPHA);class K extends g{constructor(){super(...arguments),this.output=s.Color,this.cullFace=i.None,this.hasSlicePlane=!1,this.transparent=!1,this.enableOffset=!0,this.writeDepth=!0,this.hasOccludees=!1,this.transparencyPassType=h.NONE,this.multipassEnabled=!1,this.cullAboveGround=!1,this.perspectiveInterpolation=!0}}L([F({count:s.COUNT})],K.prototype,"output",void 0),L([F({count:i.COUNT})],K.prototype,"cullFace",void 0),L([F()],K.prototype,"hasSlicePlane",void 0),L([F()],K.prototype,"transparent",void 0),L([F()],K.prototype,"enableOffset",void 0),L([F()],K.prototype,"writeDepth",void 0),L([F()],K.prototype,"hasOccludees",void 0),L([F({count:h.COUNT})],K.prototype,"transparencyPassType",void 0),L([F()],K.prototype,"multipassEnabled",void 0),L([F()],K.prototype,"cullAboveGround",void 0),L([F()],K.prototype,"perspectiveInterpolation",void 0),L([F({constValue:!1})],K.prototype,"occlusionPass",void 0);const X=new Map([[w.POSITION,0],[w.UV0,2],[w.PERSPECTIVEDIVIDE,3]]);class Y extends M{constructor(t){super(t,new et),this.supportsEdges=!0,this.produces=new Map([[A.OPAQUE_MATERIAL,t=>a(t)||r(t)&&!this.parameters.transparent],[A.TRANSPARENT_MATERIAL,t=>r(t)&&this.parameters.transparent&&this.parameters.writeDepth],[A.TRANSPARENT_DEPTH_WRITE_DISABLED_MATERIAL,t=>r(t)&&this.parameters.transparent&&!this.parameters.writeDepth],[A.DRAPED_MATERIAL,t=>r(t)||a(t)]]),this._vertexAttributeLocations=X,this._configuration=new K}getConfiguration(t,e){return this._configuration.output=t,this._configuration.cullFace=this.parameters.cullFace,this._configuration.hasSlicePlane=this.parameters.hasSlicePlane,this._configuration.transparent=this.parameters.transparent,this._configuration.writeDepth=this.parameters.writeDepth,this._configuration.hasOccludees=this.parameters.hasOccludees,this._configuration.transparencyPassType=e.transparencyPassType,this._configuration.enableOffset=e.camera.relativeElevation<x,this._configuration.multipassEnabled=e.multipassEnabled,this._configuration.cullAboveGround=e.multipassTerrain.cullAboveGround,this._configuration.perspectiveInterpolation=this.parameters.perspectiveInterpolation,this._configuration}createGLMaterial(t){return new Z(t)}createBufferWriter(){const t=V.clone();return this.parameters.perspectiveInterpolation&&t.f32(w.PERSPECTIVEDIVIDE),new tt(t)}}class Z extends o{constructor(t){super({...t,...t.material.parameters})}_updateParameters(t){return this.updateTexture(this._material.parameters.textureId),this._material.setParameters(this.textureBindParameters),this.ensureTechnique(Q,t)}_updateOccludeeState(t){t.hasOccludees!==this._material.parameters.hasOccludees&&(this._material.setParameters({hasOccludees:t.hasOccludees}),this._updateParameters(t))}beginSlot(t){return this._output===s.Color&&this._updateOccludeeState(t),this._updateParameters(t)}}class tt extends j{write(e,s,a,r,i){for(const o of this.vertexBufferLayout.fields.keys()){const n=a.attributes.get(o);if(n)if(o===w.PERSPECTIVEDIVIDE){D(1===n.size);const e=r.getField(o,t);e&&N(n,e,i)}else R(o,n,e,s,r,i)}}}class et extends n{constructor(){super(...arguments),this.transparent=!1,this.writeDepth=!0,this.hasSlicePlane=!1,this.cullFace=i.None,this.hasOccludees=!1,this.opacity=1,this.textureId=null,this.initTextureTransparent=!0,this.perspectiveInterpolation=!1}}export{Y as I};
