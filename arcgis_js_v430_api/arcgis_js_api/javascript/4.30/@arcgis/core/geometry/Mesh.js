/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.30/esri/copyright.txt for details.
*/
import{_ as e}from"../chunks/tslib.es6.js";import{b as t,k as r}from"../core/Accessor.js";import n from"../core/Error.js";import s from"../core/Loadable.js";import{L as o}from"../chunks/Logger.js";import{EsriPromiseMixin as i}from"../core/Promise.js";import{whenOrAbort as a,throwIfAborted as c,allSettledValues as l,isAborted as u,createAbortError as p}from"../core/promiseUtils.js";import{on as m,watch as f}from"../core/reactiveUtils.js";import{property as h}from"../core/accessorSupport/decorators/property.js";import"../core/lang.js";import{subclass as d}from"../core/accessorSupport/decorators/subclass.js";import{c as g,f as x,Z as y,O as v}from"../chunks/vec3f64.js";import j from"./Extent.js";import w from"./Geometry.js";import b from"./Point.js";import A from"./Polygon.js";import{d as S,c as k,a as R,e as M,g as F}from"../chunks/axisAngleDegrees.js";import I from"./support/MeshComponent.js";import T from"./support/MeshGeoreferencedVertexSpace.js";import U from"./support/MeshLocalVertexSpace.js";import O from"./support/MeshTransform.js";import{M as _}from"../chunks/MeshVertexAttributes.js";import{i as L,s as P,a as E,b as C}from"../chunks/meshVertexSpaceUtils.js";import{t as N}from"../chunks/triangulationUtils.js";import{z,c as B,h as D}from"../chunks/aaBoundingBox.js";import{project as G,logProjectionError as V,loadProjectErrorMessage as q,projectToPCPF as Y,projectNormalToPCPF as $,projectTangentToPCPF as H,projectFromPCPF as W,projectNormalFromPCPF as Z,projectTangentFromPCPF as J}from"../chunks/projection.js";import{c as K,i as Q,r as X,n as ee,s as te,H as re,h as ne,b as se}from"../chunks/vec3.js";import{p as oe}from"../chunks/projectPointToVector.js";import{c as ie,g as ae,p as ce}from"../chunks/vertexSpaceConversion.js";import{removeFile as le,makeRelative as ue}from"../core/urlUtils.js";import{Clonable as pe}from"../core/Clonable.js";import me from"../core/Collection.js";import{d as fe,f as he,e as de}from"../chunks/External.js";import{c as ge}from"../chunks/mat3f64.js";import{f as xe}from"../chunks/mat3.js";import{D as ye,m as ve,n as je,s as we,x as be,f as Ae}from"../chunks/mat4.js";import{c as Se}from"../chunks/mat4f64.js";import{s as ke}from"../chunks/quat.js";import{c as Re,I as Me}from"../chunks/quatf64.js";import{g as Fe}from"../chunks/spatialReferenceEllipsoidUtils.js";import{c as Ie}from"../chunks/computeTranslationToOriginAndRotation.js";import"../core/Handles.js";import"../chunks/maybe.js";import"../chunks/metadata.js";import"../chunks/utils.js";import"../chunks/handleUtils.js";import"../chunks/ObservableBase.js";import"../chunks/tracking.js";import"../core/scheduling.js";import"../config.js";import"../chunks/ensureType.js";import"../chunks/asyncUtils.js";import"../core/Evented.js";import"../chunks/shared.js";import"../chunks/SimpleObservable.js";import"./SpatialReference.js";import"../core/JSONSupport.js";import"../chunks/unitUtils.js";import"../chunks/jsonMap.js";import"../chunks/assets.js";import"../request.js";import"../kernel.js";import"../chunks/writer.js";import"./support/webMercatorUtils.js";import"../chunks/reader.js";import"../core/accessorSupport/decorators/cast.js";import"../chunks/coordsUtils.js";import"../chunks/Axis.js";import"../chunks/extentUtils.js";import"../chunks/aaBoundingRect.js";import"../chunks/mathUtils.js";import"../chunks/zmUtils.js";import"../chunks/common.js";import"../chunks/vec4f64.js";import"./support/MeshMaterial.js";import"../Color.js";import"../chunks/colorUtils.js";import"./support/MeshTexture.js";import"../chunks/imageUtils.js";import"../chunks/persistableUrlUtils.js";import"./support/MeshTextureTransform.js";import"./support/MeshMaterialMetallicRoughness.js";import"../chunks/enumeration.js";import"../chunks/vec4.js";import"../chunks/earcut.js";import"../chunks/_commonjsHelpers.js";import"../chunks/DoubleArray.js";import"../chunks/Indices.js";import"../chunks/plane.js";import"../chunks/vec2f64.js";import"../chunks/mathUtils2.js";import"../chunks/deduplicate.js";import"./projection.js";import"./Multipoint.js";import"./Polyline.js";import"../chunks/projectBuffer.js";import"../chunks/geodesicConstants.js";import"./support/GeographicTransformation.js";import"./support/GeographicTransformationStep.js";import"../chunks/zscale.js";import"../chunks/BufferView.js";import"../chunks/vec2.js";import"../chunks/vec32.js";import"../chunks/vec42.js";import"../chunks/infoFor3D.js";const Te="Expected location to be a Point instance";class Ue extends n{constructor(){super("invalid-input:location",Te)}}let Oe=null;function _e(e){if(0===e.length)return z;const t=B([Number.POSITIVE_INFINITY,Number.POSITIVE_INFINITY,Number.POSITIVE_INFINITY,-Number.POSITIVE_INFINITY,-Number.POSITIVE_INFINITY,-Number.POSITIVE_INFINITY]);return D(t,e),t}function Le(e,t){const[r,n,s,o,i,a]=_e(e);return new j({xmin:r,ymin:n,zmin:s,xmax:o,ymax:i,zmax:a,spatialReference:t})}function Pe(e,t){return e.isGeographic||e.isWebMercator&&(t??!0)}function Ee(e,r,n,s){if(void 0!==s){t(e(),"option: geographic",{replacement:"Use mesh `vertexSpace` and spatial reference to control how operations are performed instead.",version:"4.30",warnOnce:!0});const o="local"===r.type;if(!L(r)||s===o)return n.isGeographic||n.isWebMercator&&s;e().warnOnce(`Specifying the 'geographic' parameter (${s}) for a Mesh vertex space of type "${r.type}" is not supported. This parameter will be ignored.`)}switch(r.type){case"georeferenced":return n.isGeographic;case"local":return n.isGeographic||n.isWebMercator}}const Ce=()=>o.getLogger("esri.geometry.support.meshUtils.centerAt"),Ne=g(),ze=g(),Be=g();function De(e){const t=le(e.url);return r=>{const n=ue(r,t,t),s=n?n.replace(/^ *\.\//,""):null;return(s?e.files.get(s):null)??r}}function Ge(e){return We.fromBlob(e,Ze(e.name,e.type))}const Ve=/^model\/gltf\+json$/,qe=/^model\/gltf-binary$/,Ye=/\.gltf$/i,$e=/\.glb$/i;function He(e){const t=new Map;let r,s=null;for(const{name:n,mimeType:o,source:i}of e)null===s&&(Ve.test(o)||Ye.test(n)?(s=i.url,r="gltf"):(qe.test(o)||$e.test(n))&&(s=i.url,r="glb")),t.set(n,i.url),i.files.forEach(((e,r)=>t.set(r,e)));if(null==s)throw new n("mesh-load-external:missing-files","Missing files to load external mesh source");return new We(s,(()=>e.forEach((({source:e})=>e.dispose()))),t,r)}class We{constructor(e,t=(()=>{}),r=new Map,n){this.url=e,this.dispose=t,this.files=r,this.type=n}static fromBlob(e,t){const r=URL.createObjectURL(e);return new We(r,(()=>URL.revokeObjectURL(r)),void 0,t)}}function Ze(e,t){return Ve.test(t)||Ye.test(e)?"gltf":qe.test(t)||Ye.test(e)?"glb":void 0}let Je=class extends pe{constructor(e){super(e),this.externalSources=new me,this._explicitDisplaySource=null,this.addHandles(m((()=>this.externalSources),"after-remove",(({item:e})=>{e===this._explicitDisplaySource&&(this._explicitDisplaySource=null)}),{sync:!0,onListenerRemove:()=>this._explicitDisplaySource=null}))}get displaySource(){return this._explicitDisplaySource??this._implicitDisplaySource}set displaySource(e){if(null!=e&&!fe(e))throw new Error("Cannot use this source for display: it is not in a supported format.");this._explicitDisplaySource=e,e&&this.externalSources.every((t=>!he(t,e)))&&this.externalSources.add(e)}clearSources(){this.externalSources.removeAll()}getExternalSourcesOnService(e){return this.externalSources.items.filter((t=>de(t,e)))}get _implicitDisplaySource(){return this.externalSources.find(fe)}};e([h()],Je.prototype,"externalSources",void 0),e([h()],Je.prototype,"displaySource",null),e([h()],Je.prototype,"_implicitDisplaySource",null),e([h()],Je.prototype,"_explicitDisplaySource",void 0),Je=e([d("esri.geometry.support.meshUtils.Metadata")],Je);const Ke={position:[-.5,-.5,0,.5,-.5,0,.5,.5,0,-.5,.5,0],normal:[0,0,1,0,0,1,0,0,1,0,0,1],uv:[0,1,1,1,1,0,0,0],faces:[0,1,2,0,2,3],facingAxisOrderSwap:{east:[3,1,2],west:[-3,-1,2],north:[-1,3,2],south:[1,-3,2],up:[1,2,3],down:[1,-2,-3]}};function Qe(e,t,r){e.isPlane||function(e){for(let t=0;t<e.position.length;t+=3)e.position[t+2]+=.5}(e),function(e,t){if(null!=t){rt[0]=t[0],rt[4]=t[1],rt[8]=t[2];for(let t=0;t<e.position.length;t+=3){for(let r=0;r<3;r++)tt[r]=e.position[t+r];X(tt,tt,rt);for(let r=0;r<3;r++)e.position[t+r]=tt[r]}if(t[0]!==t[1]||t[1]!==t[2]){rt[0]=1/t[0],rt[4]=1/t[1],rt[8]=1/t[2];for(let t=0;t<e.normal.length;t+=3){for(let r=0;r<3;r++)tt[r]=e.normal[t+r];X(tt,tt,rt),ee(tt,tt);for(let r=0;r<3;r++)e.normal[t+r]=tt[r]}}}}(e,function(e,t,r){const n=ae(t,r);if(null==e&&1===n)return null;if(null==e)return[n,n,n];if("number"==typeof e){const t=e*n;return[t,t,t]}return[null!=e.width?e.width*n:n,null!=e.depth?e.depth*n:n,null!=e.height?e.height*n:n]}(r?.size,r?.unit,t.spatialReference));const n=P(t,r),s=t.spatialReference.isGeographic?P(t):n,o=ie({vertexAttributes:e,vertexSpace:s,spatialReference:t.spatialReference},n,{allowBufferReuse:!0});return{vertexAttributes:new _({...o,uv:e.uv}),vertexSpace:n,components:[new I({faces:e.faces,material:r?.material||null})],spatialReference:t.spatialReference}}const Xe={faceDescriptions:[{axis:[0,-1,0],uvOrigin:[0,.625],corners:[[-1,-1],[1,-1],[1,1],[-1,1]]},{axis:[1,0,0],uvOrigin:[.25,.625],corners:[[-1,-1],[1,-1],[1,1],[-1,1]]},{axis:[0,1,0],uvOrigin:[.5,.625],corners:[[1,-1],[-1,-1],[-1,1],[1,1]]},{axis:[-1,0,0],uvOrigin:[.75,.625],corners:[[1,-1],[-1,-1],[-1,1],[1,1]]},{axis:[0,0,1],uvOrigin:[0,.375],corners:[[-1,-1],[1,-1],[1,1],[-1,1]]},{axis:[0,0,-1],uvOrigin:[0,.875],corners:[[-1,1],[1,1],[1,-1],[-1,-1]]}],uvScales:[[0,0],[1,0],[1,1],[0,1]],faceVertexOffsets:[0,1,2,0,2,3]},et={south:0,east:1,north:2,west:3,up:4,down:5},tt=g(),rt=ge(),nt=()=>o.getLogger("esri.geometry.support.meshUtils.rotate");function st(e,t,r,n=y){if(null!=e){Ae(ct,k(t),R(t));for(let t=0;t<e.length;t+=r){for(let r=0;r<3;r++)ot[r]=e[t+r]-n[r];ne(ot,ot,ct);for(let r=0;r<3;r++)e[t+r]=ot[r]+n[r]}}}const ot=g(),it=Se(),at=S(),ct=Se(),lt=ge(),ut=g(),pt=Re(),mt=()=>o.getLogger("esri.geometry.support.meshUtils.scale");function ft(e,t,r=y){if(e)for(let n=0;n<e.length;n+=3){for(let t=0;t<3;t++)ht[t]=e[n+t]-r[t];se(ht,ht,t);for(let t=0;t<3;t++)e[n+t]=ht[t]+r[t]}}const ht=g(),dt=g(),gt=Se(),xt=g();var yt;const vt="esri.geometry.Mesh";function jt(){return o.getLogger(vt)}const wt={base:null,key:"type",defaultKeyValue:"georeferenced",typeMap:{georeferenced:T,local:U}};let bt=yt=class extends(s.LoadableMixin(i(w))){constructor(e){super(e),this.components=null,this.vertexSpace=new T,this.transform=null,this.metadata=new Je,this.hasZ=!0,this.hasM=!1,this.vertexAttributes=new _,this.type="mesh"}initialize(){(0===this.metadata.externalSources.length||this.vertexAttributes.position.length)&&(this.loadStatus="loaded"),this.when((()=>{this.addHandles(f((()=>({vertexAttributes:this.vertexAttributes,components:this.components?.map((e=>e.clone()))})),(()=>this._clearSources()),{once:!0,sync:!0}))}))}get hasExtent(){return this.loaded?this.vertexAttributes.position.length>0&&(!this.components||this.components.length>0):null!=this.metadata.displaySource?.extent}get _transformedExtent(){const{components:e,spatialReference:t,vertexAttributes:r,vertexSpace:n}=this,s=r.position;if(0===s.length||e&&0===e.length)return new j({xmin:0,ymin:0,zmin:0,xmax:0,ymax:0,zmax:0,spatialReference:t});if(L(n)){const{_untransformedBounds:e,transform:r}=this;return function([e,t,r,n,s,o],i,a,c){Oe??=new Float64Array(24);const l=Oe;return l[0]=e,l[1]=t,l[2]=r,l[3]=e,l[4]=s,l[5]=r,l[6]=n,l[7]=s,l[8]=r,l[9]=n,l[10]=t,l[11]=r,l[12]=e,l[13]=t,l[14]=o,l[15]=e,l[16]=s,l[17]=o,l[18]=n,l[19]=s,l[20]=o,l[21]=n,l[22]=t,l[23]=o,G({positions:l,transform:i,vertexSpace:a,inSpatialReference:c,outSpatialReference:c,outPositions:l}),Le(l,c)}(e,r,n,t)}return Le(s,t)}get _untransformedBounds(){return _e(this.vertexAttributes.position)}get anchor(){const e=C(this.vertexSpace,this.spatialReference);if(null!=e)return e;const{center:t,zmin:r}=this._transformedExtent;return new b({x:t.x,y:t.y,z:r,spatialReference:this.spatialReference})}get origin(){const e=C(this.vertexSpace,this.spatialReference);return null!=e?e:this._transformedExtent.center}get extent(){return this.loaded||null==this.metadata?.displaySource?.extent?this._transformedExtent:this.metadata.displaySource.extent.clone()}addComponent(e){this._checkIfLoaded("addComponent()")&&(this.components||(this.components=[]),this.components.push(I.from(e)),this.notifyChange("components"))}removeComponent(e){if(this._checkIfLoaded("removeComponent()")){if(this.components){const t=this.components.indexOf(e);if(-1!==t)return this.components.splice(t,1),void this.notifyChange("components")}jt().error("removeComponent()","Provided component is not part of the list of components")}}rotate(e,t,r,n){return F(e,t,r,At),function(e,t,r){if(!e.vertexAttributes?.position||0===t[3])return;const{spatialReference:n,vertexSpace:s}=e,o=r?.origin??e.anchor,i=r?.geographic,a=Ee(nt,s,n,i);E(e)?function(e,t,r){e.transform??=new O;const{vertexSpace:n,transform:s,spatialReference:o}=e,[i,a,c]=n.origin,l=new b({x:i,y:a,z:c,spatialReference:o}),u=ot;if(l.equals(r))te(u,0,0,0);else if(!ce(u,r,e))return void V(nt(),r.spatialReference,o,q);ke(pt,R(t),k(t));const p=ye(it,pt,y,v,u),{localMatrix:m}=s,f=ve(it,p,m);s.scale=je(g(),f),we(f,f,re(ot,s.scale));const h=s.rotationAxis;s.rotation=M(f),0===s.rotationAngle&&(s.rotationAxis=h),s.translation=be(g(),f)}(e,t,o):a?function(e,t,r){const n=e.spatialReference,s=Fe(n),o=ut;if(!oe(r,o,s)&&(V(nt(),r.spatialReference,s,"Falling back to mesh origin"),!oe(e.origin,o,s)))return void V(nt(),e.origin.spatialReference,s);const i=e.vertexAttributes.position,a=e.vertexAttributes.normal,c=e.vertexAttributes.tangent,l=new Float64Array(i.length),u=null!=a?new Float32Array(a.length):null,p=null!=c?new Float32Array(c.length):null;Ie(s,o,ct,s),xe(lt,ct);const m=at;X(R(at),R(t),lt),m[3]=t[3],!Y(i,n,l)||null!=a&&null!=u&&!$(a,i,l,n,u)||null!=c&&null!=p&&!H(c,i,l,n,p)?V(nt(),n,s):(st(l,m,3,o),!W(l,i,n)||null!=a&&null!=u&&(st(u,m,3),!Z(u,i,l,n,a))||null!=c&&null!=p&&(st(p,m,4),!J(p,i,l,n,c))?V(nt(),s,n):e.vertexAttributesChanged())}(e,t,o):function(e,t,r){const n=ut;if(!oe(r,n,e.spatialReference)){const t=e.origin;return n[0]=t.x,n[1]=t.y,n[2]=t.z,void V(nt(),r.spatialReference,e.spatialReference,q)}st(e.vertexAttributes.position,t,3,n),st(e.vertexAttributes.normal,t,3),st(e.vertexAttributes.tangent,t,4),e.vertexAttributesChanged()}(e,t,o)}(this,At,n),this}offset(e,t,r){if(!this._checkIfLoaded("offset()"))return this;const{vertexSpace:n,vertexAttributes:s}=this,o=s?.position;if(!o)return this;if(L(n)){const[s,o,i]=n.origin;n.origin=x(s+e,o+t,i+r)}else{for(let n=0;n<o.length;n+=3)o[n]+=e,o[n+1]+=t,o[n+2]+=r;this.vertexAttributesChanged()}return this}scale(e,t){return this._checkIfLoaded("scale()")?(function(e,t,r){if(!e.vertexAttributes?.position)return;const{vertexSpace:n,spatialReference:s}=e,o=r?.origin??e.anchor,i=r?.geographic,a=Ee(mt,n,s,i);E(e)?function(e,t,r){e.transform??=new O;const{vertexSpace:n,transform:s,spatialReference:o}=e,[i,a,c]=n.origin,l=new b({x:i,y:a,z:c,spatialReference:o}),u=ht;if(l.equals(r))te(u,0,0,0);else if(!ce(u,r,e))return void V(mt(),r.spatialReference,o,q);const p=te(dt,t,t,t),m=ye(gt,Me,y,p,u),{localMatrix:f}=s,h=ve(gt,m,f);s.scale=je(g(),h),we(h,h,re(ht,s.scale));const d=s.rotationAxis;s.rotation=M(h),0===s.rotationAngle&&(s.rotationAxis=d),s.translation=be(g(),h)}(e,t,o):a?function(e,t,r){const n=e.spatialReference,s=Fe(n),o=xt;if(!oe(r,o,s)&&(V(mt(),r.spatialReference,s,"Falling back to mesh origin"),!oe(e.origin,o,s)))return void V(mt(),e.origin.spatialReference,s);const i=e.vertexAttributes.position,a=e.vertexAttributes.normal,c=e.vertexAttributes.tangent,l=new Float64Array(i.length),u=null!=a?new Float32Array(a.length):null,p=null!=c?new Float32Array(c.length):null;!Y(i,n,l)||null!=a&&null!=u&&!$(a,i,l,n,u)||null!=c&&null!=p&&!H(c,i,l,n,p)?V(mt(),n,s):(ft(l,t,o),!W(l,i,n)||null!=a&&null!=u&&!Z(u,i,l,n,a)||null!=c&&null!=p&&!J(p,i,l,n,c)?V(mt(),s,n):e.vertexAttributesChanged())}(e,t,o):function(e,t,r){const n=xt;if(!oe(r,n,e.spatialReference)){const t=e.origin;return n[0]=t.x,n[1]=t.y,n[2]=t.z,void V(mt(),r.spatialReference,e.spatialReference,q)}ft(e.vertexAttributes.position,t,n),e.vertexAttributesChanged()}(e,t,o)}(this,e,t),this):this}centerAt(e,t){return this._checkIfLoaded("centerAt()")?(function(e,t,r){if(!e.vertexAttributes?.position)return;const{vertexSpace:n}=e,s=r?.origin??e.anchor,o=Ee(Ce,n,s.spatialReference,r?.geographic);L(n)?function(e,t,r){const{vertexSpace:n}=e;if(!L(n))return;const s=ze,o=Ne;if(!oe(t,o,e.spatialReference))return void V(Ce(),t.spatialReference,e.spatialReference,q);if(!oe(r,s,e.spatialReference)){const t=e.origin;return s[0]=t.x,s[1]=t.y,s[2]=t.z,void V(Ce(),r.spatialReference,e.spatialReference,q)}const i=K(Be,o,s);n.origin=Q(g(),n.origin,i)}(e,t,s):o?function(e,t,r){const n=x(r.x,r.y,r.z??0),s=ie(e,new U({origin:n}));if(!s)return;const o=x(t.x,t.y,t.z??0),i=ie({vertexAttributes:s,spatialReference:e.spatialReference,vertexSpace:new U({origin:o})},new T);if(!i)return;const{position:a,normal:c,tangent:l}=i;e.vertexAttributes.position=a,e.vertexAttributes.normal=c,e.vertexAttributes.tangent=l,e.vertexAttributesChanged()}(e,t,s):function(e,t,r){const n=ze,s=Ne;if(oe(t,s,e.spatialReference)){if(!oe(r,n,e.spatialReference)){const t=e.origin;return n[0]=t.x,n[1]=t.y,n[2]=t.z,void V(Ce(),r.spatialReference,e.spatialReference,q)}(function(e,t,r){if(e)for(let n=0;n<e.length;n+=3)for(let s=0;s<3;s++)e[n+s]+=t[s]-r[s]})(e.vertexAttributes.position,s,n),e.vertexAttributesChanged()}else V(Ce(),t.spatialReference,e.spatialReference,q)}(e,t,s)}(this,e,t),this):this}load(e){const{metadata:{displaySource:t}}=this;return t&&this.addResolvingPromise(async function(e,t,r){const{source:s}=t,{loadGLTFMesh:o}=await a(import("../chunks/loadGLTFMesh.js"),r),i=await async function(e,t){if(Array.isArray(e)){if(!e.length)throw new n("mesh-load-external:missing-assets","There must be at least one file to load");return e[0]instanceof File?He(e.map((e=>({name:e.name,mimeType:e.type,source:Ge(e)})))):async function(e,t){const r=await l(e.map((async e=>{const r=await async function(e,t){const{parts:r,assetMimeType:n,assetName:s}=e;if(1===r.length)return new We(r[0].partUrl);const o=await e.toBlob(t);return c(t),We.fromBlob(o,Ze(s,n))}(e);return c(t),{name:e.assetName,mimeType:e.assetMimeType,source:r}})));if(u(t))throw r.forEach((e=>e.source.dispose())),p();return He(r)}(e,t)}return Ge(e)}(s,r);c(r);const m=o(new b({x:0,y:0,z:0,spatialReference:e.spatialReference}),i.url,{resolveFile:De(i),signal:r?.signal,expectedType:i.type});m.then((()=>i.dispose()),(()=>i.dispose()));const{vertexAttributes:f,components:h}=await m;e.vertexAttributes=f,e.components=h}(this,t,e)),Promise.resolve(this)}addExternalSources(e){this.metadata.externalSources.addMany(e)}updateDisplaySource(e){this.metadata.displaySource=e}clone(){return this.cloneAndModifyVertexAttributes(this.vertexAttributes.clone(),this.vertexSpace.clone())}cloneAndModifyVertexAttributes(e,t){let r=null;if(this.components){const e=new Map,t=new Map;r=this.components.map((r=>r.cloneWithDeduplication(e,t)))}const n={components:r,spatialReference:this.spatialReference,vertexAttributes:e,vertexSpace:t,transform:this.transform?.clone()??null,metadata:this.metadata.clone()};return new yt(n)}cloneShallow(){return new yt({components:this.components,spatialReference:this.spatialReference,vertexAttributes:this.vertexAttributes,vertexSpace:this.vertexSpace.clone(),transform:this.transform,metadata:this.metadata})}vertexAttributesChanged(){this.notifyChange("vertexAttributes")}async toBinaryGLTF(e){const[{toBinaryGLTF:t}]=await Promise.all([import("../chunks/gltfexport.js"),this.load(e)]);return c(e),await t(this,e)}get memoryUsage(){let e=0;if(e+=this.vertexAttributes.memoryUsage,null!=this.components)for(const t of this.components)e+=t.memoryUsage;return e}_clearSources(){this.metadata.clearSources()}_checkIfLoaded(e){return!!this.loaded||(jt().error(e,"Mesh must be loaded before applying operations"),!1)}static createBox(e,t){if(!(e instanceof b))return jt().error(".createBox()",Te),null;const r=new yt(Qe(function(){const{faceDescriptions:e,faceVertexOffsets:t,uvScales:r}=Xe,n=4*e.length,s=new Float64Array(3*n),o=new Float32Array(3*n),i=new Float32Array(2*n),a=new Uint32Array(2*e.length*3);let c=0,l=0,u=0,p=0;for(let n=0;n<e.length;n++){const m=e[n],f=c/3;for(const e of t)a[p++]=f+e;const h=m.corners;for(let e=0;e<4;e++){const t=h[e];let n=0;i[u++]=.25*r[e][0]+m.uvOrigin[0],i[u++]=m.uvOrigin[1]-.25*r[e][1];for(let e=0;e<3;e++)0!==m.axis[e]?(s[c++]=.5*m.axis[e],o[l++]=m.axis[e]):(s[c++]=.5*t[n++],o[l++]=0)}}return{position:s,normal:o,uv:i,faces:a}}(),e,t));return t?.imageFace&&"all"!==t.imageFace?function(e,t){const r=e.components[0],n=r.faces,s=et[t],o=6*s,i=new Array(6),a=new Array(n.length-6);let c=0,l=0;for(let e=0;e<n.length;e++)e>=o&&e<o+6?i[c++]=n[e]:a[l++]=n[e];if(null!=e.vertexAttributes.uv){const t=new Float32Array(e.vertexAttributes.uv),r=4*s*2,n=[0,1,1,1,1,0,0,0];for(let e=0;e<n.length;e++)t[r+e]=n[e];e.vertexAttributes.uv=t}return e.components=[new I({faces:i,material:r.material}),new I({faces:a})],e}(r,t.imageFace):r}static createSphere(e,t){return e instanceof b?new yt(Qe(function(e=0){const t=Math.round(8*2**e),r=2*t,n=(t-1)*(r+1)+2*r,s=new Float64Array(3*n),o=new Float32Array(3*n),i=new Float32Array(2*n),a=new Uint32Array((t-1)*r*2*3);let c=0,l=0,u=0,p=0;for(let e=0;e<=t;e++){const n=e/t*Math.PI+.5*Math.PI,m=Math.cos(n),f=Math.sin(n);tt[2]=f;const h=0===e||e===t,d=h?r-1:r;for(let n=0;n<=d;n++){const f=n/d*2*Math.PI;tt[0]=-Math.sin(f)*m,tt[1]=Math.cos(f)*m;for(let e=0;e<3;e++)s[c]=.5*tt[e],o[c]=tt[e],++c;i[l++]=(n+(h?.5:0))/r,i[l++]=e/t,0!==e&&n!==r&&(e!==t&&(a[u++]=p,a[u++]=p+1,a[u++]=p-r),1!==e&&(a[u++]=p,a[u++]=p-r,a[u++]=p-r-1)),p++}}return{position:s,normal:o,uv:i,faces:a}}(t?.densificationFactor||0),e,t)):(jt().error(".createSphere()",Te),null)}static createCylinder(e,t){return e instanceof b?new yt(Qe(function(e=0){const t=Math.round(16*2**e),r=4*(t+1)+2*t,n=new Float64Array(3*r),s=new Float32Array(3*r),o=new Float32Array(2*r),i=new Uint32Array(4*t*3);let a=0,c=0,l=0,u=0,p=0;for(let e=0;e<=5;e++){const r=0===e||5===e,m=e<=1||e>=4,f=2===e||4===e,h=r?t-1:t;for(let d=0;d<=h;d++){const g=d/h*2*Math.PI,x=r?0:.5;tt[0]=x*Math.sin(g),tt[1]=x*-Math.cos(g),tt[2]=e<=2?.5:-.5;for(let t=0;t<3;t++)n[a++]=tt[t],s[c++]=m?2===t?e<=1?1:-1:0:2===t?0:tt[t]/x;o[l++]=(d+(r?.5:0))/t,o[l++]=e<=1?1*e/3:e<=3?1*(e-2)/3+1/3:1*(e-4)/3+2/3,f||0===e||d===t||(5!==e&&(i[u++]=p,i[u++]=p+1,i[u++]=p-t),1!==e&&(i[u++]=p,i[u++]=p-t,i[u++]=p-t-1)),p++}}return{position:n,normal:s,uv:o,faces:i}}(t?.densificationFactor||0),e,t)):(jt().error(".createCylinder()",Te),null)}static createPlane(e,t){if(!(e instanceof b))return jt().error(".createPlane()",Te),null;const r=t?.facing??"up",n=function(e,t){const r="number"==typeof t?t:null!=t?t.width:1,n="number"==typeof t?t:null!=t?t.height:1;switch(e){case"up":case"down":return{width:r,depth:n};case"north":case"south":return{width:r,height:n};case"east":case"west":return{depth:r,height:n}}}(r,t?.size);return new yt(Qe(function(e){const t=Ke.facingAxisOrderSwap[e],r=Ke.position,n=Ke.normal,s=new Float64Array(r.length),o=new Float32Array(n.length);let i=0;for(let e=0;e<4;e++){const e=i;for(let a=0;a<3;a++){const c=t[a],l=Math.abs(c)-1,u=c>=0?1:-1;s[i]=r[e+l]*u,o[i]=n[e+l]*u,i++}}return{position:s,normal:o,uv:new Float32Array(Ke.uv),faces:new Uint32Array(Ke.faces),isPlane:!0}}(r),e,{...t,size:n}))}static createFromPolygon(e,t){if(!(e instanceof A))return jt().error(".createFromPolygon()","Expected polygon to be a Polygon instance"),null;const r=N(e);return new yt({vertexAttributes:new _({position:r.position}),components:[new I({faces:r.faces,shading:"flat",material:t?.material??null})],spatialReference:e.spatialReference,vertexSpace:new T})}static async createFromGLTF(e,t,r){if(!(e instanceof b)){const e=new Ue;throw jt().error(".createfromGLTF()",e.message),e}const{loadGLTFMesh:n}=await a(import("../chunks/loadGLTFMesh.js"),r);return new yt(await n(e,t,r))}static async createFromFiles(e,t,s){if(r(jt(),"`Mesh.createFromFiles` is deprecated in favor of 'SceneLayer.convertMesh'",{replacement:"SceneLayer.convertMesh",version:"4.29"}),!(e instanceof b)){const e=new Ue;throw(e=>{jt().error(".createFromFiles()",e.message)})(e),e}if(!s?.layer)throw new n("invalid:no-layer","SceneLayer required for file to mesh conversion.");return s.layer.convertMesh(t,{location:e,...s})}static createWithExternalSource(e,t,r){const n=r?.extent??null,{spatialReference:s}=e,o=r?.transform?.clone()??new O,i=P(e,r),a={source:t,extent:n},c=new Je;return c.externalSources.push(a),new yt({metadata:c,transform:o,vertexSpace:i,spatialReference:s})}static createIncomplete(e,t){const{spatialReference:r}=e,s=t?.transform?.clone()??new O,o=P(e,t),i=new yt({transform:s,vertexSpace:o,spatialReference:r});return i.addResolvingPromise(Promise.reject(new n("mesh-incomplete","Mesh resources are not complete"))),i}};e([h({type:[I],json:{write:!0}})],bt.prototype,"components",void 0),e([h({nonNullable:!0,types:wt,constructOnly:!0,json:{write:!0}})],bt.prototype,"vertexSpace",void 0),e([h({type:O,json:{write:!0}})],bt.prototype,"transform",void 0),e([h({constructOnly:!0})],bt.prototype,"metadata",void 0),e([h()],bt.prototype,"hasExtent",null),e([h()],bt.prototype,"_transformedExtent",null),e([h()],bt.prototype,"_untransformedBounds",null),e([h()],bt.prototype,"anchor",null),e([h()],bt.prototype,"origin",null),e([h({readOnly:!0,json:{read:!1}})],bt.prototype,"extent",null),e([h({readOnly:!0,json:{read:!1,write:!0,default:!0}})],bt.prototype,"hasZ",void 0),e([h({readOnly:!0,json:{read:!1,write:!0,default:!1}})],bt.prototype,"hasM",void 0),e([h({type:_,nonNullable:!0,json:{write:!0}})],bt.prototype,"vertexAttributes",void 0),bt=yt=e([d(vt)],bt);const At=S(),St=bt;export{St as default,Pe as i};
