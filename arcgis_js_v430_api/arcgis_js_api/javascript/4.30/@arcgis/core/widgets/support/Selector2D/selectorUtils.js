/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.30/esri/copyright.txt for details.
*/
import{whenOrAbort as e,ignoreAbortErrors as s}from"../../../core/promiseUtils.js";import{getDisplayFieldName as r}from"../../../layers/support/fieldUtils.js";import{a as t,b as o,c as i,d as n,e as c}from"../../../chunks/layerUtils2.js";import{c as a,a as l}from"../../../chunks/drapedUtils.js";import{i as u}from"../../../chunks/layerViewUtils.js";import"../../../chunks/handleUtils.js";import"../../../core/Error.js";import"../../../core/lang.js";import"../../../chunks/Logger.js";import"../../../config.js";import"../../../chunks/maybe.js";import"../../../core/Accessor.js";import"../../../core/Handles.js";import"../../../core/accessorSupport/decorators/subclass.js";import"../../../chunks/metadata.js";import"../../../chunks/utils.js";import"../../../chunks/tracking.js";import"../../../chunks/ensureType.js";import"../../../core/accessorSupport/decorators/property.js";import"../../../chunks/ObservableBase.js";import"../../../core/scheduling.js";import"../../../core/sql.js";import"../../../intl.js";import"../../../chunks/date.js";import"../../../chunks/jsonMap.js";import"../../../chunks/locale.js";import"../../../chunks/timeZoneUtils.js";import"../../../chunks/datetime.js";import"../../../chunks/number.js";import"../../../chunks/substitute.js";import"../../../chunks/messages.js";import"../../../request.js";import"../../../kernel.js";import"../../../core/urlUtils.js";import"../../../core/JSONSupport.js";import"../../../chunks/tslib.es6.js";import"../../../chunks/assets.js";import"../../../chunks/mathUtils.js";import"../../../chunks/vec3.js";import"../../../chunks/vec3f64.js";import"../../../chunks/common.js";import"../../../geometry.js";import"../../../geometry/Extent.js";import"../../../geometry/Geometry.js";import"../../../chunks/reader.js";import"../../../geometry/SpatialReference.js";import"../../../chunks/unitUtils.js";import"../../../chunks/writer.js";import"../../../geometry/Point.js";import"../../../core/accessorSupport/decorators/cast.js";import"../../../geometry/support/webMercatorUtils.js";import"../../../geometry/Multipoint.js";import"../../../chunks/zmUtils.js";import"../../../geometry/Polygon.js";import"../../../chunks/coordsUtils.js";import"../../../chunks/Axis.js";import"../../../chunks/extentUtils.js";import"../../../chunks/aaBoundingRect.js";import"../../../geometry/Polyline.js";import"../../../chunks/typeUtils.js";import"../../../geometry/support/jsonUtils.js";async function p(){return import("../../../chunks/geometryEngineJSON.js").then((e=>e.g))}async function m(){return p().then((({contains:e,intersects:s,overlaps:r,simplify:t})=>({contains:e,intersects:s,overlaps:r,simplify:t})))}async function y(s){const{currentSelection:r,selector:a,signal:l,sources:p,view:m}=s;if(!p?.length)return{added:[],removed:[]};const{layers:y,layerViews:f,graphicsLayers:k}=function(e){const s=[],r=[],a=[];return e.forEach((e=>{t(e)?s.push(e):(o(e)||i(e))&&e.layers?.length?s.push(...e.layers.toArray()):n(e)&&e.sublayers?.length?a.push(...e.sublayers.toArray()):c(e)?a.push(e):u(e)&&r.push(e)})),{layers:s,layerViews:r,graphicsLayers:a}}(p),w=(await e(Promise.all([d(a,y,m,l),h(a,f,m,l),j(a,k,m)]),l)).flat();if(!r)return{added:w,removed:[]};const v=r.toArray(),U=w.filter((e=>!g(v,e))),b=v.filter((e=>!g(w,e)));return r.removeMany(b),r.addMany(U),{added:U,removed:b}}const j=async(e,s,r)=>U({candidates:s.flatMap((e=>e.graphics.toArray()))??[],selector:e,view:r}),d=async(e,r,t,o)=>{const i=await s(w({selector:e,signal:o,layers:r,view:t}));return i?f(i):[]},h=async(e,r,t,o)=>{const i=await s(k({selector:e,signal:o,layerViews:r,view:t}));return i?f(i):[]};function f(e){const s=[];for(let r=0;r<e.length;r++){const t=e[r];"fulfilled"===t.status&&s.push(...t.value)}return s}function g(e,s){if(e.includes(s))return!0;const r=s.getObjectId(),t=null!=r,{layer:o,uid:i}=s;return t?e.some((e=>{if(o===e.layer)return r===e.getObjectId()})):e.some((e=>{if(o===e.layer)return i===e.uid}))}async function k(s){const{layerViews:r,selector:t,signal:o,view:i}=s;return e(Promise.allSettled(r.map((async e=>{const s=e.createQuery(),{geometry:r}=v(t,e.layer,i);return s.outFields=["*"],s.geometry=r,s.returnGeometry=!0,s.outSpatialReference=i.spatialReference,e.queryFeatures(s,{signal:o}).then((({features:e})=>e))}))),o)}async function w(s){const{layers:r,selector:t,signal:o,view:i}=s;return e(Promise.allSettled(r.map((async e=>e.queryFeatures(function(e,s,r,t){const{outFields:o,geometry:i}=v(s,r,t);return e.outFields=o,e.geometry=i,e.returnGeometry=!0,e.outSpatialReference=t.spatialReference,e}(e.createQuery(),t,e,i),{signal:o}).then((({features:e})=>e))))),o)}function v(e,s,t){const o="displayField"in s?s.displayField:null,i=r({displayField:o,fields:s.fields}),n=[s.objectIdField];null!=i&&s.fieldsIndex.has(i)&&n.push(i);const c="renderer"in s?a({renderer:s.renderer}):0;return{geometry:"point"===e.type?l(e,c,t):e,outFields:n}}async function U(e){const{selector:s,candidates:r,view:t}=e;if(!r?.length||!s)return[];const{spatialReference:o}=t,i=s,n=await m();return r.filter((e=>n.intersects(o,i,e.geometry)))}export{m as getGeometryEngineOperations,v as getQueryOptionsFromLayer,k as getSelectionFromFeatureLayerViews,w as getSelectionFromFeatureLayers,y as getSelectionFromGeometry,U as getSelectionFromGeometryEngine,p as importGeometryEngine};
