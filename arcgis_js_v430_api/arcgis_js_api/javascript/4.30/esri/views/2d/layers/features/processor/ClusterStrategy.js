// All material copyright Esri, All Rights Reserved, unless otherwise specified.
// See https://js.arcgis.com/4.30/esri/copyright.txt for details.
//>>built
define("exports ../../../../../layers/graphics/featureConversionUtils ../../../../../layers/graphics/OptimizedFeature ../../../../../layers/graphics/OptimizedGeometry ../../../engine/webgl/definitions ../aggregation/ComputedAggregateField ../aggregation/GridCell ../aggregation/GridSpatialIndex ./AAggregateStrategy ./AProcessorStrategy ./support/WithDisplayId ../sources/FeatureSourceMessage ../support/ComputedAttributeStorage ../support/FeatureFilter ../support/FeatureMetadata ../support/FeatureSetReaderJSON ../../../tiling/TileKey".split(" "),
function(r,x,p,t,m,y,z,u,A,B,C,D,E,F,G,H,I){class v extends B.ASendState{constructor(a){super(a);this.done=this.didSend=!1}}class J{constructor(a,b,e,d,c){this._level=a;this._scale=b;this._indexOptions=e;this._clusterRadius=d;this._store=c;this._cells=new Map;this._handledChunks=new Set;this._statistics=new Map;this._clusters=new Map}destroy(){this._clearClusters()}_clearClusters(){for(const a of this._clusters.values())this._store.releaseDisplayIdForObjectId(a.inner.id);this._clusters.clear()}*aggregatesWorldSpace(){for(const b of this._clusters.values()){var a=
b.inner.getCentroid(null);a=new p.OptimizedFeature(a,b.inner.getAttributes(),null);a.objectId=b.inner.id;a.displayId=b.displayId;yield a}}clusters(){return this._clusters.values()}updateChunks(a,b){let e=!1;for(var d of a)a=d.queryInfo,"tileId"in a&&(new I(a.tileId)).level!==this._level||this._handledChunks.has(d.normalizedChunkId)||(this._handledChunks.add(d.normalizedChunkId),e=!0,d.getAggregateIndex({...this._indexOptions,scale:this._scale}).put(this._cells));d={xMin:Infinity,yMin:Infinity,xMax:-Infinity,
yMax:-Infinity};a=u.pixelsPerMapUnit(this._indexOptions.spatialReference,this._scale);const c=this._indexOptions.cellSize;for(const {subscription:g}of b){b=g.tile.bounds;const f=Math.floor(b[1]*a/c),h=Math.ceil(b[2]*a/c),k=Math.ceil(b[3]*a/c);d.xMin=Math.min(d.xMin,Math.floor(b[0]*a/c));d.yMin=Math.min(d.yMin,f);d.xMax=Math.max(d.xMax,h);d.yMax=Math.max(d.yMax,k)}if(null==this._lastCellBounds||d.xMin!==this._lastCellBounds.xMin||d.yMin!==this._lastCellBounds.yMin||d.yMin!==this._lastCellBounds.yMin||
d.yMax!==this._lastCellBounds.yMax)e=!0,this._lastCellBounds=d;e&&this._clusterCells(d);return e}async updateStatistics(a){var b=!1;for(const e of this._clusters.values())1<e.inner.count&&(b=this._updateAggregateStatistics(this._statistics,e.inner)||b);b&&(b=Array.from(this._statistics.entries()).map(([e,d])=>({fieldName:e,minValue:d.minValue,maxValue:d.maxValue})),await a.container.updateStatistics(this._level,b))}createAggregateFeatures(a,b){a=a.subscription;const e=[],d=a.tile.transform;for(const h of this._clusters.values()){var c=
h.inner.getCentroidX(d);const k=h.inner.getCentroidY(d);var g=a.tile.lod,f=g.wrap?g.worldSize[0]:null;g=1===h.inner.count?h.inner.firstObjectId:h.inner.id;const l=h.displayId;null!=f&&(1===f?(f=new t([],[c,k]),f=new p.OptimizedFeature(f,h.inner.getAttributes(),null),f.geometry.coords[0]-=m.tileSize,f.objectId=g,f.displayId=l,e.push(f),f=new t([],[c,k]),f=new p.OptimizedFeature(f,h.inner.getAttributes(),null),f.geometry.coords[0]+=m.tileSize,f.objectId=g,f.displayId=l,e.push(f)):c>m.tileSize+m.tileSize/
2?c-=f*m.tileSize:c<-(m.tileSize/2)&&(c+=f*m.tileSize));c<m.tileSize+128&&-128<=c&&k<m.tileSize+128&&-128<=k&&(c=new t([],[c,k]),c=new p.OptimizedFeature(c,h.inner.getAttributes(),null),c.objectId=g,c.displayId=l,e.push(c))}return H.FeatureSetReaderJSON.fromOptimizedFeatures(e,b,a.tile.transform)}_clusterCells(a){var b=Array.from(this._cells.values());b=b.sort((f,h)=>h.count-f.count);const e=[];for(var d of this._clusters.values())e.push(d.inner.id);this._clusters.clear();d=this._clusterRadius*(1/
u.pixelsPerMapUnit(this._indexOptions.spatialReference,this._scale));const c=1+this._clusterRadius/this._indexOptions.cellSize,g=new Set;for(const f of b){if(g.has(f.id))continue;if(f.gridX<a.xMin||f.gridX>a.xMax||f.gridY<a.yMin||f.gridY>a.yMax)continue;b=this._store.createDisplayIdForObjectId(f.id);b=new C.WithDisplayId(f.clone(),b);g.add(f.id);this._clusters.set(f.id,b);const h=f.centroidXWorld,k=f.centroidYWorld;for(let l=f.gridY-c;l<=f.gridY+c;l++)for(let q=f.gridX-c;q<=f.gridX+c;q++){if(l===
f.gridY&&q===f.gridX)continue;const n=this._cells.get(z.GridCell.createId(q,l));if(!n||g.has(n.id))continue;const K=Math.abs(n.centroidYWorld-k);Math.abs(n.centroidXWorld-h)<d&&K<d&&(b.inner.merge(n),g.add(n.id))}}for(const f of e)this._store.releaseDisplayIdForObjectId(f)}_updateAggregateStatistics(a,b){let e=!1;for(const g of b.statistics.values())if("esriFieldTypeString"!==g.field.type){var d=g.value,c=g.field;if(b=a.get(c.name)){const {minValue:f,maxValue:h}=b;c=Math.min(b.minValue,d);d=Math.max(b.maxValue,
d);if(f!==c||h!==d)b.minValue=c,b.maxValue=d,e=!0}else a.set(c.name,{minValue:d,maxValue:d}),e=!0}return e}}class w extends A.AAggregateStrategy{static async create(a,b,e,d,c,g){const f=new E.ComputedAttributeStorage({spatialReference:e}),h=await Promise.all(b.fields.map(async l=>y.ComputedAggregateField.create(f,l))),k=b.featureFilter?await F.create({geometryType:d.metadata.geometryType,hasM:!1,hasZ:!1,timeInfo:d.metadata.timeInfo,fieldsIndex:d.metadata.fieldsIndex,spatialReference:e,filterJSON:b.featureFilter}):
null;return new w(a,b.clusterRadius,{type:"grid",fields:h,spatialReference:e,featureFilter:k,cellSize:b.clusterRadius/4,timeZone:g},b.fields,d,c)}constructor(a,b,e,d,c,g){super(c,g,e.spatialReference,e.fields);this._connection=a;this._clusterRadius=b;this._indexOptions=e;this._cellsPerScale=new Map;this._metadata=new G.FeatureMetadata({geometryType:"esriGeometryPoint",objectIdField:"aggregateId",fields:[...d,...this._source.metadata.fieldsIndex.fields,{name:"aggregateId",alias:"aggregateId",type:"esriFieldTypeOID"}],
globalIdField:null,spatialReference:c.metadata.spatialReference,subtypeField:null,subtypes:null,timeInfo:null,timeReferenceUnknownClient:null,typeIdField:null,types:null})}get enablePixelBuffering(){return!1}invalidate(){super.invalidate();for(const a of this._cellsPerScale.values())a.destroy();this._cellsPerScale.clear()}onSubscribe(a){super.onSubscribe(a);this._requiredLevel=a.tile.level;this._requiredScale=a.tile.scale}createState(a){return new v(a)}async *applyLocalEdit(a){for(const b of this._cellsPerScale.values())b.destroy();
this._cellsPerScale.clear();for(const b of this._sendStates.values())b.done=!1}displayMap(a,b,e){a=new Map(a.map(g=>[b(g),g]));const d=[];var c=this._getClusterState(this._requiredLevel,this._requiredScale);for(const g of c.clusters())c=a.get(g.inner.id),null!=c?(c=e(g.displayId,c,g.inner.id),d.push(c),a.delete(g.inner.id)):1===g.inner.count&&(c=a.get(g.inner.firstObjectId),null!=c&&(c=e(g.displayId,c,g.inner.firstObjectId),d.push(c),a.delete(g.inner.firstObjectId)));return d}getDisplayFeatures(a){a=
new Set(a);const b=new Set,e=[],d=[];var c=this._getClusterState(this._requiredLevel,this._requiredScale);for(const g of c.aggregatesWorldSpace())a.has(g.displayId)&&!b.has(g.displayId)&&(c=x.convertToFeature(g,this._metadata.geometryType,!1,!1),b.add(g.displayId),1===c.attributes.cluster_count?e.push({...c,displayId:g.displayId}):d.push({...c,displayId:g.displayId}));return{features:e,aggregates:d}}getFeatureObjectIdsForAggregate(a){const b=this._getClusterState(this._requiredLevel,this._requiredScale);
for(const e of b.clusters())if(e.inner.id===a)return Array.from(e.inner.containedObjectIds);return[]}async *updateChunks(){var a=this._source.chunks();if(a.length){var b=this._getClusterState(this._requiredLevel,this._requiredScale),e=Array.from(this._sendStates.values()).filter(c=>c.subscription.tile.level===this._requiredLevel);if(b.updateChunks(a,e)||!this._source.updateTracking.updating)for(const c of e)c.subscription.tile.level===this._requiredLevel&&(c.didSend=!1,c.done=!1);a=Array.from(this._sendStates.values()).filter(c=>
c.done).map(c=>c.subscription.tile.key);var d=new Set(a);for(const c of this._sendStates.values()){if(this._source.updateTracking.updating){if(a.some(g=>g.containsChild(c.subscription.tile.key)))continue;if(c.subscription.tile.key.getChildKeys().every(g=>d.has(g)))continue}c.didSend||c.subscription.tile.level!==this._requiredLevel||(c.didSend=!0,yield*this._update(c,b,this._source))}await b.updateStatistics(this._connection)}}forEachAggregateWorldSpace(a){if(null!=this._requiredLevel&&null!=this._requiredScale){var b=
this._getClusterState(this._requiredLevel,this._requiredScale);for(const e of b.aggregatesWorldSpace())a(e)}}_getClusterState(a,b){if(null==a||null==b)throw Error("InternalError: Level and scale must be defined");let e=this._cellsPerScale.get(b);e||(e=new J(a,b,this._indexOptions,this._clusterRadius,this._attributeStore),this._cellsPerScale.set(b,e));return e}async *_update(a,b,e){if(!a.done){b=b.createAggregateFeatures(a,this._metadata);this.events.emit("changed");a.done=!e.updateTracking.updating;
e=b.getCursor();for(var d=a.subscription.tile.createArcadeEvaluationOptions(this._indexOptions.timeZone);e.next();)this._attributeStore.setAttributeData(e.getDisplayId(),e,d);yield new D.FeatureTileAppendMessage(a.subscription,b,!0,a.done,{})}}}r.ClusterState=v;r.ClusterStrategy=w;Object.defineProperty(r,Symbol.toStringTag,{value:"Module"})});