// All material copyright Esri, All Rights Reserved, unless otherwise specified.
// See https://js.arcgis.com/4.30/esri/copyright.txt for details.
//>>built
define("../../../../geometry ../../../../core/events ../../../../core/Handles ../../../../core/maybe ../../../../core/reactiveUtils ../../../../core/screenUtils ../../../../core/libs/gl-matrix-2/factories/vec2f64 ../../../../geometry/projection ../DisplayObject ../../../layers/support/Geometry ../../../webgl/BufferObject ../../../webgl/enums ../../../webgl/Texture ../../../webgl/TextureDescriptor ../../../webgl/VertexArrayObject ../../../../geometry/Polygon ../../../../geometry/Point".split(" "),
function(M,B,C,D,z,w,E,m,F,G,x,p,H,I,J,K,y){class L extends F.DisplayObject{constructor(b){super();this.element=b;this._handles=new C;this.isWrapAround=!1;this.perspectiveTransform=E.create();this.wrapAroundShift=0;this.clipGeometry=null;this._handles.add(z.when(()=>this.element,()=>{const a=this.element;this.ready();a&&this._handles.add(B.on(a,"play",()=>this.requestRender()))},z.initial))}getMesh(b){throw Error("Method not implemented.");}destroy(){this._handles.destroy();this.texture=D.disposeMaybe(this.texture);
this._vao&&(this._vao.dispose(),this._vao=null);this._vbo&&(this._vbo.dispose(),this._vbo=null);this.texture&&(this.texture.dispose(),this.texture=null)}get textureSize(){if(!this.texture)return[1,1];const b=this.texture.descriptor;return[b.width,b.height]}get dvsMat3(){return this.parent.dvsMat3}beforeRender(b){const a=this.element;if(null!=a){var {context:d}=b,{videoWidth:c,videoHeight:e}=a;if(0!==c&&0!==e){if(this.texture)a.paused||this.texture.setData(a);else{const f=new I.TextureDescriptor;f.wrapMode=
p.TextureWrapMode.CLAMP_TO_EDGE;f.preMultiplyAlpha=!0;f.width=c;f.height=e;this.texture=new H.Texture(d,f,a)}a.paused||(this.texture.generateMipmap(),this.requestRender());super.beforeRender(b)}}}_createTransforms(){return null}updateDrawCoords(b,a,d,c){var e=this.element,f=this._getFrameInfo();if(e&&f){this._initializeData(b,f,d);var {controlPoints:g,horizon:h}=f;e=Math.sqrt(g.length);var {x:r,y:t}=b;b=this._vertices;var l=g[0];f=g[e-1];var k=g[(e-1)*e],n=g[(e-1)*e+e-1];e=m.project(h?h[0].mapPoint:
l.mapPoint,d);f=m.project(h?h[1].mapPoint:f.mapPoint,d);k=m.project(k.mapPoint,d);n=m.project(n.mapPoint,d);this.clipGeometry=h?new G({geometry:K.fromJSON({rings:[[[k.x,k.y],[n.x,n.y],[f.x,f.y],[e.x,e.y],[k.x,k.y]]],spatialReference:d})}):null;for(l=0;l<g.length;l++){const {sourcePoint:u,mapPoint:v}=g[l];if(null==u||null==v)continue;const q=m.project(v,d);b[2*l]=q.x-r;b[2*l+1]=q.y-t}if(c){d=Math.min(e.x,f.x,k.x,n.x);b=Math.max(e.x,f.x,k.x,n.x);const {worldWidth:u,xBounds:v}=c,[q,A]=v;d<q&&b>q?a=u:
b>A&&d<A&&(a=-u)}this.wrapAroundShift=a;this.isWrapAround=0!==a}}getVAO(b,a,d){if(null==this._vertices)return null;var c=this._vertices;this._vao?this._vbo.setData(c):(this._vbo=x.BufferObject.createVertex(b,p.Usage.DYNAMIC_DRAW,c),c=x.BufferObject.createVertex(b,p.Usage.STATIC_DRAW,this._texCoords),this._ibo=x.BufferObject.createIndex(b,p.Usage.DYNAMIC_DRAW,this._indices),this._vao=new J.VertexArrayObject(b,d,a,{geometry:this._vbo,tex:c},this._ibo));return this._vao}draw(b){b.drawElements(p.PrimitiveType.TRIANGLE_STRIP,
this._indices.length,b.gl.UNSIGNED_SHORT,0)}_initializeData(b,a,d){if(null==this._vertices||null==this._indices){var {controlPoints:c}=a;a=Math.sqrt(c.length);var e=new Float32Array(2*c.length),f=new Uint16Array(2*c.length);for(var g=0;g<c.length;g++){const {sourcePoint:h,mapPoint:r}=c[g];if(null==h||null==r)continue;const t=m.project(r,d);e[2*g]=t.x-b.x;e[2*g+1]=t.y-b.y;f[2*g]=h.x;f[2*g+1]=h.y}b=new Uint16Array(a*a+(a-2)*(a+2));d=0;for(c=0;c<a;c++){for(g=0;g<a;g++)b[d++]=c*a+g,b[d++]=(c+1)*a+g;c<
a-2&&(b[d++]=(c+1)*a+(a-1),b[d++]=(c+1)*a)}this._vertices=e;this._texCoords=f;this._indices=b}}_getFrameInfo(){if(!this.groundControlPoints)return null;const b=this._getFrameControlPoints(),a=this.frameHorizonPoints;var d=null;if(a){d=a.endX;const c=a.endY;d=[{sourcePoint:w.createScreenPoint(a.startX,a.startY),mapPoint:new y(a.startLongitude,a.startLatitude)},{sourcePoint:w.createScreenPoint(d,c),mapPoint:new y(a.endLongitude,a.endLatitude)}]}return{controlPoints:b,horizon:d}}_getFrameControlPoints(){const b=
this.groundControlPoints,a=b?.length;if(!a)return[];const d=Array(a);for(let c=0;c<a;c++){const {x:e,y:f,lat:g,lon:h}=b[c];d[c]={sourcePoint:w.createScreenPoint(e,-f),mapPoint:new y(h,g)}}return d}}return L});