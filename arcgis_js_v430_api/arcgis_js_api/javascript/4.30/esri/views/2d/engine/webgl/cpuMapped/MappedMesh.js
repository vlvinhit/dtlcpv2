// All material copyright Esri, All Rights Reserved, unless otherwise specified.
// See https://js.arcgis.com/4.30/esri/copyright.txt for details.
//>>built
define("exports ../../../../../core/maybe ../number ./Buffer ../shaderGraph/techniques/mesh/dataViewUtils ../../../../webgl/enums ../../../../webgl/VertexArrayObject".split(" "),function(q,r,w,t,x,y,u){function z(a,b){const c=[],e=a.attributes.filter(d=>b.locations.has(d.name));for(const d of e)c.push({name:d.name,type:d.type,count:d.count,divisor:0,normalized:d.normalized??!1,offset:d.offset,stride:a.stride});return{geometry:c}}function A(a,b){const c=[];var e=a.attributes.filter(d=>b.locations.has(d.name));
for(const d of e)c.push({name:d.name,type:d.type,count:d.count,divisor:0,normalized:d.normalized??!1,offset:d.offset,stride:a.stride}),e=b.computeAttributeMap[d.name],null!=e&&2===e.length&&(c.push({name:e[0],count:d.count,divisor:0,type:d.type,normalized:d.normalized??!1,offset:d.offset+a.stride,stride:a.stride}),c.push({name:e[1],count:d.count,divisor:0,type:d.type,normalized:d.normalized??!1,offset:d.offset+2*a.stride,stride:a.stride}));return{geometry:c}}class B{constructor(a,b){this._bufferPool=
a;this._layout=b;this._invalidated=!1;this._position=this._layout.attributes.find(c=>"pos"===c.name||"position"===c.name);if(!this._position)throw Error("InternalError: Unable to find position attribute");}destroy(){this._indexBuffer=r.destroyMaybe(this._indexBuffer);this._vertexBuffer=r.destroyMaybe(this._vertexBuffer);this._computeVAO?.disposeVAOOnly();this._geometryVAO?.disposeVAOOnly()}get layout(){return this._layout}getDrawArgs(a,b,c,e){return e?{primitive:y.PrimitiveType.POINTS,count:b/3,offset:c/
3}:{primitive:a,count:b,offset:c}}getAttributePrecisionPackFactors(){const a={};for(const b of this.layout.attributes)b.packPrecisionFactor&&(a[b.name]=b.packPrecisionFactor);return a}getDebugVertexInfo(a=!1){if(!this._vertexBuffer)return null;const b=this._layout,c=b.stride;var e=this._vertexBuffer.getView(0,this._vertexBuffer.byteSize);const d=new DataView(e.slice().buffer);e=e.byteLength/c;a&&(e=this._indexBuffer.fillPointer/3);const n=this._indexBuffer.getView(0,this._indexBuffer.byteSize);let k=
0;const m=[];for(let f=0;f<e;f++){a&&(k=n[3*f]*c);const g={};for(const h of b.attributes){let v=`${h.offset} ${h.name}`,l=x.unpackDataView(d,h,k);if(h.packPrecisionFactor)if(v+=` (precision: ${h.packPrecisionFactor})`,"number"===typeof l)l/=h.packPrecisionFactor;else for(let p=0;p<l.length;p++)l[p]/=h.packPrecisionFactor;g[v]=l}k+=c;m.push(g)}return{vertices:m,layout:b}}_ensure(a,b){if(this._vertexBuffer&&this._indexBuffer)this._indexBuffer.ensure(Math.max(a,1E3)),this._vertexBuffer.ensure(Math.max(b,
1E3));else{const c=this._layout.stride/Uint32Array.BYTES_PER_ELEMENT;this._indexBuffer=new t.MappedBuffer("index",Math.max(a,1E3),1,this._bufferPool);this._vertexBuffer=new t.MappedBuffer("vertex",Math.max(b,1E3),c,this._bufferPool)}}append(a){var b=a.layout.stride;this._ensure(a.indices.byteLength/Uint32Array.BYTES_PER_ELEMENT,a.vertices.byteLength/b);const {vertices:c,indices:e}=a;a=this._vertexBuffer.insert(c,0,c.byteLength/b,0);b=this._indexBuffer.insert(e,0,e.byteLength/4,a);return{vertexFrom:a,
indexFrom:b}}copyRecordFrom(a,b,c,e){const {indexStart:d,indexCount:n,vertexStart:k,vertexCount:m}=b;this._ensure(n,m);const f=a._position;var g=f.offset;c=w.i1616to32(c*(f.packPrecisionFactor??1),e*(f.packPrecisionFactor??1));g=this._vertexBuffer.copyFrom(a._vertexBuffer,k,m,c,g);a=this._indexBuffer.copyFrom(a._indexBuffer,d,n,g-k,0);b=b.clone();b.vertexStart=g;b.indexStart=a;b.overlaps=0;return b}remove(a,b,c,e){this._indexBuffer.free(a,b);this._vertexBuffer.free(c,e)}upload(){this._invalidated=
!0}getGeometryVAO(a,b){if(!this._vertexBuffer||!this._indexBuffer||!this._vertexBuffer.bufferSize)return null;if(this._invalidated){if(this._vertexBuffer.invalidated||this._indexBuffer.invalidated)this._vertexBuffer.invalidate(),this._indexBuffer.invalidate(),this._geometryVAO?.disposeVAOOnly(),this._geometryVAO=null;this._vertexBuffer.upload();this._indexBuffer.upload();const c=this._indexBuffer.getGPUBuffer(a,!1),e=this._vertexBuffer.getGPUBuffer(a);this._geometryVAO||(this._geometryVAO=new u.VertexArrayObject(a,
b.locations,z(this.layout,b),{geometry:e},c));this._invalidated=!1}return this._geometryVAO}getComputeVAO(a,b){if(!this._vertexBuffer||!this._indexBuffer||!this._vertexBuffer.bufferSize)return null;if(this._vertexBuffer.invalidated||this._indexBuffer.invalidatedComputeBuffer)this._vertexBuffer.invalidate(),this._indexBuffer.invalidate(),this._computeVAO?.disposeVAOOnly(),this._computeVAO=null;this._vertexBuffer.upload();this._indexBuffer.upload();const c=this._indexBuffer.getGPUBuffer(a,!0),e=this._vertexBuffer.getGPUBuffer(a);
this._computeVAO||(this._computeVAO=new u.VertexArrayObject(a,b.locations,A(this.layout,b),{geometry:e},c),this._invalidated=!1);return this._computeVAO}get memoryStats(){return{bytesUsed:this._vertexBuffer.memoryStats.bytesUsed+this._indexBuffer.memoryStats.bytesUsed,bytesReserved:this._vertexBuffer.memoryStats.bytesReserved+this._indexBuffer.memoryStats.bytesReserved,vertex:this._vertexBuffer.memoryStats,index:this._indexBuffer.memoryStats}}reshuffle(a){this._vertexBuffer&&this._vertexBuffer.reshuffle(a.vertex.count,
a.vertex.operations);this._indexBuffer&&this._indexBuffer.reshuffle(a.index.count,a.index.operations)}}q.MappedMesh=B;Object.defineProperty(q,Symbol.toStringTag,{value:"Module"})});