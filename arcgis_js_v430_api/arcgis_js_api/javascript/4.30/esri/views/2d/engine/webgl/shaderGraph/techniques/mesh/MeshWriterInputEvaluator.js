// All material copyright Esri, All Rights Reserved, unless otherwise specified.
// See https://js.arcgis.com/4.30/esri/copyright.txt for details.
//>>built
define("exports ../../../../../../../core/arrayUtils ../../../../../../../core/Error ../../../../../../../core/lang ../../../../../../../core/Logger ../../../grouping ./utils ../../../../../layers/features/support/DictionaryValue".split(" "),function(w,u,B,C,D,E,F,G){async function v(c,e,f=!1){const {defaultValue:a,valueExpressionInfo:h,value:l}=e;if(h){const {expression:g}=h;return(c=await c.createComputedField({expression:g},f))?{...e,computed:c,defaultValue:a}:null}return{...e,computed:new G.DictionaryValue(l),
defaultValue:a}}async function x(c,e){const {defaultValue:f,valueExpressionInfo:a}=e,{expression:h}=a;return(c=await c.createComputedField({expression:h}))?{...e,computed:c,defaultValue:f}:null}const y=c=>"boolean"!==typeof c&&"number"!==typeof c&&"valueExpressionInfo"in c,H=c=>c.some(e=>{for(const f in e)if(y(e[f]))return!0;return!1});class z{static async create(c,e,f){const a={},h=new Map,l=new Map,g=new Map,m=new Map,p=new Map;for(const d in f){const b=f[d];if(null==b||"object"!==typeof b)a[d]=
b;else if(Array.isArray(b)){if("object"===typeof b[0])throw Error(`InternalError: Cannot handle ${d}. Nested array params are not supported`);a[d]=b}else if("valueExpressionInfo"in b)if(b.value)a[d]=b.value;else{var k=await x(c,b);k?(h.set(d,k),a[d]=null):a[d]=b.defaultValue}else switch(b.type){case "cim-effect-infos":if(b.effectInfos.some(n=>n.overrides.length)){l.set(d,{effects:await Promise.all(b.effectInfos.map(async n=>{const r=n.overrides.map(q=>v(c,q));return{effect:n.effect,compiledOverrides:(await Promise.all(r)).filter(u.isSome)}}))});
break}a[d]=b.effectInfos.map(n=>n.effect);break;case "cim-marker-placement-param":b.overrides.length&&g.set(d,{placementInfo:b,compiledOverrides:(await Promise.all(b.overrides.map(n=>v(c,n)))).filter(u.isSome)});a[d]=b.placement;break;case "text-rasterization-param":if(b.overrides.length){k=b.overrides.map(n=>v(c,n,b.useLegacyLabelEvaluationRules));m.set(d,{compiledOverrides:(await Promise.all(k)).filter(u.isSome),rasterizationParam:b,objectIdToResourceId:new Map});continue}a[d]=await e.fetchResourceImmediate({type:"cim-rasterization-info",
resource:b.resource})??null;break;case "sprite-rasterization-param":if(b.overrides.length){k=b.overrides.map(n=>v(c,n));m.set(d,{compiledOverrides:(await Promise.all(k)).filter(u.isSome),rasterizationParam:b,objectIdToResourceId:new Map});continue}if("animated"===b.resource.type){m.set(d,{compiledOverrides:[],rasterizationParam:b,objectIdToResourceId:new Map});continue}a[d]=await e.fetchResourceImmediate({type:"cim-rasterization-info",resource:b.resource})??null;break;case "cim-marker-transform-param":({params:k}=
b);if(H(k)){const n={compiledMarkerInfos:[]};await Promise.all(k.map(async r=>{const q={props:{}};for(const t in r)if(y(r[t])){const A=await x(c,r[t]);q.compiledExpressionMap||(q.compiledExpressionMap=new Map);const I=q.compiledExpressionMap;A&&I.set(t,A)}else q.props[t]=r[t];n.compiledMarkerInfos.push(q)}));p.set(d,n)}else a[d]={type:"cim-marker-transform-info",infos:k};break;default:a[d]=b}}return new z(f,a,h,l,g,m,p)}constructor(c,e,f,a,h,l,g){this.inputMeshParams=c;this._resolvedMeshParams=e;
this._dynamicProperties=f;this._dynamicEffectProperties=a;this._dynamicPlacementProperties=h;this._dynamicAsyncProperties=l;this._dynamicTransformProperties=g;this.evaluator=m=>m}get hasDynamicProperties(){return!!(this._dynamicProperties.size||this._dynamicAsyncProperties.size||this._dynamicEffectProperties.size||this._dynamicTransformProperties.size||this._dynamicPlacementProperties.size)}get evaluatedMeshParams(){this._evaluatedMeshParams||(this._evaluatedMeshParams=this.evaluator(this._resolvedMeshParams));
return this._evaluatedMeshParams}enqueueRequest(c,e,f){for(const h of this._dynamicAsyncProperties.values()){var a=C.clone(h.rasterizationParam.resource);"animated"===h.rasterizationParam.resource.type&&h.rasterizationParam.resource.randomizeStartTime&&(a.primitiveName="__RESERVED__PRIMITIVE__NAME__",a.startGroup=E.getStartGroup(e.getObjectId()||0));for(const {primitiveName:l,propertyName:g,computed:m,defaultValue:p,valueExpressionInfo:k}of h.compiledOverrides)try{F.applyComputedValue(a,"animated"===
h.rasterizationParam.resource.type?a.primitiveName:l,g,m,e,f,p)}catch(d){D.getLogger("esri.views.2d.engine.webgl.shaderGraph.techniques.mesh.MeshWriterInputEvaluator").errorOnce(new B("invalid-arcade-expression",`Encountered an error when evaluating the arcade expression '${k?.expression}' (primitive: '${l}', property: '${g}')`,d))}a=c.enqueueRequest({type:"cim-rasterization-info",resource:a});h.objectIdToResourceId.set(e.getObjectId(),a)}}evaluateMeshParams(c,e,f){for(const [l,g]of this._dynamicProperties.entries())this._resolvedMeshParams[l]=
g.computed.readWithDefault(e,f,g.defaultValue);for(const [l,g]of this._dynamicPlacementProperties.entries())for(const {computed:m,defaultValue:p,propertyName:k}of g.compiledOverrides){var a=m.readWithDefault(e,f,p);g.placementInfo.placement[k]=a;this._resolvedMeshParams[l]=g.placementInfo.placement}for(const [l,g]of this._dynamicEffectProperties.entries())for(var h of g.effects){for(const {computed:m,defaultValue:p,propertyName:k}of h.compiledOverrides)a=m.readWithDefault(e,f,p),h.effect[k]=a;this._resolvedMeshParams[l]=
g.effects.map(m=>m.effect)}for(const [l,g]of this._dynamicTransformProperties.entries()){h={type:"cim-marker-transform-info",infos:[]};for(const m of g.compiledMarkerInfos){a={...m.props};if(m.compiledExpressionMap)for(const [p,k]of m.compiledExpressionMap){const d=k.computed.readWithDefault(e,f,k.defaultValue);a[p]="number"===typeof d||"boolean"===typeof d?d:k.defaultValue}h.infos.push(a)}this._resolvedMeshParams[l]=h}for(const [l,g]of this._dynamicAsyncProperties.entries())f=g.objectIdToResourceId.get(e.getObjectId()),
null!=f&&(f=c.getResource(f),this._resolvedMeshParams[l]=f);this._evaluatedMeshParams=this.evaluator(this._resolvedMeshParams);return this.evaluatedMeshParams}}w.MeshWriterInputEvaluator=z;Object.defineProperty(w,Symbol.toStringTag,{value:"Module"})});