// All material copyright Esri, All Rights Reserved, unless otherwise specified.
// See https://js.arcgis.com/4.30/esri/copyright.txt for details.
//>>built
define("exports ../../core/Cyclical ../../core/quantityUtils ../../core/unitUtils ../../core/libs/gl-matrix-2/math/vec2 ../../core/libs/gl-matrix-2/factories/vec2f64 ../../chunks/vec32 ../../core/libs/gl-matrix-2/factories/vec3f64 ../../geometry/projection/projectVectorToVector ../../geometry/support/geodesicUtils ../../geometry/support/spatialReferenceUtils".split(" "),function(e,x,f,l,E,y,n,p,r,m,F){function z(a,c){if(null!=a&&null!=c)return a=u(a,c),null!=a?f.createAngle(a,"radians","geographic"):
void 0}function A(a,c,d){if(a&&c&&d&&(a=u(a,c),c=u(c,d),null!=a&&null!=c))return f.createAngle(c-a,"radians","geographic")}function v(a,c){if(null!=a)switch(c){case e.DirectionMode.Absolute:return B(a);case e.DirectionMode.Relative:return a=q(a),a=C.normalize(a,0,!0),-180===a&&(a=180),f.createAngle(a,"degrees","geographic");case e.DirectionMode.RelativeBilateral:return a=q(a),a=Math.abs(C.normalize(a,0,!0)),f.createAngle(a,"degrees","geographic")}}function B(a){a=q(a);a=G.normalize(a,0,!0);return f.createAngle(a,
"degrees","geographic")}function q(a){if(null!=a)return f.convertRotationType(l.convertUnit(a.value,a.unit,"degrees"),a.rotationType,"geographic")}e.DirectionMode=void 0;(function(a){a.Absolute="absolute";a.Relative="relative";a.RelativeBilateral="relative-bilateral"})(e.DirectionMode||(e.DirectionMode={}));const u=(()=>{const a=p.create(),c=p.create();return(d,b)=>{n.set(a,d.x,d.y,d.z??0);n.set(c,b.x,b.y,b.z??0);return D(a,c,d.spatialReference,b.spatialReference)}})(),D=(()=>{const a=y.create(),
c=p.create(),d=p.create();return(b,g,k,h)=>{if(!n.exactEquals(b,g)){var t=m.geodesicCompatibleSpatialReference(k),w=m.geodesicCompatibleSpatialReference(h);if(t&&w&&F.equals(t,w)&&r.projectVectorToVector(b,k,c,t)&&r.projectVectorToVector(g,h,d,w))return{azimuth:b}=m.inverseGeodeticSolver(H,c,d,t),null!=b?l.convertUnit(b,"degrees","radians"):void 0;a[0]=g[0]-b[0];a[1]=g[1]-b[1];b=E.angle(y.UNIT_Y,a);0>a[0]&&(b=I-b);return b}}})(),J=(()=>{const a=p.create();return(c,d,b,g,k,h="geodesic")=>{n.copy(a,
d);k=q(k);if("geodesic"===h&&(h=m.geodesicCompatibleSpatialReference(b))&&r.projectVectorToVector(a,b,a,h))return m.directGeodeticSolver(c,a,k,g,h),c[2]=d[2],r.projectVectorToVector(c,h,c,b)?!0:!1;b=f.convertRotationType(k,"geographic","arithmetic");b=l.convertUnit(b,"degrees","radians");n.set(c,d[0]+g*Math.cos(b),d[1]+g*Math.sin(b),d[2]);return!0}})(),H=new m.InverseGeodeticSolverResult,I=2*Math.PI,G=x.cyclicalDegrees,C=new x.Cyclical(-180,180);e.convertAngle=function(a,c,d){let b=l.convertUnit(a.value,
a.unit,"degrees");b=f.convertRotationType(b,a.rotationType,d);b=l.convertUnit(b,"degrees",c);return f.createAngle(b,c,d)};e.directionBetweenPoints=z;e.directionForVertices=function(a,c,d,b=e.DirectionMode.Absolute){if(c&&d)switch(b){case e.DirectionMode.Absolute:return z(c,d);case e.DirectionMode.Relative:return v(A(a,c,d),e.DirectionMode.Relative);case e.DirectionMode.RelativeBilateral:return v(A(a,c,d),e.DirectionMode.RelativeBilateral)}};e.getDegreesArithmetic=function(a){if(null!=a)return f.convertRotationType(l.convertUnit(a.value,
a.unit,"degrees"),a.rotationType,"arithmetic")};e.getDegreesGeographic=q;e.getNormalizedDirection=v;e.getNormalizedGeographicOrientation=B;e.pointFromDistanceAlongAzimuth=J;e.radiansGeographicBetweenVec=D;Object.defineProperty(e,Symbol.toStringTag,{value:"Module"})});