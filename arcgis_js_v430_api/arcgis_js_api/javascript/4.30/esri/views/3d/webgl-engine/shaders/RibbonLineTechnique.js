// All material copyright Esri, All Rights Reserved, unless otherwise specified.
// See https://js.arcgis.com/4.30/esri/copyright.txt for details.
//>>built
define("require exports ../core/shaderLibrary/ShaderOutput ../core/shaderTechnique/ReloadableShaderModule ../core/shaderTechnique/ShaderTechnique ../lib/OrderIndependentTransparency ../lib/Program ../lib/StencilUtils ../lib/TransparencyPassType ../lib/VertexAttribute ../../../../chunks/RibbonLine.glsl ../../../webgl/enums ../../../webgl/renderState".split(" "),function(t,l,h,u,v,f,w,b,p,c,x,k,g){const q=new Map([[c.VertexAttribute.POSITION,0],[c.VertexAttribute.PREVPOSITION,1],[c.VertexAttribute.NEXTPOSITION,
2],[c.VertexAttribute.SUBDIVISIONFACTOR,3],[c.VertexAttribute.UV0,4],[c.VertexAttribute.COLOR,5],[c.VertexAttribute.COLORFEATUREATTRIBUTE,5],[c.VertexAttribute.SIZE,6],[c.VertexAttribute.SIZEFEATUREATTRIBUTE,6],[c.VertexAttribute.OPACITYFEATUREATTRIBUTE,7],[c.VertexAttribute.OBJECTANDLAYERIDCOLOR,8]]);class m extends v.ShaderTechnique{initializeProgram(a){return new w.Program(a.rctx,m.shader.get().build(this.configuration),q)}_makePipelineState(a,d){const e=this.configuration,n=a===p.TransparencyPassType.NONE,
y=a===p.TransparencyPassType.FrontFace,z=h.isDepthLikeOutput(e.output);return g.makePipelineState({blending:e.output===h.ShaderOutput.Color?n?f.blendingDefault:f.oitBlending(a):null,depthTest:{func:f.oitDepthTest(a)},depthWrite:n?e.writeDepth||z?g.defaultDepthWriteParams:null:f.oitDepthWrite(a),drawBuffers:e.output===h.ShaderOutput.Depth?{buffers:[k.SpecialDrawBuffers.NONE]}:f.oitDrawBuffers(a),colorWrite:g.defaultColorWriteParams,stencilWrite:e.hasOccludees?b.stencilWriteMaskOn:null,stencilTest:e.hasOccludees?
d?b.stencilToolMaskBaseParams:b.stencilBaseAllZerosParams:null,polygonOffset:n||y?e.hasPolygonOffset?r:null:f.OITPolygonOffset})}initializePipeline(){const a=this.configuration;if(a.occluder){const d=a.hasPolygonOffset?r:null;this._occluderPipelineTransparent=g.makePipelineState({blending:f.blendingDefault,polygonOffset:d,depthTest:b.depthCompareAlways,depthWrite:null,colorWrite:g.defaultColorWriteParams,stencilWrite:null,stencilTest:b.stencilToolTransparentOccluderParams,drawBuffers:a.output===h.ShaderOutput.Depth?
{buffers:[k.SpecialDrawBuffers.NONE]}:null});this._occluderPipelineOpaque=g.makePipelineState({blending:f.blendingDefault,polygonOffset:d,depthTest:b.depthCompareAlways,depthWrite:null,colorWrite:g.defaultColorWriteParams,stencilWrite:b.stencilWriteMaskOff,stencilTest:b.stencilToolMaskOccluderParams,drawBuffers:a.output===h.ShaderOutput.Depth?{buffers:[k.SpecialDrawBuffers.NONE]}:null});this._occluderPipelineMaskWrite=g.makePipelineState({blending:null,polygonOffset:d,depthTest:b.depthCompareLess,
depthWrite:null,colorWrite:null,stencilWrite:b.stencilWriteMaskOn,stencilTest:b.stencilToolMaskBaseParams,drawBuffers:a.output===h.ShaderOutput.Depth?{buffers:[k.SpecialDrawBuffers.NONE]}:null})}this._occludeePipelineState=this._makePipelineState(this.configuration.transparencyPassType,!0);return this._makePipelineState(this.configuration.transparencyPassType,!1)}get primitiveType(){return this.configuration.wireframe?k.PrimitiveType.LINES:k.PrimitiveType.TRIANGLE_STRIP}getPipeline(a,d,e){return a?
this._occludeePipelineState:this.configuration.occluder?e?this._occluderPipelineTransparent:d?this._occluderPipelineOpaque:this._occluderPipelineMaskWrite:super.getPipeline()}}m.shader=new u.ReloadableShaderModule(x.RibbonLine,()=>new Promise((a,d)=>t(["./RibbonLine.glsl"],a,d)));const r={factor:0,units:-4};l.RibbonLineTechnique=m;l.vertexAttributeLocations=q;Object.defineProperty(l,Symbol.toStringTag,{value:"Module"})});