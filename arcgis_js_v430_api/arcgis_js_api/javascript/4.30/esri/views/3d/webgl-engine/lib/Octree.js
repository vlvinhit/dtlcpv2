// All material copyright Esri, All Rights Reserved, unless otherwise specified.
// See https://js.arcgis.com/4.30/esri/copyright.txt for details.
//>>built
define("../../../../core/ObjectPool ../../../../core/PooledArray ../../../../chunks/vec32 ../../../../core/libs/gl-matrix-2/factories/vec3f64 ../../../../geometry/support/frustum ../../../../geometry/support/ray ../../../../chunks/sphere ./Util".split(" "),function(ba,E,w,m,I,S,g,T){function B(a,b){a=l.acquire().init(a);const c=[a];for(;0!==c.length;){a=c.pop();if(b(a)&&!a.isLeaf())for(let d=0;d<a.node.children.length;d++)a.node.children[d]&&c.push(l.acquire().init(a).advance(d));l.release(a)}}function U(a,
b,c,d=F.DepthOrder.FRONT_TO_BACK){a=l.acquire().init(a);const f=[a];for(ca(c,d,V);0!==f.length;){a=f.pop();if(b(a)&&!a.isLeaf())for(c=7;0<=c;--c)d=V[c],a.node.children[d]&&f.push(l.acquire().init(a).advance(d));l.release(a)}}function da(a,b,c){C.clear();b=c.advanceTo(b,(d,f)=>{C.push(d.node);C.push(f)})?c.node.terminals:c.node.residents;b.removeUnordered(a);if(0===b.length)for(a=C.length-2;0<=a&&ea(C.data[a],C.data[a+1]);a-=2);}function ea(a,b){0<=b&&(a.children[b]=null);return W(a)?(null===a.residents&&
(a.residents=new E({shrink:!0})),!0):!1}function fa(a,b){J(g.getCenter(b.bounds),2*-b.halfSize,r);J(g.getCenter(b.bounds),2*b.halfSize,t);return T.rayBoxTest(a.origin,a.direction,r,t)}function ha(a,b,c){J(g.getCenter(b.bounds),2*-b.halfSize,r);J(g.getCenter(b.bounds),2*b.halfSize,t);c.applyToMinMax(r,t);return T.rayBoxTest(a.origin,a.direction,r,t)}function W(a){if(0!==a.terminals.length)return!1;if(null!==a.residents)return 0===a.residents.length;for(let b=0;b<a.children.length;b++)if(a.children[b])return!1;
return!0}function J(a,b,c){c[0]=a[0]+b;c[1]=a[1]+b;c[2]=a[2]+b}function X(a,b,c,d){if(1===b)a=c(a[0]),g.copy(a,d);else{r[0]=Infinity;r[1]=Infinity;r[2]=Infinity;t[0]=-Infinity;t[1]=-Infinity;t[2]=-Infinity;for(let h=0;h<b;h++){var f=c(a[h]);if(G(f[3])){var e=r,k=f;e[0]=Math.min(e[0],k[0]-k[3]);e[1]=Math.min(e[1],k[1]-k[3]);e[2]=Math.min(e[2],k[2]-k[3]);e=t;e[0]=Math.max(e[0],f[0]+f[3]);e[1]=Math.max(e[1],f[1]+f[3]);e[2]=Math.max(e[2],f[2]+f[3])}}w.lerp(g.getCenter(d),r,t,.5);d[3]=Math.max(t[0]-r[0],
t[1]-r[1],t[2]-r[2])/2}}function ca(a,b,c){if(!D.length)for(var d=0;8>d;++d)D.push({index:0,distance:0});for(d=0;8>d;++d){const f=Y[d];D.data[d].index=d;D.data[d].distance=z(a,b,f)}D.sort((f,e)=>f.distance-e.distance);for(a=0;8>a;++a)c[a]=D.data[a].index}function N(a,b){let c=Infinity,d;for(let f=0;8>f;++f){const e=z(a,b,Z[f]);e<c&&(c=e,d=Z[f])}return d}function z(a,b,c){return b*(a[0]*c[0]+a[1]*c[1]+a[2]*c[2])}function G(a){return!isNaN(a)&&-Infinity!==a&&Infinity!==a&&0<a}class F{get bounds(){return this._root.bounds}get halfSize(){return this._root.halfSize}get root(){return this._root.node}get maximumObjectsPerNode(){return this._maximumObjectsPerNode}get maximumDepth(){return this._maximumDepth}get objectCount(){return this._objectCount}constructor(a,
b){this.objectToBoundingSphere=a;this._maximumObjectsPerNode=10;this._maximumDepth=20;this._degenerateObjects=new Set;this._root=new l;this._objectCount=0;b&&(void 0!==b.maximumObjectsPerNode&&(this._maximumObjectsPerNode=b.maximumObjectsPerNode),void 0!==b.maximumDepth&&(this._maximumDepth=b.maximumDepth))}destroy(){this._degenerateObjects.clear();l.clearPool();O[0]=null;C.prune();D.prune()}add(a,b=a.length){this._objectCount+=b;this._grow(a,b);const c=l.acquire();for(let d=0;d<b;d++){const f=a[d];
this._isDegenerate(f)?this._degenerateObjects.add(f):(c.init(this._root),this._add(f,c))}l.release(c)}remove(a,b=null){this._objectCount-=a.length;const c=l.acquire();for(const d of a)a=b??g.copy(this.objectToBoundingSphere(d),ia),G(a[3])?(c.init(this._root),da(d,a,c)):this._degenerateObjects.delete(d);l.release(c);this._shrink()}update(a,b){if(G(b[3])||!this._isDegenerate(a))O[0]=a,a=O,this.remove(a,b),this.add(a)}forEachAlongRay(a,b,c){const d=S.wrap(a,b);B(this._root,f=>{if(!fa(d,f))return!1;f=
f.node;f.terminals.forAll(e=>{this._intersectsObject(d,e)&&c(e)});null!==f.residents&&f.residents.forAll(e=>{this._intersectsObject(d,e)&&c(e)});return!0})}forEachAlongRayWithVerticalOffset(a,b,c,d){const f=S.wrap(a,b);B(this._root,e=>{if(!ha(f,e,d))return!1;e=e.node;e.terminals.forAll(k=>{this._intersectsObjectWithOffset(f,k,d)&&c(k)});null!==e.residents&&e.residents.forAll(k=>{this._intersectsObjectWithOffset(f,k,d)&&c(k)});return!0})}forEach(a){B(this._root,b=>{b=b.node;b.terminals.forAll(a);null!==
b.residents&&b.residents.forAll(a);return!0});this._degenerateObjects.forEach(a)}forEachDegenerateObject(a){this._degenerateObjects.forEach(a)}findClosest(a,b,c,d=()=>!0,f=Infinity){let e=Infinity,k=Infinity,h=null;const p=N(a,b),x=q=>{--f;if(d(q)){var u=this.objectToBoundingSphere(q);if(I.intersectsSphere(c,u)){var K=z(a,b,g.getCenter(u)),H=K-u[3];u=K+u[3];H<e&&(e=H,k=u,h=q)}}};U(this._root,q=>{if(0>=f||!I.intersectsSphere(c,q.bounds))return!1;w.scale(v,p,q.halfSize);w.add(v,v,g.getCenter(q.bounds));
if(z(a,b,v)>k)return!1;q=q.node;q.terminals.forAll(u=>x(u));null!==q.residents&&q.residents.forAll(u=>x(u));return!0},a,b);return h}forEachInDepthRange(a,b,c,d,f,e,k){let h=-Infinity,p=Infinity;const x={setRange:n=>{c===F.DepthOrder.FRONT_TO_BACK?(h=Math.max(h,n.near),p=Math.min(p,n.far)):(h=Math.max(h,-n.far),p=Math.min(p,-n.near))}};x.setRange(d);const q=z(b,c,a),u=N(b,c),K=N(b,-c),H=n=>{if(k(n)){var A=this.objectToBoundingSphere(n),L=g.getCenter(A);L=z(b,c,L)-q;var ja=L+A[3];L-A[3]>p||ja<h||!I.intersectsSphere(e,
A)||f(n,x)}};U(this._root,n=>{if(!I.intersectsSphere(e,n.bounds))return!1;w.scale(v,u,n.halfSize);w.add(v,v,g.getCenter(n.bounds));if(z(b,c,v)-q>p)return!1;w.scale(v,K,n.halfSize);w.add(v,v,g.getCenter(n.bounds));if(z(b,c,v)-q<h)return!1;n=n.node;n.terminals.forAll(A=>H(A));null!==n.residents&&n.residents.forAll(A=>H(A));return!0},b,c)}forEachNode(a){B(this._root,b=>a(b.node,b.bounds,b.halfSize,b.depth))}forEachNeighbor(a,b){const c=g.getRadius(b),d=g.getCenter(b),f=h=>{const p=this.objectToBoundingSphere(h);
var x=g.getRadius(p);x=c+x;return 0>=w.squaredDistance(g.getCenter(p),d)-x*x?a(h):!0};let e=!0;const k=h=>{e&&=f(h)};B(this._root,h=>{var p=g.getRadius(h.bounds);p=c+p;if(0<w.squaredDistance(g.getCenter(h.bounds),d)-p*p)return!1;h=h.node;h.terminals.forAll(k);e&&null!==h.residents&&h.residents.forAll(k);return e});e&&this.forEachDegenerateObject(k)}_intersectsObject(a,b){b=this.objectToBoundingSphere(b);return 0<b[3]?g.intersectsRay(b,a):!0}_intersectsObjectWithOffset(a,b,c){b=this.objectToBoundingSphere(b);
return 0<b[3]?g.intersectsRay(c.applyToBoundingSphere(b),a):!0}_add(a,b){b.advanceTo(this.objectToBoundingSphere(a))?b.node.terminals.push(a):(b.node.residents.push(a),b.node.residents.length>this._maximumObjectsPerNode&&b.depth<this._maximumDepth&&this._split(b))}_split(a){const b=a.node.residents;a.node.residents=null;for(let c=0;c<b.length;c++){const d=l.acquire().init(a);this._add(b.at(c),d);l.release(d)}}_grow(a,b){0!==b&&(X(a,b,c=>this.objectToBoundingSphere(c),y),G(y[3])&&!this._fitsInsideTree(y)&&
(W(this._root.node)?(g.copy(y,this._root.bounds),this._root.halfSize=1.25*this._root.bounds[3],this._root.updateBoundsRadiusFromHalfSize()):(a=this._rootBoundsForRootAsSubNode(y),this._placingRootViolatesMaxDepth(a)?this._rebuildTree(y,a):this._growRootAsSubNode(a),l.release(a))))}_rebuildTree(a,b){w.copy(g.getCenter(P),g.getCenter(b.bounds));P[3]=b.halfSize;X([a,P],2,c=>c,Q);a=l.acquire().init(this._root);this._root.initFrom(null,Q,Q[3]);this._root.increaseHalfSize(1.25);B(a,c=>{this.add(c.node.terminals.data,
c.node.terminals.length);null!==c.node.residents&&this.add(c.node.residents.data,c.node.residents.length);return!0});l.release(a)}_placingRootViolatesMaxDepth(a){const b=Math.log(a.halfSize/this._root.halfSize)*Math.LOG2E;let c=0;B(this._root,d=>{c=Math.max(c,d.depth);return c+b<=this._maximumDepth});return c+b>this._maximumDepth}_rootBoundsForRootAsSubNode(a){var b=a[3],c=-Infinity;const d=this._root.bounds,f=this._root.halfSize;for(var e=0;3>e;e++){var k=Math.max(0,Math.ceil((d[e]-f-(a[e]-b))/(2*
f)));const h=Math.max(0,Math.ceil((a[e]+b-(d[e]+f))/(2*f)))+1;c=Math.max(c,2**Math.ceil(Math.log(k+h)*Math.LOG2E));M[e].min=k;M[e].max=h}for(a=0;3>a;a++)b=M[a].min,e=M[a].max,k=(c-(b+e))/2,b+=Math.ceil(k),e+=Math.floor(k),R[a]=d[a]-f-b*f*2+(e+b)*f;c*=f;R[3]=c*aa;return l.acquire().initFrom(null,R,c,0)}_growRootAsSubNode(a){const b=this._root.node;w.copy(g.getCenter(y),g.getCenter(this._root.bounds));y[3]=this._root.halfSize;this._root.init(a);a.advanceTo(y,null,!0);a.node.children=b.children;a.node.residents=
b.residents;a.node.terminals=b.terminals}_shrink(){for(;;){const a=this._findShrinkIndex();if(-1===a)break;this._root.advance(a);this._root.depth=0}}_findShrinkIndex(){if(0!==this._root.node.terminals.length||this._root.isLeaf())return-1;let a=null;const b=this._root.node.children;let c=0,d=0;for(;d<b.length&&null==a;)c=d++,a=b[c];for(;d<b.length;)if(b[d++])return-1;return c}_isDegenerate(a){a=this.objectToBoundingSphere(a)[3];return!G(a)}_fitsInsideTree(a){const b=this._root.bounds,c=this._root.halfSize;
return a[3]<=c&&a[0]>=b[0]-c&&a[0]<=b[0]+c&&a[1]>=b[1]-c&&a[1]<=b[1]+c&&a[2]>=b[2]-c&&a[2]<=b[2]+c}toJSON(){const {maximumDepth:a,maximumObjectsPerNode:b,_objectCount:c}=this,d=this._nodeToJSON(this._root.node);return{maximumDepth:a,maximumObjectsPerNode:b,objectCount:c,root:{bounds:this._root.bounds,halfSize:this._root.halfSize,depth:this._root.depth,node:d}}}_nodeToJSON(a){const b=a.children.map(d=>d?this._nodeToJSON(d):null),c=a.residents?.map(d=>this.objectToBoundingSphere(d));a=a.terminals?.map(d=>
this.objectToBoundingSphere(d));return{children:b,residents:c,terminals:a}}static fromJSON(a){const b=new F(c=>c,{maximumDepth:a.maximumDepth,maximumObjectsPerNode:a.maximumObjectsPerNode});b._objectCount=a.objectCount;b._root.initFrom(a.root.node,a.root.bounds,a.root.halfSize,a.root.depth);return b}}class l{constructor(){this.bounds=g.create();this.halfSize=0;this.initFrom(null,null,0,0)}init(a){return this.initFrom(a.node,a.bounds,a.halfSize,a.depth)}initFrom(a,b,c,d=this.depth){this.node=null!=
a?a:l.createEmptyNode();b&&g.copy(b,this.bounds);this.halfSize=c;this.depth=d;return this}increaseHalfSize(a){this.halfSize*=a;this.updateBoundsRadiusFromHalfSize()}updateBoundsRadiusFromHalfSize(){this.bounds[3]=this.halfSize*aa}advance(a){let b=this.node.children[a];b||(b=l.createEmptyNode(),this.node.children[a]=b);this.node=b;this.halfSize/=2;this.depth++;a=Y[a];this.bounds[0]+=a[0]*this.halfSize;this.bounds[1]+=a[1]*this.halfSize;this.bounds[2]+=a[2]*this.halfSize;this.updateBoundsRadiusFromHalfSize();
return this}advanceTo(a,b,c=!1){for(;;){if(this.isTerminalFor(a))return b&&b(this,-1),!0;if(this.isLeaf()){if(!c)return b&&b(this,-1),!1;this.node.residents=null}const d=this._childIndex(a);b&&b(this,d);this.advance(d)}}isLeaf(){return null!=this.node.residents}isTerminalFor(a){return a[3]>this.halfSize/2}_childIndex(a){const b=this.bounds;return(b[0]<a[0]?1:0)+(b[1]<a[1]?2:0)+(b[2]<a[2]?4:0)}static createEmptyNode(){return{children:[null,null,null,null,null,null,null,null],terminals:new E({shrink:!0}),
residents:new E({shrink:!0})}}static acquire(){return l._pool.acquire()}static release(a){l._pool.release(a)}static clearPool(){l._pool.prune()}}l._pool=new ba(l);(function(a){a=a.DepthOrder||(a.DepthOrder={});a[a.FRONT_TO_BACK=1]="FRONT_TO_BACK";a[a.BACK_TO_FRONT=-1]="BACK_TO_FRONT"})(F||={});const Y=[m.fromValues(-1,-1,-1),m.fromValues(1,-1,-1),m.fromValues(-1,1,-1),m.fromValues(1,1,-1),m.fromValues(-1,-1,1),m.fromValues(1,-1,1),m.fromValues(-1,1,1),m.fromValues(1,1,1)],Z=[m.fromValues(-1,-1,-1),
m.fromValues(-1,-1,1),m.fromValues(-1,1,-1),m.fromValues(-1,1,1),m.fromValues(1,-1,-1),m.fromValues(1,-1,1),m.fromValues(1,1,-1),m.fromValues(1,1,1)],aa=Math.sqrt(3),O=[null],R=g.create(),v=m.create(),r=m.create(),t=m.create(),C=new E,ia=g.create(),y=g.create(),P=g.create(),Q=g.create(),M=[{min:0,max:0},{min:0,max:0},{min:0,max:0}],D=new E,V=[0,0,0,0,0,0,0,0];return F});