// All material copyright Esri, All Rights Reserved, unless otherwise specified.
// See https://js.arcgis.com/4.30/esri/copyright.txt for details.
//>>built
define("exports ../../../core/mathUtils ../../../chunks/vec32 ../../../core/libs/gl-matrix-2/factories/vec3f64 ../../../geometry/projection/lonLatToSphericalPCPF ../../../geometry/support/DoubleArray ../../../geometry/support/frustum ../../../chunks/sphere ./interfaces ./PatchGeometryFactory ./terrainUtils ./Tile ./TileFrustumVisibility ./tileUtils".split(" "),function(ca,da,g,p,qa,ra,aa,T,P,X,y,M,U,sa){function ea(c,a,e,d,b,f){c=d-c;a=b-a;e=f-e;return c*c+a*a+e*e}class ta extends M.Tile{constructor(c,
a,e,d,b){super();this._convexHull=Array(24);this._boundingSphere=T.create();this._baseUsedMemory=1816;this.init(c,a,e,d,b)}init(c,a,e,d,b){super.init(c,a,e,d,b);a=this.ellipsoid.radius;e=this.extentInRadians[0];d=this.extentInRadians[1];b=this.extentInRadians[2];const f=this.extentInRadians[3],k=da.lerp(d,f,.5),t=da.lerp(e,b,.5);this._edgeLen=(b-e)*Math.cos(0===c?0:Math.min(Math.abs(d),Math.abs(f)))*a;this._edgeLen2=this._edgeLen*this._edgeLen;this._curvatureHeight=a-Math.sqrt(a*a-this._edgeLen2/
4);qa.lonLatToSphericalPCPF(this.centerAtSeaLevel,t,k,this.ellipsoid.radius);g.normalize(this.up,this.centerAtSeaLevel);this.updateRadiusAndCenter()}updateRadiusAndCenter(){this._updateBoundingVolumes();const c=this._center;if(0===this.lij[0])g.set(T.getCenter(c[M.CenterPosition.MIDDLE]),0,0,0),g.set(c[M.CenterPosition.TOP],0,0,0),g.set(c[M.CenterPosition.BOTTOM],0,0,0),c[M.CenterPosition.MIDDLE][3]=this.ellipsoid.radius+this.elevationBoundsMax;else{this._updateCenter();const k=c[M.CenterPosition.MIDDLE],
t=this.convexHull;var a=0;for(let n=0;8>n;++n){var e=Math,d=e.max;var b=T.getCenter(k);var f=3*n;b=ea(b[0],b[1],b[2],t[f],t[f+1],t[f+2]);a=d.call(e,a,b)}c[M.CenterPosition.MIDDLE][3]=Math.sqrt(a)}}_calculateFrustumVisibilityStatus(c){if(!aa.intersectsSphere(c,this._boundingSphere))return U.TileFrustumVisibility.OUTSIDE;if(10>this.lij[0])return U.TileFrustumVisibility.INTERSECTS;const a=this.convexHull,e=this.surface.view.state.camera.near;let d=!0;for(let f=0;f<aa.numPlanes;f++){var b=c[f];const k=
b[0],t=b[1],n=b[2];b=b[3]-(f===aa.PlaneIndex.NEAR?e:0);let z=!1;for(let D=0;8>D;++D){const G=3*D;if(0>k*a[G]+t*a[G+1]+n*a[G+2]+b){if(z=!0,!d)break}else d=!1}if(!z)return U.TileFrustumVisibility.OUTSIDE}return d?U.TileFrustumVisibility.INSIDE:U.TileFrustumVisibility.INTERSECTS}computeElevationBounds(){super.computeElevationBounds();this._updateBoundingVolumes()}createGeometry(){X.createSphericalGlobePatch(this.renderData,this._getPatchType());this._updateBoundingVolumes();this.setMemoryDirty()}_updateBoundingVolumes(){this._updateConvexHull();
this._updateBoundingSphere();y.enableTerrainInternalChecks&&this._checkBVs()}_updateBoundingSphere(){const c=this._boundingSphere,a=T.getCenter(c);var e=this.elevationBoundsMin,d=this.elevationBoundsMax,b=this.ellipsoid.radius;if(0===this.level)g.set(a,0,0,0),c[3]=b+d;else{var f=this.extentInRadians,k=.5*(f[0]+f[2]),t=f[3];J(fa,k,f[1],b);J(ha,k,t,b);g.add(a,fa,ha);g.scale(a,a,(b+.5*(e+d))/g.len(a));e=this.convexHull;d=0;for(b=0;8>b;++b)f=a[0]-e[3*b],k=a[1]-e[3*b+1],t=a[2]-e[3*b+2],d=Math.max(d,Math.sqrt(f*
f+k*k+t*t));c[3]=d+2}}_updateConvexHull(){var c=this.extentInRadians,a=this.ellipsoid.radius;if(0!==this.level){var e=this.elevationBoundsMin,d=this.elevationBoundsMax,b=this._getPatchType(),f=this.surface.isWebMercator,k=f&&b===P.PatchType.HAS_NORTH_POLE,t=(b=f&&b===P.PatchType.HAS_SOUTH_POLE)||k;f=Math.PI/2;var n=c[0],z=c[2];b=b?-f:c[1];var D=k?f:c[3],G=.5*(n+z),H=a+(t?Math.min(0,e-1):e);e=p.create();c=p.create();k=p.create();f=p.create();J(e,n,b,H);J(c,n,D,H);J(k,z,D,H);J(f,z,b,H);n=(x,A)=>{for(let E=
0;3>E;++E)this._convexHull[3*A+E]=x[E]};n(e,0);n(c,1);n(k,2);n(f,3);var Q=a+(t?Math.max(0,d+1):d),O=p.create();a=p.create();d=p.create();J(a,G,D,H);J(d,G,b,H);g.add(O,a,d);g.normalize(O,O);var h=p.create(),B=p.create();b=(x,A)=>{g.sub(B,x,A);g.normalize(B,B);A=-g.dot(x,h)/g.dot(B,h);y.internalAssert(0<=A);g.scale(B,B,A);g.add(x,x,B)};2**this.lij[0]>2*this.lij[1]?(a=p.create(),g.cross(a,ia,d),g.normalize(a,a),g.cross(h,d,a),g.normalize(h,h),y.internalAssert(y.almostEquals(g.dot(h,d)/g.len(d),0)),b(e,
c),b(f,k),n(e,0),n(f,3)):2**this.lij[0]!==2*this.lij[1]&&(d=p.create(),g.cross(d,ia,a),g.normalize(d,d),g.cross(h,d,a),g.normalize(h,h),b(c,e),b(k,f),n(c,1),n(k,2));a=(x,A)=>{const E=Q/g.dot(A,O);for(let K=0;3>K;++K)this._convexHull[3*x+K]=A[K]*E};a(4,e);a(5,c);a(6,k);a(7,f)}}_getPatchType(){const c=this.lij[1],a=c===(1<<this.level)-1;return 0===c?a?P.PatchType.HAS_BOTH_POLES:P.PatchType.HAS_NORTH_POLE:a?P.PatchType.HAS_SOUTH_POLE:P.PatchType.REGULAR}intersectsRay(c,a,e,d){var b=this._boundingSphere;
e=b[3]+e;var f=b[0]-c[0];d=b[1]-c[1];c=b[2]-c[2];b=(f*a[0]+d*a[1]+c*a[2])/(a[0]*a[0]+a[1]*a[1]+a[2]*a[2]);f=a[0]*b-f;d=a[1]*b-d;a=a[2]*b-c;return f*f+d*d+a*a<e*e}getDefaultVerticesPerSide(){return this.level<ja.length?ja[this.level]+1:2}updateCornerElevations(){X.updateCornerSpherical(this.renderData);this._updateBoundingVolumes()}updateEdgeElevations(){X.updateEdgesAndCornersSpherical(this.renderData);this._updateBoundingVolumes()}updateEdgeElevationsAndResolutions(){X.updateEdgeElevationsAndResolutionsSpherical(this.renderData);
this._updateBoundingVolumes()}_checkBVs(){if(y.enableTerrainInternalChecks&&!(2>=this.level)){var c=this._boundingSphere,a=c[3],e=T.getCenter(c);c=p.create();var d=this.ellipsoid.radius,b=this.elevationBoundsMin,f=this.elevationBoundsMax,k=d+b,t=this._center[M.CenterPosition.MIDDLE][3],n=this.convexHull,z=(m,v)=>{for(let q=0;3>q;++q)m[q]=n[3*v+q]},D=p.create(),G=p.create(),H=p.create(),Q=p.create(),O=p.create(),h=(m,v,q,F)=>{z(G,m);z(H,v);z(Q,q);g.sub(G,G,H);g.sub(Q,Q,H);g.cross(D,G,Q);g.normalize(D,
D);var R=g.dot(D,H);z(O,F);const Y=g.dot(D,O);R=Math.abs(Y-R);y.internalAssert(y.almostEquals(R,0),`Non coplanar ${m},${v},${q},${F} diff = ${R}`)};h(0,1,2,3);h(4,5,6,7);h(0,1,4,5);h(1,2,5,6);h(2,3,6,7);h(3,0,7,4);var B=ra.newDoubleArray(24),x=p.create(),A=p.create(),E=p.create(),K=p.create();h=(m,v,q,F)=>{z(x,v);z(A,q);z(E,F);g.sub(x,x,A);g.normalize(x,x);g.sub(E,E,A);g.normalize(E,E);g.cross(K,x,E);g.normalize(K,K);v=g.dot(K,A);m*=4;for(q=0;3>q;++q)B[m+q]=K[q];B[m+3]=v};h(0,0,1,2);h(1,1,0,4);h(2,
1,5,2);h(3,3,2,6);h(4,4,0,3);h(5,4,6,5);var V=(m,v,q,F)=>{m*=4;return B[m]*v+B[m+1]*q+B[m+2]*F-B[m+3]},u=(m,v,q,F)=>-1<=V(m,v,q,F),N=2**this.lij[0]>2*this.lij[1];h=(m,v,q)=>Math.sqrt(ea(m,v,q,e[0],e[1],e[2]))<a;var l=this.extentInRadians,r=.5*(l[0]+l[2]),C=l[1],w=l[3];l=p.create();var I=p.create();J(l,r,w,k);J(I,r,C,k);k=N?"Upper":"Lower";N=!0;for(r=0;6>r;++r){for(C=0;8>C;++C)w=3*C,w=-1<=V(r,n[w],n[w+1],n[w+2]),N&&=w,y.internalAssert(w,`Tile[${this.lij}] Convex hull point ${C} outside of plane ${r}`);
y.internalAssert(u(r,I[0],I[1],I[2]),`Tile[${this.lij}] (${k}) bottom mid outside of plane ${r}`);y.internalAssert(u(r,l[0],l[1],l[2]),`Tile[${this.lij}] (${k}) top mid outside of plane ${r}`)}y.internalAssert(N,"Not all convex hull points are inside  convex hull polyhedron");y.internalAssert(h(I[0],I[1],I[2]),`Tile[${this.lij}] (${k}) bottom mid outside of bounding sphere`);y.internalAssert(h(l[0],l[1],l[2]),`Tile[${this.lij}] (${k}) top mid outside of bounding sphere`);for(u=0;8>u;++u)l=3*u,l=h(n[l],
n[l+1],n[l+2]),y.internalAssert(l,`Tile[${this.lij}] Convex hull point ${u} outside of bounding sphere`);for(h=0;6>h;++h)for(u=0;8>u;++u)l=3*u,-1<=V(h,n[l],n[l+1],n[l+2])||console.error(`Tile[${this.lij}] Convex hull point ${u} outside of plane ${h}`);({extentInRadians:h}=this);h=Math.round(Math.max(h[2]-h[0],h[3]-h[1])*d);({renderData:u}=this);if(u){var {geometry:ba,geometryState:ka,localOrigin:ua}=u;if(u=ba.vertexAttributes?.position){l=p.create();I=ba.numVerticesPerSide-2;var {indices:la,indexCount:va,
edgeVerticesStartIndex:ma,poleVerticesStartIndex:wa}=ba;if(la)for(k=new Set,N=0;N<va;++N){const m=la[N];if(k.has(m))continue;k.add(m);const v=m<wa,q=m>=ma;let F=!1;r=-1;if(q)for(C=ma,w=0;4>w;++w){var W=ka.edgeResolutions[w];if(m===C||m===C+W-1){F=!0;break}C+=W;if(m<C){r=w;break}}r=q?ka.edgePeerNeighbors[r]:null;const R=q&&r&&0<sa.compareTilesByLij(this,r);u.getVec(m,c);g.add(l,c,ua);r=g.len(l)-d;C=0;w=!1;W=b-r;const Y=r-f,na=1<W,oa=1<Y;var L=na||oa;const pa=()=>{const Z=q&&!F;return`Tile[${this.lij}].vertex[${m}]:${v?
"internal":Z?"edge":F?"corner":"pole"}`+(na?"(below)":oa?"(above)":"")+(R?"(Neighbor)":"")};var S=g.dist(l,e);S>=a+0&&(S-=a,L||(console.error(`${pa()} is out of the bounding sphere by ${S.toFixed(0)} / ${a.toFixed(0)}`+"[tol\x3d0]"+` h=${r.toFixed(0)} / [${b.toFixed(0)}..${f.toFixed(0)}] (${(S/a).toFixed(0)})`),w=!0));for(L=0;6>L;++L)if(!(-1<=V(L,l[0],l[1],l[2]))){S=V(L,l[0],l[1],l[2]);const Z=m%I,xa=(m-Z)/I;0===L&&W||5===L&&Y||(console.error(`${pa()} (${Z},${xa})|${I}] is out of the bounding trapezoid plane ${L}`+
` h=${Math.round(r)} / [${Math.round(b)}..${Math.round(f)}] dist=${Math.round(S)}`+` radii = ${Math.round(a)}/${Math.round(t)}} : maxL = ${h}`),++C)}if(w||0<C)break}}}}}get convexHull(){return this._convexHull}}const ja=[128,64,64,32,16,8,8,4],J=(c,a,e,d)=>{const b=Math.sin(a),f=Math.cos(e);e=Math.sin(e);c[0]=d*f*Math.cos(a);c[1]=d*f*b;c[2]=d*e},ia=[0,0,1],fa=p.create(),ha=p.create();ca.SphericalPatch=ta;Object.defineProperty(ca,Symbol.toStringTag,{value:"Module"})});