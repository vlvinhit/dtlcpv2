// All material copyright Esri, All Rights Reserved, unless otherwise specified.
// See https://js.arcgis.com/4.30/esri/copyright.txt for details.
//>>built
define("exports ../../../core/mathUtils ../../../geometry/support/aaBoundingBox ../../../geometry/support/aaBoundingRect ./ElevationData ./interfaces ./NeighborIndex ./PatchGeometry ./PatchGeometryLUT ./PatchRenderData ./terrainUtils ./Tile ./tileUtils ../webgl-engine/lib/Normals".split(" "),function(mb,H,mc,$c,ka,Ib,nc,jb,ad,Jb,O,oc,Kb,Lb){function bd(a,b,c){const {tile:e,localOrigin:f,geometry:l}=a,{extent:k,ellipsoid:g}=e,{boundingBox:m,numVerticesPerSide:t,vertexAttributes:r,poleVerticesStartIndex:p}=
l,n=t-1,w=f[0],B=f[1],C=f[2],L=g.radius,R=k[1],X=k[3],P=[];let G=p;a=(M,Y)=>{Y*=t;eb(-w,-B,-C+M*L,m);P.push(new cd(1===M,Y,1===M?0:2,G,6));Y=Math.PI/2-2*Math.atan(Math.exp(-(-1===M?R:X)/L));const Aa=M*Math.PI/2-Y;M=.99*(1===M?1:-1);const ea=L+0,{position:ba,uv0:U}=r,{typedBuffer:Z,typedBufferStride:va}=r.normalCompressed;for(let x=1;6>=x;++x){var fa=Y+x/6*Aa;const D=Math.cos(fa);fa=Math.sin(fa);for(let F=0;F<=n;F++){const N=F/n,z=Ja.cosLonLUT[F]*D,h=Ja.sinLonLUT[F]*D,ca=fa,I=z*ea-w,ha=h*ea-B,da=ca*
ea-C;eb(I,ha,da,m);ba.setValues(G,I,ha,da);jb.encodeUVInBuffer(U,G,N,M);Lb.compressNormal(Z,G,z,h,ca,va);++G}}};b&&a(-1,0);c&&a(1,n);return P}function Qb(a){a.tile.intersectsClippingArea&&(Mb(a),pc(a))}function pc(a,b=!1){const {geometry:c,geometryState:e,tile:f,localOrigin:l}=a,{level:k,extent:g,extentInRadians:m,ellipsoid:t}=f,r=t.radius,p=m[0],n=m[2],w=m[1],B=m[3],{samplerData:C}=e,L=g[0],R=g[2],X=g[1],P=g[3],G=Rb(a),{boundingBox:M,vertexAttributes:Y}=c,Aa=l[0],ea=l[1],ba=l[2];var U=Y.position;
const Z=U.typedBuffer,va=U.typedBufferStride,fa=Y.uv0;for(let z=0;4>z;++z){const h=1===z||3===z;U=e.edgeResolutions[z];O.internalAssert(H.isPowerOfTwo(U));const ca=U+1;var x=Jb.neighborTileIfLoadedOrSelf(f,e.edgePeerNeighbors[z]);if(qc(f,x,z)){rc(a,z,x);continue}const I=null!=x;O.internalAssert(!I||x.level===f.level);O.internalAssert(!I||0>=Kb.compareTilesByLij(f,x));var D=x?.renderData?.geometryState;if(O.enableTerrainInternalChecks){var F=f.surface;if(!x&&F&&!F.updatingRootTiles){var N=O.neighborEdgeIndices[z];
const u=f.findNeighborTile(N,J=>J.isLoaded||J.isLeaf||J.level===f.level);u?u.intersectsClippingArea&&(O.internalAssert(!u.isLoaded),O.internalAssert(!u.isLeaf),O.internalAssert(u.level===k)):O.internalAssert(null==F?.rootTiles||!f.shouldHaveNeighbor(N))}}const ha=1===z?g[2]:g[0],da=(x=x?.extent)&&h?1===z?x[0]:x[2]:ha,qa=0===z?g[3]:g[1],Fa=1===z?1:0,aa=0===z?1:0,ia=1===z?n:p,ra=0===z?B:w,Ga=Math.sin(ia),Na=Math.cos(ia),Ha=Math.sin(ra),S=Math.cos(ra),d=D?.samplerData;D=(u,J,Q)=>ka.sampleElevation(u,
J,C);F=(u,J,Q)=>.5*(ka.sampleElevation(u,J,C)+ka.sampleElevation(Q,J,d));const y=I?F:D;D=c.outerEdgesOffsetAndLength[2*z];const v=b&&3<ca?ca-3:1;F=null!=C&&C.some(u=>null!=u);N=null!=d&&d.some(u=>null!=u);const q=F||N,A=1/U,E=D;O.internalAssert(!x||O.almostEquals(x[2]-x[0],g[2]-g[0]));(()=>{const u=1===z?-1:3===z?1:0,J=0===z?-1:2===z?1:0,Q=(g[2]-g[0])*A,wa=u*Q,xa=J*Q,Ua=n-p,Va=h?u*Ua*A:0,Oa=h?0:J*A,Ba=aa,na=h?ia+Va:ia,Ia=h?Math.sin(na):Ga,Ca=h?Math.cos(na):Na,la=h?ia-Va:ia,sa=h?Math.sin(la):Ga,V=
h?Math.cos(la):Na,T=h?ra:G(Ba+Oa),oa=h?Ha:Math.sin(T),Ka=h?S:Math.cos(T),ya=h?ra:G(Ba-Oa),$a=h?Ha:Math.sin(ya),Ra=h?S:Math.cos(ya);let ab=0,Sa=0,bb=0;const Da=0*A,Wa=h?ha:L*(1-Da)+R*Da,cb=h?da:Wa,db=h?X*(1-Da)+P*Da:qa,Ta=h?ia:p*(1-Da)+n*Da,Xa=h?Ga:Math.sin(Ta),Ya=h?Na:Math.cos(Ta),Pa=h?G(Da):ra,Qa=h?Math.sin(Pa):Ha,La=h?Math.cos(Pa):S,ma=r+y(Wa,db,cb);ab=Ya*La*ma;Sa=Xa*La*ma;bb=Qa*ma;let pa=0,ta=0,ua=0;const W=1*A,za=h?ha:L*(1-W)+R*W,Ea=h?da:za,K=h?X*(1-W)+P*W:qa,ja=h?ia:p*(1-W)+n*W,Ma=h?Ga:Math.sin(ja),
rb=h?Na:Math.cos(ja),hb=h?G(W):ra,fb=h?Math.sin(hb):Ha,nb=h?Math.cos(hb):S,gb=r+y(za,K,Ea);pa=rb*nb*gb;ta=Ma*nb*gb;ua=fb*gb;for(let Za=1;Za<ca-1;Za+=v){let ob=0,kb=0,pb=0;const ib=(Za+1)*A,vb=h?ha:L*(1-ib)+R*ib,Nb=h?da:vb,lb=h?X*(1-ib)+P*ib:qa,qb=h?ia:p*(1-ib)+n*ib,wb=h?Ga:Math.sin(qb),tb=h?Na:Math.cos(qb),sb=h?G(ib):ra,xb=h?Math.sin(sb):Ha,Eb=h?Math.cos(sb):S,Sb=r+y(vb,lb,Nb);ob=tb*Eb*Sb;kb=wb*Eb*Sb;pb=xb*Sb;const sc=ob,tc=kb,uc=pb,Tb=pa,Ub=ta,Vb=ua;pa=sc;ta=tc;ua=uc;const vc=E+Za,Wb=vc*va,wc=Tb-
Aa,xc=Ub-ea,yc=Vb-ba;Z[Wb]=wc;Z[Wb+1]=xc;Z[Wb+2]=yc;eb(wc,xc,yc,M);const zc=Za*A;jb.encodeUVInBuffer(fa,vc,h?Fa:zc,h?zc:aa);const dd=ab,ed=Sa,fd=bb;ab=Tb;Sa=Ub;bb=Vb;const Fb=Tb,Gb=Ub,yb=Vb,Ob=1/Math.sqrt(Fb*Fb+Gb*Gb+yb*yb),Ac=yb*Ob;let zb=0,Ab=0,Bb=0;if(q&&.999>Ac*Ac){let Xb=0,Yb=0,Zb=0;const $b=0===z?-1:1;Xb=$b*(sc-dd);Yb=$b*(tc-ed);Zb=$b*(uc-fd);const ub=Za*A,Bc=h?ha:L*(1-ub)+R*ub,gd=h?da:Bc,Cc=h?X*(1-ub)+P*ub:qa,Dc=h?ia:p*(1-ub)+n*ub,Ec=h?Ga:Math.sin(Dc),Fc=h?Na:Math.cos(Dc),Gc=h?G(ub):ra,Hc=
h?Math.sin(Gc):Ha,Ic=h?Math.cos(Gc):S;let ac=Fb,bc=Gb,cc=yb;if(I){const dc=r+ka.sampleElevation(gd-wa,Cc-xa,d),hd=h?sa:Ec,id=h?Hc:$a,Jc=h?Ic:Ra;ac=(h?V:Fc)*Jc*dc;bc=hd*Jc*dc;cc=id*dc}const ec=r+ka.sampleElevation(Bc+wa,Cc+xa,C),Kc=h?Ic:Ka,Lc=(h?Ca:Fc)*Kc*ec,Mc=(h?Ia:Ec)*Kc*ec,Nc=(h?Hc:oa)*ec;I||(ac=2*Fb-Lc,bc=2*Gb-Mc,cc=2*yb-Nc);const fc=3===z?-1:1,Oc=fc*(ac-Lc),Pc=fc*(bc-Mc),Qc=fc*(cc-Nc);zb=Zb*Pc-Yb*Qc;Ab=Xb*Qc-Zb*Oc;Bb=Yb*Oc-Xb*Pc;const gc=1/Math.sqrt(zb*zb+Ab*Ab+Bb*Bb);zb*=gc;Ab*=gc;Bb*=gc}else zb=
Fb*Ob,Ab=Gb*Ob,Bb=yb*Ob;c.setEdgeNormalFromValues(z,Za,zb,Ab,Bb)}})()}}function Rb(a){({tile:a}=a);if(a.surface.isWebMercator){const c=a.extent,e=a.ellipsoid.radius;return f=>Math.PI/2-2*Math.atan(Math.exp(-(c[1]*(1-f)+c[3]*f)/e))}const b=a.extentInRadians;return c=>b[1]*(1-c)+b[3]*c}function hc(a,b){a.tile.intersectsClippingArea&&(Mb(a),Rc(a,!1))}function Rc(a,b){const {geometry:c,geometryState:e,localOrigin:f}=a,l=a.tile,{surface:k,extent:g}=l,{clippingArea:m,samplerData:t}=e,r=null!=m?m:ic,p=g[0],
n=g[2],w=g[1],B=g[3],C=[B>r[3],n>r[2],w<r[1],p<r[0]],L=l.horizontalScale,R=Sc(k.isWebMercatorOnPlateCarree,l.ellipsoid.radius,L),{minu:X,minv:P,maxu:G,maxv:M,boundingBox:Y}=c,Aa=Math.max(p,r[0]),ea=Math.min(n,r[2]),ba=Math.max(w,r[1]),U=Math.min(B,r[3]),Z=f[0],va=f[1],fa=f[2];for(let x=0;4>x;++x){const D=1===x||3===x,F=e.edgeResolutions[x];O.internalAssert(H.isPowerOfTwo(F));const N=F+1,z=C[x],h=Jb.neighborTileIfLoadedOrSelf(l,e.edgePeerNeighbors[x]);if(!z&&qc(l,h,x)){rc(a,x,h);continue}const ca=
null!=h&&!z,I=h?.renderData?.geometryState;if(O.enableTerrainInternalChecks&&(O.internalAssert(!ca||h.level===l.level),O.internalAssert(!ca||0>=Kb.compareTilesByLij(l,h)),l&&!h&&!k.updatingRootTiles)){const V=O.neighborEdgeIndices[x],T=l.findNeighborTile(V,oa=>oa.isLoaded||oa.isLeaf||oa.level===l.level);k.updatingRootTiles||(T?T.intersectsClippingArea&&(O.internalAssert(!T.isLoaded),O.internalAssert(!T.isLeaf),O.internalAssert(T.level===l.level)):O.internalAssert(null==k?.rootTiles||!l.shouldHaveNeighbor(V)))}const ha=
H.clamp(1===x?n:p,Aa,ea),da=H.clamp(0===x?B:w,ba,U),qa=I?.samplerData,Fa=b&&3<N?N-3:1,aa=H.clamp(1===x?1:0,X,G),ia=H.clamp(0===x?1:0,P,M),ra=(V,T)=>ka.sampleElevation(V,T,t),Ga=(V,T)=>.5*(ka.sampleElevation(V,T,qa)+ka.sampleElevation(V,T,t)),Na=ca?Ga:ra,Ha=(n-p)/F,S=D?1===x?Ha:-Ha:0,d=D?0:0===x?Ha:-Ha,y=-S,v=-d;let q=0,A=0,E=0;const u=0/F,J=D?ha:H.clamp(p*(1-u)+n*u,Aa,ea),Q=D?H.clamp(w*(1-u)+B*u,ba,U):da,wa=Na(J,Q);q=J*L;A=R(Q);E=wa;let xa=0,Ua=0,Va=0;const Oa=1/F,Ba=D?ha:H.clamp(p*(1-Oa)+n*Oa,Aa,
ea),na=D?H.clamp(w*(1-Oa)+B*Oa,ba,U):da,Ia=Na(Ba,na),Ca=Ba*L,la=R(na),sa=Ia;xa=Ca;Ua=la;Va=sa;for(let V=1;V<N-1;V+=Fa){const T=V/F,oa=xa,Ka=Ua,ya=Va,$a=D?aa:H.clamp(T,X,G),Ra=D?H.clamp(T,P,M):ia,ab=oa-Z,Sa=Ka-va,bb=ya-fa;eb(oa,Sa,bb,Y);c.setEdgeVertexFromValuesRawPositionUV(x,V,ab,Sa,bb,$a,Ra);const Da=(V+1)/F,Wa=D?ha:H.clamp(p*(1-Da)+n*Da,Aa,ea),cb=D?H.clamp(w*(1-Da)+B*Da,ba,U):da,db=Na(Wa,cb);xa=Wa*L;Ua=R(cb);Va=db;const Ta=xa,Xa=Ua,Ya=Va,Pa=q,Qa=A,La=E;q=oa;A=Ka;E=ya;let ma=0,pa=0,ta=0;if(D){const W=
Xa-Ka,za=Ya-ya,Ea=Qa-Ka,K=La-ya,ja=H.clamp(w*(1-T)+B*T,ba,U),Ma=ha+y,rb=Ma*L,hb=ka.sampleElevation(Ma,ja,t),fb=rb-oa,nb=hb-ya,gb=3===x?-1:1;ma=gb*(-Ea+W)*nb;pa=gb*fb*(-K+za);ta=-gb*fb*(-Ea+W);if(ca){const Za=ha+S,ob=Za*L,kb=ka.sampleElevation(Za,ja,qa),pb=ob-oa;ma=(-Ea+W)*(nb-(kb-ya));pa=(fb-pb)*(-K+za);ta=-(fb-pb)*(-Ea+W)}}else{const W=Ta-oa,za=Ya-ya,Ea=Pa-oa,K=La-ya,ja=H.clamp(p*(1-T)+n*T,Aa,ea),Ma=da+v,rb=ka.sampleElevation(ja,Ma,t)-ya,hb=R(Ma)-Ka,fb=2===x?-1:1;ma=fb*hb*(-K+za);pa=fb*(-Ea+W)*rb;
ta=-fb*hb*(-Ea+W);if(ca){const nb=ja,gb=da+d,Za=R(gb),ob=ka.sampleElevation(nb,gb,qa)-ya,kb=Za-Ka;ma=(-hb+kb)*(-K+za);pa=(-Ea+W)*(-rb+ob);ta=-(-hb+kb)*(-Ea+W)}}const ua=1/Math.sqrt(ma*ma+pa*pa+ta*ta);c.setEdgeNormalFromValues(x,V,ma*ua,pa*ua,ta*ua)}}}function Sc(a,b,c){return a?e=>(Math.PI/2-2*Math.atan(Math.exp(-e/b)))*b:e=>e*c}function Tc(a,b,c){const {numVerticesPerSide:e,vertexAttributes:f,maxEdgeVertexCount:l}=a,k=e-1;var g=f.count;const m=2*(e-3)*(e-3);var t=4*(k+l-3);const r=Jb.zeroToFour.reduce((w,
B)=>w+(k+a.getEdgeCount(B)-3),0),p=b.reduce((w,B)=>w+k*(2*(B.latitudeResolution-1)+1),0),n=3*(c?2:1);t=(m+t+p)*n;g=65536<=g?new Uint32Array(t):new Uint16Array(t);for(let w=0;w<t;++w)g[w]=0;a.indices=g;a.indexCount=(m+r+p)*n;a.poleIndicesStartIndex=m*n;a.edgeIndicesStartIndex=(m+p)*n;c?(jd(a),kd(a,b),Uc(a)):(ld(a),md(a,b),Vc(a))}function ld(a){const {numVerticesPerSide:b,indices:c,vertexAttributes:e}=a;({position:a}=e);const {typedBuffer:f,typedBufferStride:l}=a;a=b-2;const k=b-3,g=b-3;let m=0;for(let t=
0;t<k;++t){const r=t*a;for(let p=0;p<g;++p){const n=r+p,w=n+1,B=w+a,C=B-1;Wc(n,w,B,C,l,f)?(c[m]=n,c[m+1]=w,c[m+2]=B,c[m+3]=B,c[m+4]=C,c[m+5]=n):(c[m]=n,c[m+1]=w,c[m+2]=C,c[m+3]=C,c[m+4]=w,c[m+5]=B);m+=6}}}function md(a,b){const {numVerticesPerSide:c,indices:e,poleIndicesStartIndex:f}=a,l=c-1;let k=f;for(const g of b){b=g.isNorth?1:2;const m=g.isNorth?2:1,t=g.isNorth?3:4,r=g.isNorth?4:3;let p=a.getEdgeVertexIndex(g.connectedOuterEdgeOffset,0),n=1;for(let w=0;w<g.latitudeResolution;++w){const B=0===
w?g.rowOffset:p+c;for(let C=0;C<l;C++){const L=B+C;e[k]=p;e[k+b]=p+1;e[k+m]=L;w<g.latitudeResolution-1?(e[k+t]=p+1,e[k+r]=L+1,e[k+5]=L,k+=6):k+=3;p+=n}p=B;n=1}}}function Vc(a){const {indices:b,numVerticesPerSide:c,edgeIndicesStartIndex:e}=a,f=c-1,l=f-2;let k=e;for(let r=0;4>r;++r){var g=jc[r];let p=0,n=0;const w=a.getEdgeCount(r),B=g.count;O.internalAssert(B===f-1);var m=1===r||2===r;const C=m?1:2;m=m?2:1;const L=a.getEdgeFirstVertexIndex(r),R=g.vertex0Index;for(g=g.stride;p<w-1||n<B-1;){const X=
R+n*g,P=L+1*p;var t=p<w-1;const G=n<B-1,M=t?f*(p+.5)/(w-1):0,Y=G?1+l*(n+.5)/(B-1):0;(t=t&&(!G||M<=Y))?++p:++n;t=t?P+1:X+g;b[k]=X;b[k+C]=P;b[k+m]=t;k+=3}}a.indexCount=k}function jd(a){const {indices:b,numVerticesPerSide:c,vertexAttributes:e}=a;({position:a}=e);const {typedBuffer:f,typedBufferStride:l}=a;a=c-2;let k=0;for(let g=0;g<c-3;++g){const m=g*a;for(let t=0;t<c-3;++t){const r=g*a+t,p=r+1,n=p+a,w=n-1,B=m+t,C=B+1,L=C+a;Wc(B,C,L,L-1,l,f)?(Cb(b,k,r,p,n),k+=6,Cb(b,k,n,w,r)):(Cb(b,k,r,p,w),k+=6,Cb(b,
k,w,n,p));k+=6}}}function kd(a,b){const {indices:c,numVerticesPerSide:e,poleIndicesStartIndex:f}=a,l=e-1;let k=f;for(const g of b){b=a.getEdgeVertexIndex(g.connectedOuterEdgeOffset,0);let m=1;for(let t=0;t<g.latitudeResolution;++t){const r=0===t?g.rowOffset:b+e;for(let p=0;p<l;p++)Cb(c,k,b,b+1,r+p),k+=6,t<g.latitudeResolution-1&&(Cb(c,k,b+1,r+p+1,r+p),k+=6),b+=m;b=r;m=1}}}function Uc(a){const {indices:b,numVerticesPerSide:c,edgeIndicesStartIndex:e}=a,f=c-1,l=f-2;let k=e;for(let r=0;4>r;++r){var g=
jc[r];let p=0,n=0;const w=a.getEdgeCount(r),B=g.count;O.internalAssert(B===f-1);var m=1===r||2===r;const C=m?1:3;m=m?3:1;const L=a.getEdgeFirstVertexIndex(r),R=g.vertex0Index;for(g=g.stride;p<w-1||n<B-1;){const X=R+n*g,P=L+1*p;var t=p<w-1;const G=n<B-1,M=t?f*(p+.5)/(w-1):0,Y=G?1+l*(n+.5)/(B-1):0;(t=t&&(!G||M<=Y))?++p:++n;t=t?P+1:X+g;b[k]=X;b[k+C]=P;b[k+C+1]=P;b[k+m]=t;b[k+m+1]=t;b[k+5]=X;k+=6}}a.indexCount=k}function kc(a){const {geometry:b,geometryState:c}=a;({edgeResolutions:a}=c);const {numVerticesPerSide:e,
edgeVerticesStartIndex:f}=b,l=e-2;let k=f;for(let m=0;4>m;++m){var g=0===m||2===m;g=(g?0:1)*l+(g?1:0);const t=jc[m];t.vertex0Index=(0===m?l-1:0)*l+(1===m?l-1:0);t.stride=g;t.count=l;g=a[m]+1;b.outerEdgesOffsetAndLength[2*m]=k;b.outerEdgesOffsetAndLength[2*m+1]=g;k+=g}}function Xc(a){kc(a);a.geometryState.wireframe?Uc(a.geometry):Vc(a.geometry)}function rc(a,b,c){const {geometryState:e,geometry:f,tile:l,localOrigin:k}=a;a=1===b||3===b;const g=e.edgeResolutions[b];O.internalAssert(H.isPowerOfTwo(g));
const m=g+1,{boundingBox:t,minu:r,minv:p,maxu:n,maxv:w,vertexAttributes:B}=f,C=H.clamp(1===b?1:0,r,n),L=H.clamp(0===b?1:0,p,w);var R=c.renderData,X=R.geometryState,P=R.geometry,G=(b+2)%4,M=P.getEdgeCount(G);const Y=l.getNeighborEdgeStartVertexIndex(b,c)*g;c=g*2**(l.level-c.level);O.internalAssert(X.edgeResolutions[G]===c);O.internalAssert(M-1===c);c=R.localOrigin[0]-k[0];X=R.localOrigin[1]-k[1];R=R.localOrigin[2]-k[2];b=f.getEdgeFirstVertexIndex(b);var Aa=B.position;M=Aa.typedBuffer;Aa=Aa.typedBufferStride;
var ea=B.normalCompressed;const ba=ea.typedBuffer;ea=ea.typedBufferStride;const U=B.uv0;var Z=P.vertexAttributes;P=P.getEdgeFirstVertexIndex(G);G=Z.position.typedBuffer;const va=Z.position.typedBufferStride,fa=Z.normalCompressed.typedBuffer;Z=Z.normalCompressed.typedBufferStride;for(let N=1;N<m-1;++N){const z=b+N;var x=P+(Y+N),D=z*Aa,F=x*va;const h=G[F]+c,ca=G[F+1]+X;F=G[F+2]+R;M[D]=h;M[D+1]=ca;M[D+2]=F;eb(h,ca,F,t);D=z*ea;x*=Z;ba[D]=fa[x];ba[D+1]=fa[x+1];D=N/g;x=a?C:H.clamp(D,r,n);D=a?H.clamp(D,
p,w):L;jb.encodeUVInBuffer(U,z,x,D)}}function Mb(a){const {geometry:b,geometryState:c,localOrigin:e}=a,{clippingArea:f,samplerData:l}=c,{minu:k,minv:g,maxu:m,maxv:t,boundingBox:r,vertexAttributes:p}=b,n=a.tile,{surface:w,ellipsoid:B,extent:C,extentInRadians:L,horizontalScale:R}=n,X="local"===w.view?.viewingMode,P=B.radius;let G=0,M=0,Y=0;const Aa=()=>{const d=null!=f&&(C[3]>f[3]||C[2]>f[2]||C[1]<f[1]||C[0]<f[0]),y=Sc(w.isWebMercatorOnPlateCarree,P,R);return(v,q,A)=>{v=0===v?C[0]:C[2];q=0===q?C[1]:
C[3];v=d?H.clamp(v,f[0],f[2]):v;q=d?H.clamp(q,f[1],f[3]):q;G=v*R;M=y(q);Y=A}},ea=(d,y,v)=>{var q=L[0===y?1:3];d=L[0===d?0:2];y=Math.cos(q);q=Math.sin(q);const A=Math.sin(d);v=P+v;G=Math.cos(d)*y*v;M=A*y*v;Y=q*v},ba=X?Aa():ea;let U=0,Z=0,va=0,fa=0,x=0,D=0,F=0,N=0,z=0;const h=X&&w.isWebMercatorOnPlateCarree,ca=(d,y,v,q,A)=>{var E=0,u=0;let J=0;X?(v=h?(Math.PI/2-2*Math.atan(Math.exp(-v/P)))*P:v*R,E=y*R-G,u=v-M,J=q-Y):(E=Rb(d),d=d.tile,u=d.extent,d=d.extentInRadians,y=(y-u[0])/(u[2]-u[0]),y=d[0]*(1-y)+
d[2]*y,E=E((v-u[1])/(u[3]-u[1])),v=Math.cos(E),d=Math.sin(E),u=Math.sin(y),q=P+q,E=Math.cos(y)*v*q-G,u=u*v*q-M,J=d*q-Y);switch(A){case 0:F+=E;N+=u;z+=J;break;case 1:fa-=E;x-=u;D-=J;break;case 2:F-=E;N-=u;z-=J;break;case 3:fa+=E,x+=u,D+=J}},I=f??ic,ha=C[0],da=C[2],qa=C[1],Fa=C[3],aa=[Fa>I[3],da>I[2],qa<I[1],ha<I[0]],ia=Math.max(ha,I[0]),ra=Math.min(da,I[2]),Ga=Math.max(qa,I[1]),Na=Math.min(Fa,I[3]),Ha=d=>{var y=c.cornerNeighborCornerTiles;Z=U=0;va=1;z=N=F=D=x=fa=0;var v=Infinity;for(var q=0;4>q;++q)v=
Math.min(v,y[4*d+q]?.level??Infinity);for(q=0;4>q;++q){var A=y[4*d+q];Hb[q]=A?.level===v?A:null}d=1;y=0;for(v=0;4>v;++v)if(q=Hb[v])d=Math.max(d,q?.renderData.geometryState.numVerticesPerSide),y=q.extent[2]-q.extent[0];O.internalAssert(1<d);d=y/d;for(y=0;4>y;++y){A=Hb[(y+3)%4];var E=Hb[y%4];if(A||E){q=0===y?1:1===y?2:2===y?3:0;var u=0===y?2:1===y?3:2===y?0:1;if(A&&E){var J=lc[y][0]*d,Q=lc[y][1]*d,wa=A.extent;v=Math.max(I[0],Math.min(I[2],wa[0===q||1===q?2:0]+J));q=Math.max(I[1],Math.min(I[3],wa[0===
q||3===q?3:1]+Q));wa=E.extent;J=Math.max(I[0],Math.min(I[2],wa[0===u||1===u?2:0]+J));u=Math.max(I[1],Math.min(I[3],wa[0===u||3===u?3:1]+Q));A=A.renderData;Q=E.renderData;E=ka.sampleElevation(v,q,A.geometryState.samplerData);u=ka.sampleElevation(J,u,Q.geometryState.samplerData);ca(A,v,q,.5*(E+u),y)}else v=A??E,A=A?q:u,E=v.extent,u=lc[y],q=Math.max(I[0],Math.min(I[2],E[0===A||1===A?2:0]+u[0]*d)),A=Math.max(I[1],Math.min(I[3],E[0===A||3===A?3:1]+u[1]*d)),v=v.renderData,E=ka.sampleElevation(q,A,v.geometryState.samplerData),
ca(v,q,A,E,y)}}X||(d=Math.sqrt(G*G+M*M+Y*Y),U=G/d,Z=M/d,va=Y/d);if(X||.999>va*va)d=Math.sqrt(fa*fa+x*x+D*D),fa/=d,x/=d,D/=d,d=Math.sqrt(F*F+N*N+z*z),F/=d,N/=d,z/=d,U=D*N-x*z,Z=fa*z-D*F,va=x*F-fa*N,d=1/Math.sqrt(U*U+Z*Z+va*va),U*=d,Z*=d,va*=d},S=c.cornerNeighborCornerTiles;for(let d=0;4>d;++d){const y=d,v=(d+1)%4,q=0===d||1===d?1:0,A=0===d||3===d?1:0,E=H.clamp(q,k,m),u=H.clamp(A,g,t),J=b.getEdgeFirstVertexIndex(y),Q=b.getEdgeCount(y),wa=0===d||3===d?Q-1:0,xa=b.getEdgeFirstVertexIndex(v),Ua=b.getEdgeCount(v),
Va=0===d||1===d?Ua-1:0;let Oa=-1;for(let Ia=0;4>Ia;++Ia){const Ca=S[4*d+Ia],la=S[4*d+Oa];Ca&&(-1===Oa||0<Kb.compareTilesByLij(la,Ca))&&(Oa=Ia)}const Ba=Oa,na=S[4*d+Ba];if(na!==n){const Ia=n.level-na.level,Ca=2**Ia,la=[na.lij[0]+Ia,na.lij[1]*Ca,na.lij[2]*Ca],sa=[la[1]+Ca===n.lij[1],0===d&&(1===Ba||0===Ba&&na!==S[4*d+3])||1===d&&(0===Ba||1===Ba&&na!==S[4*d+2]),la[1]===n.lij[1]+1,2===d&&(3===Ba||2===Ba&&na!==S[4*d+1])||3===d&&(2===Ba||3===Ba&&na!==S[4*d])],V=sa.reduce((K,ja)=>K+(ja?1:0),0);O.internalAssert(1===
V||2===V);let T=-1,oa=-1;const Ka=na.renderData;if(1===V){const K=sa.findIndex(Ma=>Ma);O.internalAssert(0<=K&&3>=K);T=(K+2)%4;const ja=c.edgeResolutions[K];oa=n.getNeighborEdgeStartVertexIndex(K,na)*ja+ja*(0===K&&0===d||1===K&&0===d||2===K&&1===d||3===K&&3===d?1:0)}else{O.internalAssert(sa[1]||sa[3]);T=sa[1]?3:1;const K=Ka.geometryState.edgeResolutions[T];oa=0===d||3===d?0:K}const ya=Ka.geometry,$a=J+wa,Ra=xa+Va,ab=ya.getEdgeFirstVertexIndex(T)+oa,Sa=ya.vertexAttributes,bb=Ka.localOrigin,Da=Sa.position,
Wa=Da.typedBuffer,cb=ab*Da.typedBufferStride,db=Wa[cb]+bb[0]-e[0],Ta=Wa[cb+1]+bb[1]-e[1],Xa=Wa[cb+2]+bb[2]-e[2];eb(db,Ta,Xa,r);const Ya=p.position,Pa=Ya.typedBuffer,Qa=$a*Ya.typedBufferStride;Pa[Qa]=db;Pa[Qa+1]=Ta;Pa[Qa+2]=Xa;const La=Ra*Ya.typedBufferStride;Pa[La]=db;Pa[La+1]=Ta;Pa[La+2]=Xa;const ma=p.uv0;jb.encodeUVInBuffer(ma,$a,E,u);jb.encodeUVInBuffer(ma,Ra,E,u);const pa=Sa.normalCompressed.typedBuffer,ta=ab*Sa.normalCompressed.typedBufferStride,ua=p.normalCompressed,W=ua.typedBuffer,za=$a*ua.typedBufferStride;
W[za]=pa[ta];W[za+1]=pa[ta+1];const Ea=Ra*ua.typedBufferStride;W[Ea]=pa[ta];W[Ea+1]=pa[ta+1]}else{const Ia=aa[v];let Ca=void 0;if(aa[y]||Ia){const T=H.clamp(ha*(1-q)+da*q,ia,ra),oa=H.clamp(qa*(1-A)+Fa*A,Ga,Na);Ca=ka.sampleElevation(T,oa,l)}else Ca=nd(S,d);ba(q,A,Ca);Ha(d);const la=G-e[0],sa=M-e[1],V=Y-e[2];eb(la,sa,V,r);b.setEdgeVertexFromValuesRawPositionUVNormal(y,wa,la,sa,V,E,u,U,Z,va);b.setEdgeVertexFromValuesRawPositionUVNormal(v,Va,la,sa,V,E,u,U,Z,va)}}for(let d=0;4>d;++d)Hb[d]=null}function nd(a,
b){const c=4*b;b=Jb.zeroToFour.reduce((k,g)=>Math.min(k,a[c+g]?.level??Infinity),Infinity);O.enableTerrainInternalChecks&&(O.internalAssert(!a[c+0]||!a[c+2]||oc.isCornerNeighbor(a[c+0],a[c+2],nc.NeighborIndex.SOUTH_WEST)),O.internalAssert(!a[c+1]||!a[c+3]||oc.isCornerNeighbor(a[c+1],a[c+3],nc.NeighborIndex.NORTH_WEST)));let e=0,f=0;for(let k=0;4>k;++k){var l=a[c+k];if(l&&l.level===b){const g=l.extent;l=ka.sampleElevation(g[0===k||1===k?0:2],g[0===k||3===k?1:3],l.renderData?.geometryState?.samplerData);
f+=l;e++}}b=e?f/e:0;O.internalAssert(null!=b);return b}function Db(a){const {vao:b,geometry:c}=a,{vertexAttributes:e,edgeVerticesStartIndex:f}=c;a=e.position.typedBuffer;b.vertexBuffers.geometry.setSubData(a,f,f,a.length)}function Yc(a){const {vao:b,geometry:c}=a,{indices:e,indexCount:f,edgeIndicesStartIndex:l}=c;b.indexBuffer.setSubData(e,l,l,f)}function qc(a,b,c){if(!b)return!1;a=Kb.compareTilesByLij(a,b);return 0<a||0===a&&2<=c}function eb(a,b,c,e){a<e[0]?e[0]=a:a>e[3]&&(e[3]=a);b<e[1]?e[1]=b:
b>e[4]&&(e[4]=b);c<e[2]?e[2]=c:c>e[5]&&(e[5]=c)}function Zc(a){const {edgeResolutions:b,numVerticesPerSide:c}=a;a=1+Math.max(...b);return Math.max(c,a)}function Wc(a,b,c,e,f,l){var k=a*f;a=l[k];const g=l[k+1];k=l[k+2];var m=b*f;b=l[m];const t=l[m+1];m=l[m+2];var r=c*f;c=l[r];const p=l[r+1];r=l[r+2];const n=e*f;e=l[n];f=l[n+1];l=l[n+2];return(b-e)*(b-e)+(t-f)*(t-f)+(m-l)*(m-l)>(a-c)*(a-c)+(g-p)*(g-p)+(k-r)*(k-r)}function Cb(a,b,c,e,f){a[b]=c;a[b+1]=e;a[b+2]=e;a[b+3]=f;a[b+4]=f;a[b+5]=c}class cd{constructor(a,
b,c,e,f){this.isNorth=a;this.connectedRowOffset=b;this.connectedOuterEdgeOffset=c;this.rowOffset=e;this.latitudeResolution=f}}const lc=[[0,1],[1,0],[0,-1],[-1,0]],Ja=new ad.PatchGeometryLUT,ic=$c.fromValues(-Infinity,-Infinity,Infinity,Infinity),Hb=[null,null,null,null];class Pb{constructor(){this.vertex0Index=0;this.stride=1;this.count=0}getVertexIndex(a){O.internalAssert(0<=a&&a<this.count);return this.vertex0Index+this.stride*a}}const jc=[new Pb,new Pb,new Pb,new Pb];mb.createPlanarGlobePatch=
function(a,b){const {tile:c,geometryState:e,geometry:f}=a,{extent:l,surface:k}=c,{wireframe:g}=e,m=l[0],t=l[1],r=l[2]-m,p=l[3]-t,{numVerticesPerSide:n,clippingArea:w}=e,B=null!=w?Math.max(0,(w[0]-m)/r):0,C=null!=w?Math.max(0,(w[1]-t)/p):0,L=null!=w?Math.min(1,(w[2]-m)/r):1,R=null!=w?Math.min(1,(w[3]-t)/p):1,X=(n-2)**2,P=Zc(e),G=k.renderer.tileGeometryCache.acquire(X+4*P),{boundingBox:M}=f;mc.empty(M);f.numVerticesPerSide=n;f.vertexAttributes=G;f.maxEdgeVertexCount=P;f.minu=B;f.minv=C;f.maxu=L;f.maxv=
R;{const Ca=a.tile;if(Ca.intersectsClippingArea){var {geometry:Y,geometryState:Aa,localOrigin:ea}=a,{samplerData:ba,clippingArea:U,numVerticesPerSide:Z}=Aa,{surface:va,extent:fa,ellipsoid:x}=Ca,{isWebMercatorOnPlateCarree:D}=va,F=null!=U?U:ic,N=fa[0],z=fa[1],h=fa[2],ca=fa[3],I=Math.max(N,F[0]),ha=Math.min(h,F[2]),da=Math.max(z,F[1]),qa=Math.min(ca,F[3]),Fa=x.radius,b=Ca.horizontalScale,aa=Z-1,ia=Z-2,{minu:ra,minv:Ga,maxu:Na,maxv:Ha,boundingBox:S,vertexAttributes:d}=Y,y=d.position,v=d.uv0,{typedBuffer:q,
typedBufferStride:A}=d.normalCompressed,E=ea[0],u=ea[1],J=ea[2],Q=y.typedBuffer,wa=y.typedBufferStride,xa=0,Ua=H.clamp(z,da,qa),Va=D?(Math.PI/2-2*Math.atan(Math.exp(-Ua/Fa)))*Fa:Ua*b,Oa=1/aa,Ba=H.clamp(z*(1-Oa)+ca*Oa,da,qa),na=Va,Ia=D?(Math.PI/2-2*Math.atan(Math.exp(-Ba/Fa)))*Fa:Ba*b;for(let la=1;la<=ia;la++){const sa=la/aa,V=H.clamp(z*(1-sa)+ca*sa,da,qa),T=H.clamp(sa,Ga,Ha),oa=Ia,Ka=(la-1)/aa,ya=H.clamp(z*(1-Ka)+ca*Ka,da,qa),$a=na,Ra=(la+1)/aa,ab=H.clamp(z*(1-Ra)+ca*Ra,da,qa),Sa=D?(Math.PI/2-2*Math.atan(Math.exp(-ab/
Fa)))*Fa:ab*b,bb=H.clamp(Ra,Ga,Ha);na=Ia;Ia=Sa;const Da=H.clamp(N,I,ha);let Wa=Da*b,cb=ka.sampleElevation(Da,V,ba);const db=1/aa,Ta=H.clamp(db,ra,Na),Xa=H.clamp(N*(1-Ta)+h*Ta,I,ha);let Ya=Ta,Pa=Xa,Qa=Xa*b,La=ka.sampleElevation(Xa,V,ba);if(1===la){const ma=Qa-E,pa=na-u,ta=La-J,ua=0*wa;Q[ua]=ma;Q[ua+1]=pa;Q[ua+2]=ta;eb(ma,pa,ta,S);const W=H.clamp(db,ra,Na);jb.encodeUVInBuffer(v,xa,W,T)}for(let ma=1;ma<=ia;ma++){const pa=Qa,ta=La,ua=(ma+1)/aa,W=H.clamp(ua,ra,Na),za=H.clamp(N*(1-ua)+h*ua,I,ha),Ea=Pa;
Pa=za;const K=xa+1,ja=K*wa;if(1===la||ma===ia){const lb=ka.sampleElevation(za,V,ba),qb=za*b,wb=oa,tb=lb;if(1===la&&ma<ia){const sb=qb-E,xb=wb-u,Eb=tb-J;Q[ja]=sb;Q[ja+1]=xb;Q[ja+2]=Eb;eb(sb,xb,Eb,S);jb.encodeUVInBuffer(v,K,W,T)}Qa=qb;La=tb}else Qa=Q[ja]+E,La=Q[ja+2]+J;const Ma=Qa,rb=La,hb=Wa,fb=cb;Wa=pa;cb=ta;const nb=(xa-ia)*wa,gb=1===la?ka.sampleElevation(Ea,ya,ba):Q[nb+2]+J,Za=ka.sampleElevation(Ea,ab,ba);if(la<ia){const lb=xa+ia,qb=lb*wa,wb=pa-E,tb=Sa-u,sb=Za-J;Q[qb]=wb;Q[qb+1]=tb;Q[qb+2]=sb;eb(wb,
tb,sb,S);const xb=Ya;Ya=W;jb.encodeUVInBuffer(v,lb,xb,bb)}const ob=Ma-hb,kb=$a-Sa,pb=kb*(rb-fb),ib=ob*(gb-Za),vb=-kb*ob,Nb=pb*pb+ib*ib+vb*vb;if(0===Nb)Lb.compressNormal(q,xa,0,0,1,A);else{const lb=1/Math.sqrt(Nb);Lb.compressNormal(q,xa,pb*lb,ib*lb,vb*lb,A)}++xa}}}}f.edgeVerticesStartIndex=X;kc(a);hc(a);Tc(f,[],g);a.intersectionData=null};mb.createSphericalGlobePatch=function(a,b){const {tile:c,geometry:e,geometryState:f}=a,{extentInRadians:l,surface:k}=c,{isWebMercator:g,renderer:m}=k,{numVerticesPerSide:t,
wireframe:r}=f,p=t-1,n=(t-2)**2,w=g&&(b===Ib.PatchType.HAS_SOUTH_POLE||b===Ib.PatchType.HAS_BOTH_POLES),B=g&&(b===Ib.PatchType.HAS_NORTH_POLE||b===Ib.PatchType.HAS_BOTH_POLES),C=6*((w?1:0)+(B?1:0))*t,L=Zc(f),R=m.tileGeometryCache.acquire(n+C+4*L);e.numVerticesPerSide=t;e.vertexAttributes=R;e.maxEdgeVertexCount=L;const {boundingBox:X}=e;mc.empty(X);const P=Rb(a);Ja.update(p,l,P);{const {tile:Ha}=a;if(Ha.intersectsClippingArea){var {geometry:G,geometryState:M,localOrigin:Y}=a,{numVerticesPerSide:Aa,
samplerData:ea}=M,ba=Aa-2,U=Aa-1,{vertexAttributes:Z,boundingBox:va}=G,fa=Z.position,x=Z.uv0,{typedBuffer:D,typedBufferStride:F}=Z.normalCompressed,{extent:N}=Ha,z=N[0],h=N[2],ca=N[1],I=N[3],ha=Ha.ellipsoid.radius,da=Y[0],qa=Y[1],Fa=Y[2],aa=fa.typedBuffer,ia=fa.typedBufferStride,ra=1/U,Ga=0;if(1<=ba){const S=ca*(1-ra)+I*ra,d=Ja.sinLatLUT[1],y=Ja.cosLatLUT[1];for(let v=1;v<=ba;v++){const q=v*ra,A=Ja.sinLonLUT[v],E=Ja.cosLonLUT[v],u=ha+ka.sampleElevation(z*(1-q)+h*q,S,ea),J=-da+u*E*y,Q=-qa+u*A*y,wa=
-Fa+u*d;eb(J,Q,wa,va);const xa=(v-1)*ia;aa[xa]=J;aa[xa+1]=Q;aa[xa+2]=wa;jb.encodeUVInBuffer(x,v-1,q,ra)}}for(let S=1;S<=ba;S++){const d=S*ra,y=ca*(1-d)+I*d,v=Ja.sinLatLUT[S],q=Ja.cosLatLUT[S],A=S+1,E=A*ra,u=ca*(1-E)+I*E,J=Ja.sinLatLUT[A],Q=Ja.cosLatLUT[A],wa=Ja.sinLonLUT[0],xa=Ja.cosLonLUT[0],Ua=ha+ka.sampleElevation(z,y,ea);let Va=xa*q*Ua-da,Oa=wa*q*Ua-qa,Ba=v*Ua-Fa;const na=Ga*ia;let Ia=aa[na],Ca=aa[na+1],la=aa[na+2];for(let sa=1;sa<=ba;sa++){const V=sa*ra,T=z*(1-V)+h*V,oa=Ja.sinLonLUT[sa],Ka=Ja.cosLonLUT[sa];
let ya=0,$a=0,Ra=0;if(sa<ba){const K=(Ga+1)*ia;ya=aa[K];$a=aa[K+1];Ra=aa[K+2]}else{const K=Ja.sinLonLUT[U],ja=Ja.cosLonLUT[U],Ma=ha+ka.sampleElevation(h,y,ea);ya=ja*q*Ma-da;$a=K*q*Ma-qa;Ra=v*Ma-Fa}const ab=Va,Sa=Oa,bb=Ba;Va=Ia;Oa=Ca;Ba=la;Ia=ya;Ca=$a;la=Ra;const Da=ya-ab,Wa=$a-Sa,cb=Ra-bb;let db=0,Ta=0,Xa=0;if(1<S){const K=(Ga-ba)*ia;db=aa[K];Ta=aa[K+1];Xa=aa[K+2]}else{const K=Ja.sinLatLUT[0],ja=Ja.cosLatLUT[0],Ma=ha+ka.sampleElevation(T,ca,ea);db=Ka*ja*Ma-da;Ta=oa*ja*Ma-qa;Xa=K*Ma-Fa}const Ya=ha+
ka.sampleElevation(T,u,ea),Pa=Ka*Q*Ya-da,Qa=oa*Q*Ya-qa,La=J*Ya-Fa;if(S<ba){const K=Ga+ba,ja=K*ia;aa[ja]=Pa;aa[ja+1]=Qa;aa[ja+2]=La;eb(Pa,Qa,La,va);jb.encodeUVInBuffer(x,K,V,E)}const ma=db-Pa,pa=Ta-Qa,ta=Xa-La;let ua=Ka*q,W=oa*q,za=v;.999>za*za&&(ua=cb*pa-Wa*ta,W=Da*ta-cb*ma,za=Wa*ma-Da*pa);const Ea=1/Math.sqrt(ua*ua+W*W+za*za);Lb.compressNormal(D,Ga,ua*Ea,W*Ea,za*Ea,F);++Ga}}}}e.poleVerticesStartIndex=n;const Na=bd(a,w,B);e.edgeVerticesStartIndex=n+C;kc(a);Qb(a);Tc(e,Na,r);a.intersectionData=null};
mb.updateCornerSpherical=function(a){a.tile.intersectsClippingArea&&(Mb(a),pc(a,!0),Db(a),a.intersectionData=null)};mb.updateCornersPlanar=function(a,b){a.tile.intersectsClippingArea&&(Mb(a),Rc(a,!0),Db(a),a.intersectionData=null)};mb.updateEdgeElevationsAndResolutionsPlanar=function(a,b){a.tile.intersectsClippingArea&&(Xc(a),hc(a),Db(a),Yc(a),a.intersectionData=null)};mb.updateEdgeElevationsAndResolutionsSpherical=function(a){a.tile.intersectsClippingArea&&(Xc(a),Qb(a),Db(a),Yc(a),a.intersectionData=
null)};mb.updateEdgesAndCornersPlanar=function(a,b){a.tile.intersectsClippingArea&&(hc(a),Db(a),a.intersectionData=null)};mb.updateEdgesAndCornersSpherical=function(a){a.tile.intersectsClippingArea&&(Qb(a),Db(a),a.intersectionData=null)};Object.defineProperty(mb,Symbol.toStringTag,{value:"Module"})});