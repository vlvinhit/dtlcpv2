// All material copyright Esri, All Rights Reserved, unless otherwise specified.
// See https://js.arcgis.com/4.30/esri/copyright.txt for details.
//>>built
define("exports ../../../../../core/mathUtils ../../../../../core/quantityUtils ../../../../../core/unitUtils ../../../../../core/libs/gl-matrix-2/math/vec2 ../../../../../core/libs/gl-matrix-2/factories/vec2f64 ../../../../../chunks/vec32 ../../../../../core/libs/gl-matrix-2/factories/vec3f64 ../../../../../core/libs/gl-matrix-2/factories/vec4f64 ../../../../../geometry/ellipsoidUtils ../../../../../geometry/projection ../../../../../geometry/spatialReferenceEllipsoidUtils ../../../../../geometry/projection/projectDirection ../../../../../geometry/projection/projectPointToVector ../../../../../geometry/projection/projectVectorToVector ../../../../../geometry/support/Axis ../../../../../geometry/support/Indices ../../../../../geometry/support/intersectsBase ../../../../../chunks/sphere ../../../../../geometry/support/triangle ../../interfaces ../../support/measurementUtils ../../../support/ElevationProvider ../../../support/mathUtils ../../../../support/euclideanAreaMeasurementUtils ../../../../support/euclideanLengthMeasurementUtils ../../../../support/geodesicLengthMeasurementUtils ../../../../support/geodesicMeasurementUtils ../../../../support/measurementUtils".split(" "),
function(D,P,w,E,B,F,m,n,Q,R,S,G,H,A,I,T,J,K,U,V,L,y,W,z,M,X,N,Y,Z){class aa{get numVertices(){return this._length}get hasStagedVertex(){return this._hasCursorPoint}constructor(a){this.validMeasurement=!1;this.positionsWorld=[];this.positionsRender=[];this.positionsFittedWorld=[];this.positionsFittedRender=[];this.positionsGeodesic=[];this.positionsSpherical=[];this.positionsStereographic=[];this.pathSegmentLengths=[];this.geodesicPathSegmentLengths=[];this.perimeterSegmentLengths=[];this.intersectingSegments=
new Set;this.geodesicIntersectingSegments=new Set;this.geodesicTriangleIndices=this.triangleIndices=null;this.areaCentroidWorldCoords=n.create();this.areaCentroidRenderCoords=n.create();this.geodesicAreaCentroidRenderCoords=n.create();this.perimeterLength=this.geodesicPathLength=this.pathLength=this.geodesicArea=this.area=this.fittingMode=null;this._length=0;this._centroidRenderCoords=n.create();this._planeWorldCoords=Q.create();this._worldUp=n.create();this._worldTangent=n.create();this._frame=[n.create(),
n.create(),n.create()];this._pathVersion=-1;this._hasCursorPoint=!1;this._mode=null;this._tempU=n.create();this._tempV=n.create();this._tempVec3=n.create();this._tempSphere=U.create();this._sceneView=a;this._measurementSR=a=Z.computeEuclideanMeasurementSR(a.spatialReference);this._lengthMeasurementUnit=E.lengthUnitFromSpatialReference(a)??"meters";this._areaMeasurementUnit=E.areaUnitFromSpatialReference(a)??"square-meters"}update(a,b,c,d,e,f){const h=null!=b,l=this._hasCursorPoint===h,k=this._mode===
e;if(this._pathVersion===a.version&&!f&&l&&k&&a.isValidPolygon)return!1;this._pathVersion=a.version;this._hasCursorPoint=h;this._updateCursorSegmentLength(a,b);this._update(a,b,c,d,e);return!0}_update(a,b,c,d,e){const f=this._sceneView.renderSpatialReference,h=this._measurementSR,l=c.spatialReference;let k=a.numVertices;const g=null!=b&&!b.equals(a.lastPoint)&&!(2<k&&b.equals(a.firstPoint));g&&(k+=1);var r=!a.polygonIsClosed&&2<k;r=a.polygonIsClosed||r;this._resize(k);const t=G.getSphericalPCPF(l),
p=null!=l&&Y.supportsGeodesicMeasurement(l)?l:null,q=null!=p&&S.canProjectWithoutEngine(l,t),{positionsGeodesic:x,positionsWorld:ba,positionsRender:ca,positionsSpherical:C}=this,O=(u,v)=>{u.hasZ||(u.z=W.getElevationAtPoint(c.elevationProvider,u,"ground")??0);A.projectPointToVector(u,ba[v],h);A.projectPointToVector(u,ca[v],f);q&&(A.projectPointToVector(u,x[v],p),A.projectPointToVector(u,C[v],t),m.normalize(C[v],C[v]))};a.forEachVertexPosition((u,v)=>O(u,v));g&&O(b,k-1);a=this._updatePathLengths(r);
this.pathLength=1<this._length?w.createLength(a,this._lengthMeasurementUnit):null;q?(a=this._updateGeodesicPathLengths(r,p),this.geodesicPathLength=null!=a&&1<this._length?a:null):this.geodesicPathLength=null;this._updateMode(e);r?(this._updateAreaAndPerimeterLength(c,f,h,d),q&&this._updateGeodesicArea(c,p),this.validMeasurement=!0):(this.geodesicTriangleIndices=this.triangleIndices=this.perimeterLength=this.geodesicArea=this.area=null,this.intersectingSegments.clear(),this.geodesicIntersectingSegments.clear(),
this.validMeasurement=!1)}getData(){return{validMeasurement:this.validMeasurement,numVertices:this.numVertices,hasStagedVertex:this.hasStagedVertex,positionsRender:this.positionsRender,positionsFittedWorld:this.positionsFittedWorld,positionsFittedRender:this.positionsFittedRender,intersectingSegments:this.intersectingSegments,geodesicIntersectingSegments:this.geodesicIntersectingSegments,triangleIndices:this.triangleIndices,geodesicTriangleIndices:this.geodesicTriangleIndices,areaCentroidRenderCoords:this.areaCentroidRenderCoords,
geodesicAreaCentroidRenderCoords:this.geodesicAreaCentroidRenderCoords,area:this.area,geodesicArea:this.geodesicArea,pathLength:this.pathLength,geodesicPathLength:this.geodesicPathLength,perimeterLength:this.perimeterLength,actualMeasurementMode:this.actualMeasurementMode}}_resize(a){a<this._length&&(this.positionsWorld.length=a,this.positionsRender.length=a,this.positionsFittedWorld.length=a,this.positionsFittedRender.length=a,this.positionsGeodesic.length=a,this.positionsSpherical.length=a,this.positionsStereographic.length=
a,this.pathSegmentLengths.length=a,this.geodesicPathSegmentLengths.length=a,this._length=this.perimeterSegmentLengths.length=a);for(;this._length<a;)this.positionsWorld.push(n.create()),this.positionsRender.push(n.create()),this.positionsFittedWorld.push(F.create()),this.positionsFittedRender.push(n.create()),this.positionsGeodesic.push(n.create()),this.positionsSpherical.push(n.create()),this.positionsStereographic.push(F.create()),this.pathSegmentLengths.push(0),this.geodesicPathSegmentLengths.push(0),
this.perimeterSegmentLengths.push(0),++this._length}_updatePathLengths(a){const b=this.positionsWorld,c=this.pathSegmentLengths;let d=0;const e=this._length;for(let f=0;f<e;++f){const h=c[f]=m.distance(b[f],b[(f+1)%e]);if(f<e-1||a)d+=h}return d}_updateGeodesicPathLengths(a,b){const c=this.positionsGeodesic,d=this.geodesicPathSegmentLengths;let e=0;const f=this._length;for(let l=0;l<f;++l){var h=N.geodesicDistance(c[l],c[(l+1)%f],b);if(null==h)return null;h=w.toUnit(h,"meters").value;h=d[l]=h;if(l<
f-1||a)e+=h}return w.createLength(e,"meters")}_updateAreaAndPerimeterLength(a,b,c,d){const e=a.renderCoordsHelper;a=this.positionsWorld;const f=this.positionsRender,h=this.positionsFittedWorld,l=this.positionsFittedRender;var k=this._planeWorldCoords,g=this._centroidRenderCoords;z.midpoint3d(f,g);e.worldUpAtPosition(g,this._worldUp);e.worldBasisAtPosition(g,T.Axis.X,this._worldTangent);H.projectDirection(g,this._worldUp,b,this._worldUp,c);H.projectDirection(g,this._worldTangent,b,this._worldTangent,
c);2<a.length&&y.bestFitPlane(a,k);this.fittingMode=this._selectFittingMode(k,a,this._worldUp,d);let r=0;if("horizontal"===this.fittingMode){let p=-Infinity;f.forEach((q,x)=>{q=e.getAltitude(f[x]);q>p&&(p=q,r=x)})}d=a[r];g=k;var t=this._worldTangent;"horizontal"===this.fittingMode?g=this._worldUp:"vertical"===this.fittingMode&&(g=this._tempVec3,t=this._worldUp,z.makeOrthonormal(k,this._worldUp,g));m.copy(this._frame[2],g);z.makeOrthonormal(t,g,this._frame[0]);m.cross(this._frame[1],this._frame[0],
this._frame[2]);m.negate(this._frame[1],this._frame[1]);k=this._tempVec3;g=this._tempU;t=this._tempV;for(let p=0;p<this._length;++p){const q=h[p],x=l[p];m.subtract(k,a[p],d);B.set(q,m.dot(this._frame[0],k),m.dot(this._frame[1],k));m.scale(g,this._frame[0],q[0]);m.scale(t,this._frame[1],q[1]);m.add(k,g,t);m.add(k,k,d);I.projectVectorToVector(k,c,x,b)}this.perimeterLength=0<this._length?this._updatePerimeterLengths():null;z.midpoint3d(l,this.areaCentroidRenderCoords);I.projectVectorToVector(this.areaCentroidRenderCoords,
b,this.areaCentroidWorldCoords,c);this._updateIntersectingSegments();this.area=0===this.intersectingSegments.size?this._computeArea():null}_updateGeodesicArea(a,b){const {renderCoordsHelper:c,spatialReference:d}=a,{positionsSpherical:e,positionsStereographic:f}=this;a=this._tempVec3;const h=y.fitHemisphere(e,a);if(h){var l=this._tempU,k=this._tempV;z.tangentFrame(a,l,k);for(let g=0;g<this._length;++g){const r=m.dot(e[g],l),t=m.dot(e[g],k),p=m.dot(e[g],a);B.set(f[g],r/p,t/p)}m.scale(a,a,R.getReferenceEllipsoid(d).radius);
c.toRenderCoords(a,G.getSphericalPCPF(d),this.geodesicAreaCentroidRenderCoords);this._updateGeodesicIntersectingSegments();this.geodesicArea=h&&0===this.geodesicIntersectingSegments.size?this._computeGeodesicArea(b):null}else this.geodesicArea=null}_updatePerimeterLengths(){const a=this.positionsFittedWorld,b=this.perimeterSegmentLengths;let c=0;for(let d=0;d<this._length;++d){const e=b[d]=B.distance(a[d],a[(d+1)%this._length]);c+=e}return w.createLength(c,this._lengthMeasurementUnit)}_updateIntersectingSegments(){const a=
this.positionsFittedWorld,b=this.intersectingSegments;b.clear();for(let c=0;c<this._length;++c)for(let d=c+2;d<this._length;++d)(d+1)%this._length!==c&&K.segmentIntersects(a[c],a[(c+1)%this._length],a[d],a[(d+1)%this._length])&&(b.add(c),b.add(d))}_computeArea(){const a=this.positionsFittedWorld,b=this.triangleIndices=J.compactIndices(M.triangulate(a));let c=0;for(let d=0;d<b.length;d+=3)c+=V.areaPoints2d(a[b[d]],a[b[d+1]],a[b[d+2]]);return w.createArea(c,this._areaMeasurementUnit)}_updateGeodesicIntersectingSegments(){const a=
this.positionsStereographic,b=this.geodesicIntersectingSegments;b.clear();for(let c=0;c<this._length;++c)for(let d=c+2;d<this._length;++d)(d+1)%this._length!==c&&K.segmentIntersects(a[c],a[(c+1)%this._length],a[d],a[(d+1)%this._length])&&(b.add(c),b.add(d))}_computeGeodesicArea(a){const b=this.positionsGeodesic,c=this.geodesicTriangleIndices=J.compactIndices(M.triangulate(this.positionsStereographic));let d=0;for(let e=0;e<c.length;e+=3){const f=y.triangleAreaGeodesic(b[c[e]],b[c[e+1]],b[c[e+2]],
a);if(null==f)return null;d+=w.toUnit(f,"square-meters").value}return w.createArea(d,"square-meters")}_selectFittingMode(a,b,c,d){var e=b.map(h=>Math.abs(y.planePointDistance(a,h))).reduce((h,l)=>Math.max(h,l),0);y.boundingSphere(b,this._tempSphere);b=e/(2*this._tempSphere[3]);e=b<d.maxRelativeErrorAlmostCoplanar;let f="horizontal";b<d.maxRelativeErrorCoplanar?f="oblique":e&&(f=Math.abs(m.dot(c,a))>Math.cos(P.deg2rad(d.verticalAngleThreshold))?"horizontal":"vertical");return f}_updateCursorSegmentLength(a,
b){const c=a.lastPoint;a.isValidPolygon||null==c||null==b?this.stagedSegmentLength=this.geodesicStagedSegmentLength=null:(this.geodesicStagedSegmentLength=N.geodesicDistanceBetweenPoints(c,b),this.stagedSegmentLength=X.euclideanDistanceBetweenPoints(c,b)?.direct)}_updateMode(a){if(a===L.MeasurementMode.Auto){this.actualMeasurementMode="euclidean";let b=0;null!=this.geodesicPathLength&&(b+=this.geodesicPathLength.value);1E5<b&&(this.actualMeasurementMode="geodesic")}else this.actualMeasurementMode=
a===L.MeasurementMode.Euclidean?"euclidean":"geodesic";null==this.geodesicPathLength&&(this.actualMeasurementMode="euclidean");this._mode=a}}D.MeasurementDataManager=aa;Object.defineProperty(D,Symbol.toStringTag,{value:"Module"})});