// All material copyright Esri, All Rights Reserved, unless otherwise specified.
// See https://js.arcgis.com/4.30/esri/copyright.txt for details.
//>>built
define("exports ../../../geometry ../../../core/quantityUtils ../../../core/unitUtils ../../../chunks/vec32 ../../../geometry/projection/projectVectorToVector ../../../geometry/support/geodesicUtils ../../../layers/graphics/dehydratedPoint ../../../support/elevationInfoUtils ./constraints ./normalizedPoint ../../support/angularMeasurementUtils ../../../geometry/SpatialReference".split(" "),function(p,T,r,A,x,u,K,L,M,n,m,l,N){function O(b,c,a,e){if(null!=a&&null!=b){var d=v(b,e);if(null!=d){a=l.getDegreesGeographic(a);
var f=h=>{if(null!=h){var k=m.createWritable();h=r.createAngle(h,"degrees","geographic");if(l.pointFromDistanceAlongAzimuth(k,d,e.measurementSR,10,h,e.mode))return new n.VerticalHalfPlaneConstraint(d,k)}},g=()=>{if(null!=c&&null!=b)return l.getDegreesGeographic(l.directionBetweenPoints(c,b))};switch(e.directionMode){case l.DirectionMode.Absolute:return f(a);case l.DirectionMode.Relative:return g=g(),null==g?void 0:f(g+a);case l.DirectionMode.RelativeBilateral:return g=g(),null==g?void 0:n.constraintOrSet([f(g+
a),f(g-a)])}}}}function B(b,c){b=C(b,c)?.value??void 0;return null!=b?new n.HorizontalPlaneConstraint(b):void 0}function y(b,c,a){const {context:e,longitude:d,latitude:f,direction:g,distance:h,elevation:k}=a;if(null!=d||null!=f||null!=h||null!=k||null!=g)return null!=d||null!=f?(b=l.getDegreesGeographic(d),c=l.getDegreesGeographic(f),a=z(k,e),new n.CoordinateConstraint(b,c,a)):P(b,c,a)}function P(b,c,{context:a,direction:e,distance:d,elevation:f}){if(null==c)return B(f,a);const {view:g,elevationInfo:h,
measurementSR:k}=a,q=m.fromPoint(c,g,h);if(k&&u.projectVectorToVector(q,c.spatialReference,D,k)){var [Q,R]=D,E=null!=d?r.valueInUnit(d,"meters"):void 0;e=l.getDegreesGeographic(e);var F=z(f,a);f=G=>{const H=new n.GeodesicConstraint([Q,R],k,E,F,G);return null==E||null==G||null==F&&a.hasZ?H:new n.PointConstraint(H.closestTo(q))};if(null==e)return f(void 0);d=()=>{if(null!=b&&null!=c)return l.getDegreesGeographic(l.directionBetweenPoints(b,c))};switch(a.directionMode){case l.DirectionMode.Absolute:return f(e);
case l.DirectionMode.Relative:return d=d(),null==d?void 0:f(d+e);case l.DirectionMode.RelativeBilateral:return d=d(),null==d?void 0:n.constraintOrSet([f(d+e),f(d-e)])}}}function I({x:b,y:c,elevation:a,context:e}){w.x=b?.value??0;w.y=c?.value??0;w.spatialReference=e.spatialReference;const d=v(w,e,S);return new n.CoordinateConstraint(null!=b&&null!=d?d[0]:void 0,null!=c&&null!=d?d[1]:void 0,z(a,e))}function J(b){let c;for(const a of b)a&&(c=c?.intersect(a)??a);return c}function v(b,c,a=m.createWritable()){const {view:e,
elevationInfo:d,measurementSR:f,origin:g,mode:h}=c;m.fromPoint(b,e,d,a);if(u.projectVectorToVector(a,b.spatialReference,a,f))return"geodesic"!==h&&x.subtract(a,a,g),a}function z(b,c){b=C(b,c);return null!=b?r.valueInUnit(b,"meters"):void 0}function C(b,{view:c,origin:a,elevationInfo:e,hasZ:d,measurementSR:f}){if(null!=b&&d&&(d=A.verticalLengthUnitFromSpatialReference(f),null!=d)){var [g,h]=a;b=r.valueInUnit(b,d);c="3d"===c?.type?M.getConvertedElevationFromXYZ(c,g,h,b,f,e):b;if(null!=c)return r.createLength(c,
d)}}const D=m.createWritable(),S=m.createWritable(),t=m.createWritable(),w=L.makeDehydratedPoint(0,0,0,N.WGS84);p.constraintSpaceToPoint=function(b,c,a,e){const {view:d,measurementSR:f,spatialReference:g,origin:h,mode:k}=a;"geodesic"===k?x.copy(t,b):x.add(t,b,h);if(u.projectVectorToVector(t,f,t,g))return m.toElevationAlignedDehydratedPoint(t,d,c,a,e)};p.getConstraintContext=function(b,c,a,e,d,f){let g="geodesic",h=K.geodesicCompatibleSpatialReference(a);const k=m.createWritable();m.fromPoint(b,c,
e,k);k[2]=0;h&&u.projectVectorToVector(k,a,k,h)||(g="euclidean",h=a);return{mode:g,view:c,elevationInfo:e,hasZ:d,directionMode:f,spatialReference:b.spatialReference,measurementSR:h,origin:k}};p.getGeodesicConstraint=y;p.getPointConstraint=function(b){return"geodesic"===b.context.mode?y(null,null,b):I(b)};p.getPolylineOrPolygonConstraint=function(b,c,a){const {context:e,x:d,y:f,distance:g,direction:h,elevation:k}=a;if("geodesic"===e.mode)return y(c,b,a);if(null!=d||null!=f)return I(a);if(null==g||
null==b)a=void 0;else{var q=A.lengthUnitFromSpatialReference(e.measurementSR);null==q?a=void 0:(a=v(b,e),null==a?a=void 0:(q=r.valueInUnit(g,q),a=new n.VerticalCylinderConstraint(a,q)))}return J([a,O(b,c,h,e),B(k,e)])};p.intersectAll=J;p.pointToConstraintSpace=v;Object.defineProperty(p,Symbol.toStringTag,{value:"Module"})});