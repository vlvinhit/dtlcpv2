// All material copyright Esri, All Rights Reserved, unless otherwise specified.
// See https://js.arcgis.com/4.30/esri/copyright.txt for details.
//>>built
define("exports ../../../core/Cyclical ../../../core/quantityUtils ../../../core/libs/gl-matrix-2/factories/vec3f64 ../../../support/elevationInfoUtils ../sketch/normalizedPoint ./SnappingAlgorithm ./snappingUtils ./candidates/LineSnappingCandidate ../support/viewUtils ../../support/angularMeasurementUtils ../../support/geodesicLengthMeasurementUtils ../../support/geometry3dUtils ../../support/geometry2dUtils".split(" "),function(r,t,u,v,m,l,w,n,x,p,q,y,z,A){function B(g,a,b,c,{spatialReference:d}){var e=
q.radiansGeographicBetweenVec(a,b,d,d);if(null==e)return!1;const h=q.radiansGeographicBetweenVec(b,c,d,d);if(null==h)return!1;a=y.geodesicDistance(b,c,d);if(null==a)return!1;e=Math.abs(t.cyclicalPI.shortestSignedDiff(e,h))>Math.PI/2?t.cyclical2PI.normalize(e+Math.PI):e;q.pointFromDistanceAlongAzimuth(g,b,d,u.valueInUnit(a,"meters"),u.createAngle(e,"radians","geographic"),"geodesic");g[2]=c[2];return!0}class C extends w.SnappingAlgorithm{snapNewVertex(g,a){var b=a.editGeometryOperations.data.components[0],
c=b.edges.length;const d=[];if(1>c)return d;var {spatialReference:e}=a;e=p.vectorToScreenPoint(g,e,m.absoluteHeightElevationInfo,this.view);const {view:h}=this;c=b=b.edges[c-1];do{if(this.edgeExceedsShortLineThreshold(c,a)){const f=n.editEdgeToSnappingEdge(c,h,a);this._processCandidateProposal(f.left,f.right,g,e,a,d)}c=c.leftVertex.leftEdge}while(c&&c!==b);return d}snapExistingVertex(g,a){const b=[],c=a.vertexHandle;var d=c.component;if(2>d.edges.length)return b;const {view:e}=this;var {spatialReference:h}=
a;h=p.vectorToScreenPoint(g,h,m.absoluteHeightElevationInfo,e);var f=c.leftEdge,k=c.rightEdge;f&&k&&this.edgeExceedsShortLineThreshold(f,a)&&this.edgeExceedsShortLineThreshold(k,a)&&this._processCandidateProposal(l.fromAnyMapPoint(f.leftVertex.pos,e,a),l.fromAnyMapPoint(k.rightVertex.pos,e,a),g,h,a,b);f=d=d.edges[0];do f!==c.leftEdge&&f!==c.rightEdge&&this.edgeExceedsShortLineThreshold(f,a)&&(k=n.editEdgeToSnappingEdge(f,e,a),this._processCandidateProposal(k.left,k.right,g,h,a,b)),f=f.rightVertex.rightEdge;
while(f&&f!==d);return b}_processCandidateProposal(g,a,b,c,d,e){const {spatialReference:h,pointer:f}=d,k=v.create();B(k,g,a,b,d)||(z.projectPointToLineLike(b,{start:g,end:a,type:A.LineType.LINE},k),k[2]=b[2]);b=l.markAsTarget(l.fromVec3(k));n.squaredScreenDistance(c,p.vectorToScreenPoint(b,h,m.absoluteHeightElevationInfo,this.view))<this.squaredProximityThreshold(f)&&e.push(new x.LineSnappingCandidate({lineStart:g,lineEnd:a,targetPoint:b,isDraped:"on-the-ground"===d.elevationInfo?.mode}))}}r.LineSnapper=
C;Object.defineProperty(r,Symbol.toStringTag,{value:"Module"})});