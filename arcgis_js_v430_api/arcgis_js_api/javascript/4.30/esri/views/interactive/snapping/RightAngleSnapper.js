// All material copyright Esri, All Rights Reserved, unless otherwise specified.
// See https://js.arcgis.com/4.30/esri/copyright.txt for details.
//>>built
define("exports ../../../core/Cyclical ../../../core/quantityUtils ../../../core/libs/gl-matrix-2/math/vec2 ../../../core/libs/gl-matrix-2/factories/vec2f64 ../../../chunks/vec32 ../../../core/libs/gl-matrix-2/factories/vec3f64 ../../../support/elevationInfoUtils ../sketch/constraints ../sketch/normalizedPoint ./SnappingAlgorithm ./snappingUtils ./candidates/RightAngleSnappingCandidate ../support/viewUtils ../../support/angularMeasurementUtils ../../support/geodesicLengthMeasurementUtils".split(" "),
function(x,B,y,l,C,p,q,r,D,g,E,F,k,t,u,G){function H(f,e,b,a,{spatialReference:c}){e=u.radiansGeographicBetweenVec(e,b,c,c);if(null==e)return!1;var d=u.radiansGeographicBetweenVec(b,a,c,c);if(null==d)return!1;d=Math.sign(B.cyclical2PI.shortestSignedDiff(e,d))*Math.PI*.5;e=y.createAngle(e+d,"radians","geographic");d=q.create();a=G.geodesicDistance(b,a,c);if(null==a)return!1;u.pointFromDistanceAlongAzimuth(d,b,c,y.valueInUnit(a,"meters"),e,"geodesic");p.subtract(f,d,b);return!0}class I extends E.SnappingAlgorithm{snapNewVertex(f,
e){var b=e.editGeometryOperations.data.components[0];const a=[];if(2>b.vertices.length)return a;var {view:c}=this;c=t.vectorToScreenPoint(f,e.spatialReference,r.absoluteHeightElevationInfo,c);const d=b.vertices.at(-1);this._checkForSnappingCandidate(k.SelfSnappingRightAngleType.LastVertex,a,d.leftEdge,d,d.leftEdge.leftVertex,f,c,e);b=b.vertices[0];this._checkForSnappingCandidate(k.SelfSnappingRightAngleType.FirstVertex,a,b.rightEdge,b,b.rightEdge.rightVertex,f,c,e);return a}snapExistingVertex(f,e){const b=
[];var a=e.vertexHandle;if(3>a.component.vertices.length)return b;var {view:c}=this;c=t.vectorToScreenPoint(f,e.spatialReference,r.absoluteHeightElevationInfo,c);var d=a.leftEdge;a=a.rightEdge;d?.leftVertex.leftEdge&&(d=d.leftVertex.leftEdge,this._checkForSnappingCandidate(k.SelfSnappingRightAngleType.ExistingEdge,b,d,d.rightVertex,d.leftVertex,f,c,e));a?.rightVertex.rightEdge&&(a=a.rightVertex.rightEdge,this._checkForSnappingCandidate(k.SelfSnappingRightAngleType.ExistingEdge,b,a,a.leftVertex,a.rightVertex,
f,c,e));return b}_checkForSnappingCandidate(f,e,b,a,c,d,v,h){if(this.edgeExceedsShortLineThreshold(b,h)){b=this.view;a=g.fromAnyMapPoint(a.pos,b,h);c=g.fromAnyMapPoint(c.pos,b,h);b=z;if(!H(b,c,a,d,h)){const m=l.subtract(w,g.asVec2(a),g.asVec2(c));p.set(b,m[1],-m[0],0)}this._checkForSnappingCandidateAlongProjectedRay(f,e,c,a,z,d,v,h)}}_checkForSnappingCandidateAlongProjectedRay(f,e,b,a,c,d,v,h){const {spatialReference:m,pointer:J}=h;var n=l.subtract(w,g.asVec2(d),g.asVec2(a));n=l.dot(c,n)/l.squaredLength(c);
const A=l.scaleAndAdd(w,g.asVec2(a),c,n);d=g.markAsTarget(g.fromValues(A[0],A[1],d[2]));F.squaredScreenDistance(v,t.vectorToScreenPoint(d,m,r.absoluteHeightElevationInfo,this.view))>this.squaredProximityThreshold(J)||this.isVertical(d,a,h)||this.isVertical(a,b,h)||(c=p.scaleAndAdd(q.create(),a,c,Math.sign(n)),e.push(new k.RightAngleSnappingCandidate({targetPoint:d,constraint:new D.VerticalHalfPlaneConstraint(a,g.fromVec3(c)),previousVertex:b,otherVertex:a,otherVertexType:k.OtherVertexType.CENTER,
selfSnappingType:f,isDraped:"on-the-ground"===h.elevationInfo?.mode})))}}const w=C.create(),z=q.create();x.RightAngleSnapper=I;Object.defineProperty(x,Symbol.toStringTag,{value:"Module"})});