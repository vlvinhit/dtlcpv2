// All material copyright Esri, All Rights Reserved, unless otherwise specified.
// See https://js.arcgis.com/4.30/esri/copyright.txt for details.
//>>built
define("../../../chunks/tslib.es6 ../../../core/arrayUtils ../../../core/Error ../../../core/promiseUtils ../../../core/Logger ../../../core/has ../../../core/accessorSupport/decorators/subclass ../../../layers/support/fieldType ../../../layers/support/fieldUtils ../../statistics/support/predominanceUtils ../../statistics/support/statsWorker ../../statistics/support/utils ../../statistics/support/WorkerClient ../utils ./FeatureLayerAdapter ./support/utils".split(" "),function(B,C,p,D,x,K,E,F,z,G,
t,H,I,v,J,n){x=class extends J{constructor(){super(...arguments);this.adapterName="feature-layer-binning-adapter"}async _getNormalizationTotalFromMemory(a,b,c){const {featuresJSON:e,graphics:l,layerView:g,query:k}=b;a=(!e&&!l&&g&&"queryAggregateSummaryStatistics"in g?await g.queryAggregateSummaryStatistics(k,{field:a},{signal:c}):e?await this.workerClient.summaryStatistics({field:a},e):await t.summaryStatistics({attribute:{field:a},features:l})).sum;if(null==a)throw new p(`${this.adapterName}:invalid`,
"invalid normalizationTotal");return a}async _processStatsFromMemoryParams(a){const {features:b,filter:c}=a;if(b?.length)return this._getFilteredFeatures(b,c);const {view:e,field:l,field2:g,field3:k,normalizationField:d,valueExpression:h,returnGeometry:m,layerViewFunc:f,signal:r}=a;let q=a=null,u=null,y=null,A=null;if(e)try{if(a=await e.whenLayerView(this.layer),q=null!=f&&f in a&&"function"===typeof a[f]){await this._waitForLayerViewUpdate(a);const w=await v.getFieldsList({field:l,field2:g,field3:k,
normalizationField:d,valueExpression:h});n.getMissingFieldsForBinning(this,w).length?q=!1:(u="createAggregateQuery"in a?a.createAggregateQuery():null)?(u.outFields=w,u.returnGeometry=!1,n.updateQueryWithFeatureFilter(u,c)):q=!1;a.suspended&&(q=!1)}}catch{q=!1}if(!q&&(A=n.getFeatureReductionFields(this.layer).map(w=>w.toJSON()),y=await this._fetchFeaturesForStats({field:l,field2:g,field3:k,valueExpression:h,normalizationField:d,returnGeometry:m,filter:c,view:e,signal:r},"json"),!y?.length))throw new p(`${this.adapterName}:insufficient-data`,
"No features are available to calculate statistics");return{layerView:a,query:u,featuresJSON:y,fieldInfos:A}}async _summaryStatsFromMemory(a,b){const {view:c,field:e,valueExpression:l,normalizationType:g,signal:k}=a,d={field:e,valueExpression:l,normalizationType:g,normalizationField:a.normalizationField,normalizationTotal:a.normalizationTotal,minValue:a.minValue,maxValue:a.maxValue},{featuresJSON:h,graphics:m,layerView:f,query:r,fieldInfos:q}=await this._processStatsFromMemoryParams({...a,layerViewFunc:"queryAggregateSummaryStatistics"});
l&&c&&(h||m)&&(d.fieldType=b?.type?F.kebabDict.toJSON(b.type):null,d.viewInfoParams=n.getViewInfoParams(c),d.timeZone=c.timeZone,d.fieldInfos=q);"percent-of-total"===g&&null==a.normalizationTotal&&(d.normalizationTotal=await this._getNormalizationTotalFromMemory(e,{featuresJSON:h,graphics:m,layerView:f,query:r},k));return!h&&!m&&f&&"queryAggregateSummaryStatistics"in f?f.queryAggregateSummaryStatistics(r,d,{signal:k}):h?this.workerClient.summaryStatistics(d,h):t.summaryStatistics({attribute:d,features:m})}async _uvFromMemory(a,
b){const {view:c,field:e,valueExpression:l,returnAllCodedValues:g,signal:k}=a,{featuresJSON:d,graphics:h,layerView:m,query:f,fieldInfos:r}=await this._processStatsFromMemoryParams({...a,layerViewFunc:"queryAggregateUniqueValues"});a={field:e,field2:a.field2,field3:a.field3,fieldDelimiter:v.fieldDelimiter,valueExpression:l,domains:b,returnAllCodedValues:g};l&&c&&(d||h)&&(a.viewInfoParams=n.getViewInfoParams(c),a.timeZone=c.timeZone,a.fieldInfos=r);return!d&&!h&&m&&"queryAggregateUniqueValues"in m?
m.queryAggregateUniqueValues(f,a,{signal:k}):d?this.workerClient.uniqueValues(a,d):t.uniqueValues({attribute:a,features:h})}async _histogramFromMemory(a){const {view:b,field:c,valueExpression:e,signal:l}=a,{featuresJSON:g,graphics:k,layerView:d,query:h,fieldInfos:m}=await this._processStatsFromMemoryParams({...a,layerViewFunc:"queryAggregateHistogram"}),f={field:c,valueExpression:e,normalizationType:a.normalizationType,normalizationField:a.normalizationField,normalizationTotal:a.normalizationTotal,
minValue:a.minValue,maxValue:a.maxValue,standardDeviationInterval:a.standardDeviationInterval,classificationMethod:a.classificationMethod,numBins:a.numBins};e&&b&&(g||k)&&(f.viewInfoParams=n.getViewInfoParams(b),f.timeZone=b.timeZone,f.fieldInfos=m);"percent-of-total"===a.normalizationType&&null==a.normalizationTotal&&(f.normalizationTotal=await this._getNormalizationTotalFromMemory(c,{featuresJSON:g,graphics:k,layerView:d,query:h},l));return!g&&!k&&d&&"queryAggregateHistogram"in d?d.queryAggregateHistogram(h,
f,{signal:l}):g?this.workerClient.histogram(f,g):t.histogram({attribute:f,features:k})}async _classBreaksFromMemory(a){const {view:b,field:c,valueExpression:e,signal:l}=a,{featuresJSON:g,graphics:k,layerView:d,query:h,fieldInfos:m}=await this._processStatsFromMemoryParams({...a,layerViewFunc:"queryAggregateClassBreaks"}),f={field:c,valueExpression:e,normalizationType:a.normalizationType,normalizationField:a.normalizationField,normalizationTotal:a.normalizationTotal,minValue:a.minValue,maxValue:a.maxValue,
standardDeviationInterval:a.standardDeviationInterval,classificationMethod:a.classificationMethod,numClasses:a.numClasses};e&&b&&(g||k)&&(f.viewInfoParams=n.getViewInfoParams(b),f.timeZone=b.timeZone,f.fieldInfos=m);"percent-of-total"===a.normalizationType&&null==a.normalizationTotal&&(f.normalizationTotal=await this._getNormalizationTotalFromMemory(c,{featuresJSON:g,graphics:k,layerView:d,query:h},l));return!g&&!k&&d&&"queryAggregateClassBreaks"in d?d.queryAggregateClassBreaks(h,f,{signal:l}):g?
this.workerClient.classBreaks(f,g):t.classBreaks({attribute:f,features:k})}getField(a=""){return n.getFeatureReductionFields(this.layer)?.find(b=>b.name.toLowerCase()===a?.toLowerCase())}getFieldUsageInfo(a){return this.getField(a)?{supportsLabelingInfo:!0,supportsRenderer:!0,supportsPopupTemplate:!0,supportsLayerQuery:!1,supportsStatistics:!0}:null}getFieldDomain(a,b){return null}async summaryStatistics(a){var {field:b}=a;const c=b?this.getField(b):null,e=v.isAnyDateField(c)||z.isTimeOnlyField(c);
b=a.sqlExpression&&!a.valueExpression&&!b;if(e||b)throw new p(`${this.adapterName}:not-supported`,"Date field and sqlExpression are not supported");return this._summaryStatsFromMemory(a,c)}async uniqueValues(a){const b=await n.getDomainsForFields(a,this);return this._uvFromMemory(a,b)}async histogram(a){var {field:b}=a,c=b?this.getField(b):null;c=v.isAnyDateField(c)||z.isTimeOnlyField(c);b=a.sqlExpression&&!a.valueExpression&&!b;if(c||b)throw new p(`${this.adapterName}:not-supported`,"Date field and sqlExpression are not supported");
return this._histogramFromMemory(a)}async classBreaks(a){return(!1!==a.analyzeData?this._classBreaksFromMemory(a):this._classBreaksFromInterpolation(a)).catch(()=>{D.throwIfAborted(a.signal);return this._classBreaksFromMemory(a)})}async queryFeatureCount(a){const b=await a.view?.whenLayerView(this.layer);if(!(b&&"queryAggregateCount"in b&&b.queryAggregateCount))throw new p(`${this.adapterName}:not-supported`,"LayerView is not supported.");await this._waitForLayerViewUpdate(b);const c=b.createAggregateQuery();
c.where=H.mergeWhereClauses(c.where,a.whereClause);n.updateQueryWithFeatureFilter(c,a.filter);return b.queryAggregateCount(c,{signal:a.signal})}generateRenderer(a,b){throw new p(`${this.adapterName}:not-supported`,"'generateRenderer' is not supported.");}heatmapStatistics(a){throw new p(`${this.adapterName}:not-supported`,"'heatmapStatistics' is not supported.");}async predominantCategories(a){const {fields:b,view:c,signal:e}=a;a=G.getArcadeForPredominantCategory(b);a=await this._uvFromMemory({valueExpression:a,
view:c,signal:e});return n.getPredominantCategoriesFromUVInfos(a.uniqueValueInfos,b)}async getSampleFeatures(a,b){const {view:c,sampleSize:e,requiredFields:l,returnGeometry:g,filter:k,signal:d}=a;if(!c)throw new p(`${this.adapterName}:not-supported`,"'view' is required to get sample features for binning.");if("3d"===c.type)throw new p(`${this.adapterName}:not-supported`,"3d 'view' is not supported to get sample features for binning.");a=await c.whenLayerView(this.layer);if(!("queryAggregateJSON"in
a&&a.queryAggregateJSON&&"queryAggregates"in a&&a.queryAggregates))throw new p(`${this.adapterName}:not-supported`,"LayerView is not supported.");await this._waitForLayerViewUpdate(a);if(n.getMissingFieldsForBinning(this,l).length)throw new p(`${this.adapterName}:insufficient-data`,"Layer does not have required fields");b="json"===b;const h=a.createAggregateQuery();h.outSpatialReference=c?.spatialReference;h.returnGeometry=!!g;h.outFields=l;n.updateQueryWithFeatureFilter(h,k);({features:a}=b?await a.queryAggregateJSON(h,
{signal:d}):await a.queryAggregates(h,{signal:d}));return a.length&&null!=e&&0<e&&e<=a.length?C.pickRandom(a,e,1):a}load(a){const b=this.layer.load(a).then(async c=>{this.geometryType="polygon";this.objectIdField=null;this._hasLocalSource=this.supportsSQLExpression=!1;this.hasQueryEngine=!0;this.minScale=c.minScale;this.maxScale=c.maxScale;this.fullExtent=c.fullExtent;c="featureReduction"in c?c.featureReduction:null;if("binning"!==c?.type&&"cluster"!==c?.type)throw new p(`${this.adapterName}:invalid-parameters`,
`Feature reduction type ${c?.type} is not supported`);this.workerClient=I.WorkerClient.getInstance();await this.workerClient.open(a.signal)});this.addResolvingPromise(b);return Promise.resolve(this)}};return x=B.__decorate([E.subclass("esri.smartMapping.support.adapters.FeatureLayerBinningAdapter")],x)});