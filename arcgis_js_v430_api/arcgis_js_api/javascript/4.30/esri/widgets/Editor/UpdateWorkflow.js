// All material copyright Esri, All Rights Reserved, unless otherwise specified.
// See https://js.arcgis.com/4.30/esri/copyright.txt for details.
//>>built
define("../../chunks/tslib.es6 ../../Graphic ../../core/Error ../../core/handleUtils ../../core/Logger ../../core/maybe ../../core/promiseUtils ../../core/Queue ../../core/reactiveUtils ../../core/SetUtils ../../core/accessorSupport/decorators/property ../../core/has ../../core/RandomLCG ../../core/accessorSupport/decorators/subclass ../../layers/support/editableLayers ../../layers/support/layerUtils ../../views/draw/support/HighlightHelper ../../views/input/InputManager ../../views/interactive/sketch/SketchOptions ./CreateFeaturesWorkflow ./UpdateFeatureWorkflow ./UpdateRecordWorkflow ./UpdateWorkflowData ./Workflow ./workflowUtils ../Feature/support/featureUtils ../support/templateUtils".split(" "),
function(h,B,n,w,C,D,t,x,q,y,k,g,S,E,z,u,F,G,H,I,J,K,L,M,A,N,O){var v;g=v=class extends M{constructor(a){super(a);this._workflowStack=new x(y.last);this._sketchStack=new x(y.last);this.data=void 0;this.type="update"}get activeEditorItem(){return this.activeWorkflow?.data.editorItem??void 0}get activeFeatureFormViewModel(){return this.activeWorkflow?.featureFormViewModel}get activeSketchViewModel(){return this._sketchStack.peek()?.viewModel}get activeWorkflow(){return this._workflowStack.last()}get hasUpdatableCandidates(){const {candidates:a,
viewModel:b}=this.data;return a.some(({layer:c})=>b.findEditorItemForLayer(c)?.supportsUpdateWorkflow)}get nestedWorkflowCount(){return this._workflowStack.length}get shouldShowAttachments(){return!!this.activeEditorItem?.capabilities.attachments.enabled}get shouldAllowAttachmentEditing(){return!!this.activeEditorItem?.capabilities.update.attachments.enabled}get hasPendingEdits(){return Array.from(this._workflowStack).some(a=>a.hasPendingEdits)}get helpMessage(){return this.activeWorkflow?.helpMessage?
this.activeWorkflow.helpMessage:"awaiting-feature-to-update"===this.stepId?"select":void 0}get reliesOnOwnerAdminPrivileges(){return this.activeWorkflow?.reliesOnOwnerAdminPrivileges??!1}get hasInvalidFormTemplate(){return!!this.activeEditorItem?.hasInvalidFormTemplate}async back(a=()=>Promise.resolve(!0)){const {activeWorkflow:b}=this;if(null!=b?.featureFormViewModel.relationshipId)b.featureFormViewModel.relationshipId=null;else if(b){if(!b.hasPendingEdits||await a())b.hasPreviousStep?await b.previous({cancelCurrentStep:!0}):
await this.cancelActiveWorkflow({force:!0})}else this.hasPreviousStep?await this.previous({cancelCurrentStep:!0}):await this.cancel({force:!0})}async cancelActiveWorkflow(a){await this.activeWorkflow?.cancel(a);await this._popWorkflow()}async commit(){await this._drainWorkflowStack(a=>a.commit());await super.commit()}static create(a){const {viewModel:b,snappingManager:c,startAt:d,addAttachmentsCallback:e,applyEditsCallback:f}=a;a=a.sketchOptions??new H;a=new v({data:new L({addAttachmentsCallback:e,
applyEditsCallback:f,sketchOptions:a,snappingManager:c,viewModel:b}),onCommit:async()=>{}});a._set("steps",this._createWorkflowSteps(a,d));return a}async save(){1<this.nestedWorkflowCount?(await this.activeWorkflow?.commit(),await this._popWorkflow()):await this.commit()}async startCreatingRelatedRecord(a){try{const b=await this._createNestedCreateFeaturesWorkflow(a);await this._pushWorkflow(b)}catch(b){throw new n("editor:unable-to-start-creating","Could not begin updating the provided feature or table record.",
{error:b});}}async startUpdating(a){try{const b=await this._createNestedUpdateWorkflow(a);await this._pushWorkflow(b)}catch(b){throw new n("editor:unable-to-start-updating","Could not begin updating the provided feature or table record.",{error:b});}}async deleteActiveFeature(){const {activeWorkflow:a}=this;if(!a)throw new n("editor:nothing-to-delete","There is no feature to delete");a&&/update-/.test(a.type)?await a.deleteAndCommit():await a.cancel();1===this.nestedWorkflowCount?await this.reset():
await this._popWorkflow()}async cancelAll(){await this._drainWorkflowStack(a=>a.cancel({force:!0}))}async _createNestedCreateFeaturesWorkflow(a){const {relatedLayer:b}=a,{addAttachmentsCallback:c,applyEditsCallback:d,sketchOptions:e,snappingManager:f,viewModel:l}=this.data;if(!z.isEditableLayer(b))throw new n("editor:unsupported-layer","Editing is not supported on the provided layer");a=this._getCreationInfoForNestedCreateFeaturesWorkflow(a);return I.create({addAttachmentsCallback:c,applyEditsCallback:d,
creationInfo:a,isNested:!0,parent:"create-features"!==this.activeWorkflow?.type?this.activeWorkflow:void 0,sketchOptions:e,snappingManager:f,startAt:a.template||a.initialFeature?"creating-features":"awaiting-feature-creation-info",viewModel:l})}_getCreationInfoForNestedCreateFeaturesWorkflow(a){const {relatedLayer:b}=a;if(!z.isEditableLayer(b)||u.isSubtypeGroupLayer(b))throw new n("editor:unsupported-layer","Editing is not supported on the provided layer");const c={layer:b,maxFeatures:1};a=this._makeRelatedRecordAttributes(a);
const d=O.getAllTemplatesForLayer(b);0<d?.length?(c.attributeOverrides=a,1===d.length&&(c.template=d[0])):c.initialFeature=new B({sourceLayer:b,attributes:a});return c}async _createNestedUpdateWorkflow(a){const b=u.isTable(a.sourceLayer)?K.UpdateRecordWorkflow:J.UpdateFeatureWorkflow,{applyEditsCallback:c,sketchOptions:d,snappingManager:e,viewModel:f}=this.data,l=await b.create({feature:a,parent:"create-features"!==this.activeWorkflow?.type?this.activeWorkflow:void 0,sketchOptions:d,snappingManager:e,
viewModel:f,applyEdits:c,relatedRecordCallbacks:{addRelatedRecord:async m=>await this.startCreatingRelatedRecord(m),editRelatedRecord:async({relatedFeature:m})=>await this.startUpdating(m)}});await q.whenOnce(()=>!l.updating);return l}async _drainWorkflowStack(a){const b=this._workflowStack,c=[];for(;0<b.length;){const d=b.pop();this._sketchStack.pop();const e=a(d).then(()=>d.destroy());this._updatingHandles.addPromise(e);c.push(e)}await Promise.all(c)}_makeRelatedRecordAttributes(a){const {parentFeature:b,
relatedLayer:c,relationshipId:d}=a;if(N.isGraphicForRelatableFeatureSupportedLayer(b))if(a=c.relationships?.find(f=>f.id===d))if("origin"===a.role)r("unsupported-role","Creating new related records in the 'origin' table of a relationship is not yet supported");else{var e=b.sourceLayer;a.relatedTableId!==e.layerId&&r("invalid-argument-combination","The given parent feature does not belong to the relationship designated by the given relationship ID.");if(e=e.relationships?.find(f=>f.id===d))return(e=
b.getAttribute(e.keyField))||r("no-key-on-origin-feature","The given parent feature does not have a value for the relationship's origin primary key field."),{[a.keyField]:e};r("relationship-not-found","Could not begin creating a related record because the relationship specified could not be found on the origin layer.")}else r("relationship-not-found","Could not begin creating a related record because the relationship specified could not be found on the destination layer.")}async _popWorkflow(){this._workflowStack.pop()?.destroy();
this._sketchStack.pop();const a=await this._reconcileWorkflowStack();if(0<a.failureCount)throw new n("editor:next-workflow-failed","Popped the top workflow, but the next workflow in the stack failed to activate",a);}async _pushWorkflow(a){var b=this._workflowRequiresSketchViewModel(a);this.activeWorkflow?.exit({removeSketchHandles:b});b=this._sketchStack;const c=await a?.start(),d=b.peek();c?(d?.exit(),b.push(c)):b.push(this._cloneSketchController(d));this._workflowStack.push(a);a=await this._reconcileWorkflowStack();
if(0<a.failureCount)throw new n("editor:failed-to-start-updating-feature","Failed to enter the provided workflow.",a);}async _reconcileWorkflowStack(){const a=this._workflowStack,b=this._sketchStack;try{const c=a.peek();await c?.enter();await b.peek()?.enter();return{activeWorkflow:c,failureCount:0}}catch(c){a.pop().destroy();b.pop();const {activeWorkflow:d,failureCount:e}=await this._reconcileWorkflowStack();return{activeWorkflow:d,failureCount:e+1}}}_cloneSketchController(a){return{enter:a?.enter??
(async()=>{}),exit:a?.exit??(async()=>{}),viewModel:a?.viewModel}}_workflowRequiresSketchViewModel(a){const {type:b}=a;return"update-feature"===b||"create-features"===b&&!u.isTable(a.data.creationInfo?.layer)}static _createWorkflowSteps(a,b="awaiting-feature-to-update"){const {data:c}=a;return A.createWorkflowSteps(["awaiting-feature-to-update","awaiting-update-feature-candidate","editing-existing-feature","adding-attachment","editing-attachment"],b,{"awaiting-feature-to-update":()=>({id:"awaiting-feature-to-update",
async setUp(){const {spinnerViewModel:d}=c.viewModel,e=c.viewModel.view;let f=null;a.addHandles(w.makeHandle(()=>{f=D.abortMaybe(f)}),this.id);c.rootFeature=null;c.candidates=[];const l=e.on("immediate-click",async m=>{d.location=m.mapPoint;d.visible=!0;f?.abort();const {editorItems:P}=c.viewModel;f=new AbortController;const R=await m.async(()=>new Promise((p,Q)=>{t.onAbort(f?.signal,()=>Q(t.createAbortError()));p(A.fetchCandidates(P,e,m,f?.signal))}));t.throwIfAborted(f);c.candidates=R.filter(p=>
"fulfilled"===p.status).flatMap(p=>p.value).filter(p=>!p.isAggregate);d.visible=1===c.candidates.length;0!==c.candidates.length&&(m.stopPropagation(),1===c.candidates.length?(c.rootFeature=c.candidates[0],a.go("editing-existing-feature").catch(()=>{}).then(()=>d.visible=!1)):a.next())},G.ViewEventPriorities.TOOL);e.focus();a.addHandles(l,this.id)},async tearDown(){0===c.candidates.length&&(c.viewModel.spinnerViewModel.visible=!1);a.removeHandles(this.id)}}),"awaiting-update-feature-candidate":()=>
({id:"awaiting-update-feature-candidate",async setUp(){c.rootFeature=null;const {view:d}=c.viewModel;if(d){var e=new F({view:d});a.addHandles([q.watch(()=>c.rootFeature,(f,l)=>{e.remove(l);e.add(f)},q.sync),w.makeHandle(()=>e.removeAll())],this.id)}},async tearDown(){a.removeHandles(this.id)}}),"editing-existing-feature":()=>({id:"editing-existing-feature",async setUp(){const {rootFeature:d,viewModel:e}=a.data;if(!d)throw new n("editor:no-feature-specified","Cannot setup the 'updating-existing-feature' step until the root feature is defined");
await a.startUpdating(d);e.spinnerViewModel.visible=!1;const f=t.debounce(async()=>{await q.whenOnce(()=>!a.updating);a.previous()});a.addHandles([q.watch(()=>a.nestedWorkflowCount,(l,m)=>{0===l&&0!==m&&f()},q.sync)],this.id)},async tearDown(){await a.cancelAll();a.removeHandles(this.id)}}),"adding-attachment":()=>({id:"adding-attachment",parent:"editing-existing-feature",async setUp(){},async tearDown(){c.viewModel.attachmentsViewModel.mode="view"}}),"editing-attachment":()=>({id:"editing-attachment",
parent:"editing-existing-feature",async setUp(){},async tearDown(){c.viewModel.attachmentsViewModel.mode="view"}})})}};h.__decorate([k.property()],g.prototype,"activeEditorItem",null);h.__decorate([k.property()],g.prototype,"activeFeatureFormViewModel",null);h.__decorate([k.property()],g.prototype,"activeSketchViewModel",null);h.__decorate([k.property()],g.prototype,"activeWorkflow",null);h.__decorate([k.property()],g.prototype,"data",void 0);h.__decorate([k.property()],g.prototype,"hasUpdatableCandidates",
null);h.__decorate([k.property()],g.prototype,"nestedWorkflowCount",null);h.__decorate([k.property()],g.prototype,"shouldShowAttachments",null);h.__decorate([k.property()],g.prototype,"shouldAllowAttachmentEditing",null);h.__decorate([k.property()],g.prototype,"hasPendingEdits",null);h.__decorate([k.property()],g.prototype,"helpMessage",null);h.__decorate([k.property()],g.prototype,"reliesOnOwnerAdminPrivileges",null);h.__decorate([k.property()],g.prototype,"hasInvalidFormTemplate",null);g=v=h.__decorate([E.subclass("esri.widgets.Editor.UpdateWorkflow")],
g);const r=(a,b)=>C.getLogger("esri.widgets.Editor.UpdateWorkflow").warn(`editor:${a}`,b,"The create operation will be allowed to proceed, but the resulting feature may not be related to the given parent feature.");return g});