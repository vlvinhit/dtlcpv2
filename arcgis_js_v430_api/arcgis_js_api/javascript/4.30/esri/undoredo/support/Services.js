// All material copyright Esri, All Rights Reserved, unless otherwise specified.
// See https://js.arcgis.com/4.30/esri/copyright.txt for details.
//>>built
define("exports ../../chunks/tslib.es6 ../../kernel ../../core/Collection ../../core/Error ../../core/Evented ../../core/Loadable ../../core/Logger ../../core/MapUtils ../../core/Promise ../../core/promiseUtils ../../core/ReactiveMap ../../core/reactiveUtils ../../core/urlUtils ../../core/accessorSupport/decorators/property ../../core/has ../../core/RandomLCG ../../core/accessorSupport/decorators/subclass ../../core/support/UpdatingHandles ../../layers/support/arcgisLayerUrl ../../layers/support/layerUtils ../../portal/Portal ../../portal/support/utils ../../rest/featureService/FeatureService ./ServiceVersionInfo ../../versionManagement/VersionManagementService".split(" "),
function(g,k,x,m,f,y,z,n,A,B,r,C,p,t,l,M,N,D,E,F,u,v,G,H,I,J){function K(b){return!b||0===b.trim().length}const w=new Map;g.Services=class extends z.LoadableMixin(B.EsriPromiseMixin(y.EventedAccessor)){constructor(b){super(b);this._updatingHandles=new E.UpdatingHandles;this.items=new m;this.tablesAndLayersLookup=new C;this.additionalLayers=new m;this._debouncedCheckAndUpdateServiceInfos=r.debounce(async()=>{const c=[];for(const a of this.items)0!==a.layersAndTables.length&&a.layersAndTables.getItemAt(0).gdbVersion!==
a.versionInfo?.versionIdentifier.name&&c.push(a);0!==c.length&&(await p.whenOnce(()=>!this.updating),await this._updateVersionInfos(c))});this._debouncedLayersChanged=r.debounce(async()=>{const c=this._detectNewLayersAndTables();0!==c.length&&(await p.whenOnce(()=>!this.updating),await this._updatingHandles.addPromise((async()=>{for(const a of c)if("feature"===a.type||"subtype-group"===a.type){if(!a.url)continue;const d=F.parse(a.url).url.path,e=this._findServiceInfo(d);e?(this.tablesAndLayersLookup.set(a,
e),a.isTable?e.tables.push(a):e.layers.push(a)):await this._addServiceInfo(d,a)}})()))});this._processed=new Set}destroy(){this._set("view",null);this.items.removeAll();this.tablesAndLayersLookup.clear()}async load(b){r.throwIfAborted(b);this.addHandles([p.watch(()=>this._allLayersAndTables,()=>{this._debouncedLayersChanged().catch(c=>{n.getLogger(this).warn("Failed to update service info",c)})}),p.watch(()=>this.items.map(c=>c.layersAndTables.map(a=>a.gdbVersion??"").join(",")),()=>{void this.checkAndUpdateServiceInfos().catch(c=>
{n.getLogger(this).warn("Failed to update service info",c)})})]);this._debouncedLayersChanged();return this}get updating(){return"loading"===this.loadStatus||this._updatingHandles.updating}checkAndUpdateServiceInfos(){return this._debouncedCheckAndUpdateServiceInfos()}changeVersion(b,c,a){return this._updatingHandles.addPromise((async()=>{await this._changeVersionInternal(b,c,a)})())}createVersion(b){return this._updatingHandles.addPromise((async()=>{const c=b.featureServerUrl,a=this._findServiceInfo(c);
if(!a?.versionService)throw new f("services:no-version-management-service");var d=a.hasAdvancedEditingUserTypeExtension;const e=a.loggedInServiceUser.toUpperCase(),h=K(b.ownerName)?e:b.ownerName?.trim().toUpperCase();if(h!==e){if(11.1>=a.featureServiceVersion)throw new f("services:versioning-api-error");if(!d)throw new f("services:no-advanced-editing-user-type-extension");}if("SDE"===h?.toUpperCase()&&"DEFAULT"===b.versionName.toUpperCase())throw new f("services:no-valid-version-name");if((await a.versionService.getVersionInfos())?.find(q=>
q.versionIdentifier.name.toUpperCase()===(h+"."+b.versionName).toUpperCase()||q.versionIdentifier.name.toUpperCase()===(e+"."+b.versionName).toUpperCase()))throw new f("services:no-valid-version-name");d=await a.versionService.createVersion({versionName:b.versionName,access:h!==e?"public":b.access,description:b.description});if(h!==e){const {guid:q,name:L}=d.versionIdentifier;await a.versionService.alterVersion({guid:q,name:L},{ownerName:h,access:b.access})}b.switchToVersion&&await this._changeVersionInternal(c,
d.versionIdentifier.name,d.versionIdentifier.guid);this.emit("version-created",{versionIdentifier:d.versionIdentifier,versionManagementService:a.versionService})})())}deleteVersion(b,c,a){return this._updatingHandles.addPromise((async()=>{const d=this._findServiceInfo(b);if(!d?.versionService)throw new f("services:no-version-management-service");if(11.1>=d.featureServiceVersion)throw new f("services:versioning-api-error");if(!d.hasAdvancedEditingUserTypeExtension)throw new f("services:no-advanced-editing-user-type-extension");
const e={name:c,guid:a};await d.versionService.deleteVersion(e)&&(await this._updateVersionInfo(d),this.emit("version-deleted",{versionIdentifier:e,versionManagementService:d.versionService}))})())}startEditing(b){return this._updatingHandles.addPromise((async()=>{const c=this._findServiceInfo(b);if(!c?.versionService)throw new f("services:no-version-management-service");if(!c.hasAdvancedEditingUserTypeExtension)throw new f("services:no-advanced-editing-user-type-extension");const a=c.versionInfo?.versionIdentifier??
{name:c.versionService.defaultVersionIdentifier.name,guid:c.versionService.defaultVersionIdentifier.guid};let d=!0;if("none"===c.versionService.getLockType(a)&&(d=await c.versionService.startReading(a),!d))return;d=await c.versionService.startEditing(a);c.updateLockType()})())}finishEditing(b,c){return this._updatingHandles.addPromise((async()=>{const a=this._findServiceInfo(b);if(!a?.versionService)throw new f("services:no-version-management-service");if(!a.hasAdvancedEditingUserTypeExtension)throw new f("services:no-advanced-editing-user-type-extension");
const d=a.versionInfo?.versionIdentifier??{name:a.versionService.defaultVersionIdentifier.name,guid:a.versionService.defaultVersionIdentifier.guid},e=a.versionService.getLockType(d);"none"!==e&&("read"===e?(await a.versionService.stopReading(d),a.updateLockType()):"edit"===e&&(await a.versionService.stopEditing(d,c),await a.versionService.stopReading(d),a.updateLockType()))})())}async _changeVersionInternal(b,c,a){b=this._findServiceInfo(b);if(!b?.versionService)throw new f("services:no-version-management-service");
await b.versionService.changeVersion(this.view?.map,b.versionInfo?.versionIdentifier??{name:b.versionService.defaultVersionIdentifier.name,guid:b.versionService.defaultVersionIdentifier.guid},{name:c,guid:a})&&await this._updateVersionInfo(b)}async _updateVersionInfo(b){const c=b.versionService;if(c&&0!==b.layersAndTables.length){var a=b.layersAndTables.getItemAt(0).gdbVersion;a=a?await c.getVersionIdentifierFromName(a):c.defaultVersionIdentifier;b.versionInfo=await c.getVersionInfoExtended(a)}}_findServiceInfo(b){return this.items.find(c=>
c.featureService.url===b)??null}_removeFeatureService(b){this.items.remove(b)}async _findPortal(b){b=x.id?.findServerInfo(b??"");if(!b?.owningSystemUrl)return null;const c=`${b.owningSystemUrl}/sharing/rest`,a=v.getDefault();return a?.loaded&&t.normalize(a.restUrl)===t.normalize(c)?a:(new v({authMode:"immediate",url:b.owningSystemUrl})).load()}_updateVersionInfos(b){return this._updatingHandles.addPromise((async()=>{for(const c of b)await this._updateVersionInfo(c).catch(a=>{n.getLogger(this).error("Failed to update version details",
a)})})())}async _addServiceInfo(b,c){var a=new H({url:b});await a.load();var d=await this._findPortal(b);b=d?.user?.username;let e=!1;b&&(e=await G.hasUserTypeExtension(d,b,"advediting"));d=null;a.versionManagementServiceUrl&&(d=new J({url:a.versionManagementServiceUrl}),await d.load());const h=c.isTable?[c]:[];a=new I.ServiceVersionInfo({loggedInServiceUser:b??"",hasAdvancedEditingUserTypeExtension:e,versionInfo:null,lockType:"none",canEditVersionedData:!0,canCreateVersion:!0,featureService:a,versionService:d,
layers:new m(c.isTable?[]:[c]),tables:new m(h)});d&&await this._updateVersionInfo(a);this.items.push(a);this.tablesAndLayersLookup.set(c,a);c.isTable?a.tables.push(c):a.layers.push(c);return a}get _allLayersAndTables(){return[...this.view.map.allLayers,...this.view.map.allTables,...this.additionalLayers]}_detectNewLayersAndTables(){const b=new Set(this._allLayersAndTables),c=[];for(var a of b)if("feature"===a.type||"subtype-group"===a.type)this._processed.has(a)||c.push(a);for(const d of this._processed)!b.has(d)&&
(u.isSubtypeGroupLayer(d)||u.isFeatureLayer(d))&&(a=this.tablesAndLayersLookup.get(d))&&(this.tablesAndLayersLookup.delete(d),d.isTable?a.tables.remove(d):a.layers.remove(d),0===a.layersAndTables.length&&this._removeFeatureService(a));this._processed=b;return c}};k.__decorate([l.property({constructOnly:!0})],g.Services.prototype,"view",void 0);k.__decorate([l.property()],g.Services.prototype,"items",void 0);k.__decorate([l.property()],g.Services.prototype,"tablesAndLayersLookup",void 0);k.__decorate([l.property()],
g.Services.prototype,"additionalLayers",void 0);k.__decorate([l.property()],g.Services.prototype,"updating",null);k.__decorate([l.property()],g.Services.prototype,"_allLayersAndTables",null);g.Services=k.__decorate([D.subclass("esri.undoredo.support.Services")],g.Services);g.getServices=function(b){return A.getOrCreateMapValue(w,b,()=>{const c=new g.Services({view:b});b.addHandles({remove(){w.delete(b);c.destroy()}});void c.load().catch(a=>{n.getLogger("esri.views.Services").error("Failed to load service metadata",
a)});return c})};Object.defineProperty(g,Symbol.toStringTag,{value:"Module"})});