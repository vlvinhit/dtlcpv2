// All material copyright Esri, All Rights Reserved, unless otherwise specified.
// See https://js.arcgis.com/4.30/esri/copyright.txt for details.
//>>built
define("require ../../../chunks/tslib.es6 ../../../config ../../../geometry ../../../request ../../../TimeExtent ../../../core/arrayUtils ../../../core/Error ../../../core/has ../../../core/jsonMap ../../../core/Loadable ../../../core/Logger ../../../core/object ../../../core/promiseUtils ../../../core/reactiveUtils ../../../core/urlUtils ../../../core/uuid ../../../core/accessorSupport/decorators/property ../../../core/accessorSupport/decorators/subclass ../../../geometry/Extent ../../../geometry/support/MeshGeoreferencedVertexSpace ../../../geometry/support/meshVertexSpaceUtils ../../../geometry/support/meshUtils/External ../applyEditsUtils ./support/clientSideDefaults ./support/QueryTask ../../support/arcgisLayerUrl ../../support/featureLayerUtils ../../support/infoFor3D ../../../rest/query/executeQueryJSON ../../../rest/query/operations/editsZScale ../../../rest/support/Query ../../../versionManagement/support/versionManagementUtils ../../../geometry/SpatialReference".split(" "),
function(E,w,F,t,l,J,x,v,G,H,K,I,L,B,M,C,N,y,O,P,Q,R,S,q,T,U,V,z,W,X,Y,Z,A,aa){const ba=new H.JSONMap({originalAndCurrentFeatures:"original-and-current-features",none:"none"}),ca=new H.JSONMap({Started:"published",Publishing:"publishing",Stopped:"unavailable"});t=class extends K{constructor(a){super(a);this.type="feature-layer";this.supportedSourceTypes=new Set(["Feature Layer","Oriented Imagery Layer","Table","Catalog Layer"]);this.refresh=B.debounce(async()=>{await this.load();var b=this.sourceJSON.editingInfo?.lastEditDate;
if(null==b)return{dataChanged:!0,updates:{}};try{await this._fetchService(null)}catch{return{dataChanged:!0,updates:{}}}b=b!==this.sourceJSON.editingInfo?.lastEditDate;return{dataChanged:b,updates:b?{editingInfo:this.sourceJSON.editingInfo,extent:this.sourceJSON.extent}:null}});this._ongoingAssetUploads=new Map}load(a){const b=this._fetchService(this.layer.sourceJSON,{...a}).then(()=>this.layer.setUserPrivileges(this.sourceJSON.serviceItemId,a)).then(()=>this._ensureLatestMetadata(a));this.addResolvingPromise(b);
return Promise.resolve(this)}initialize(){this.addHandles([M.watch(()=>{const a=this.layer;return a&&"lastEditsEventDate"in a?a.lastEditsEventDate:null},a=>this._handleLastEditsEventChange(a))])}destroy(){this._removeEditInterceptor()}get queryTask(){const {capabilities:a,parsedUrl:b,gdbVersion:c,spatialReference:e,fieldsIndex:d}=this.layer,f="infoFor3D"in this.layer?this.layer.infoFor3D:null,g="dynamicDataSource"in this.layer?this.layer.dynamicDataSource:null,h=G("featurelayer-pbf")&&a?.query.supportsFormatPBF&&
null==f;return new U({url:b.path,pbfSupported:h,fieldsIndex:d,infoFor3D:f,dynamicDataSource:g,gdbVersion:c,sourceSpatialReference:e,queryAttachmentsSupported:a?.operations?.supportsQueryAttachments??!1})}async addAttachment(a,b){await this.load();var {layer:c}=this;await z.ensureLayerCredential(c,"editing");a=a.attributes[c.objectIdField];c=c.parsedUrl.path+"/"+a+"/addAttachment";const e=this._getLayerRequestOptions();b=this._getFormDataForAttachment(b,e.query);try{const d=await l(c,{body:b});return q.createFeatureEditResult(d.data.addAttachmentResult)}catch(d){throw this._createAttachmentErrorResult(a,
d);}}async updateAttachment(a,b,c){await this.load();var {layer:e}=this;await z.ensureLayerCredential(e,"editing");a=a.attributes[e.objectIdField];e=e.parsedUrl.path+"/"+a+"/updateAttachment";b=this._getLayerRequestOptions({query:{attachmentId:b}});c=this._getFormDataForAttachment(c,b.query);try{const d=await l(e,{body:c});return q.createFeatureEditResult(d.data.updateAttachmentResult)}catch(d){throw this._createAttachmentErrorResult(a,d);}}async applyEdits(a,b){await this.load();const {layer:c}=
this;await z.ensureLayerCredential(c,"editing");const e="infoFor3D"in c?c.infoFor3D:null;var d=null!=e,f=d||(b?.globalIdUsed??!1);const g=d?await this._uploadMeshesAndGetAssetMapEditsJSON(a):null;var h=a.addFeatures?.map(r=>q.getFeatureJSON(this.layer,r,e))??[];h=(await Promise.all(h)).filter(x.isSome);var m=a.updateFeatures?.map(r=>q.getFeatureJSON(this.layer,r,e))??[];m=(await Promise.all(m)).filter(x.isSome);const k=q.getFeatureIds(this.layer,a.deleteFeatures,f);Y.unapplyEditsZUnitScaling(h,m,
c.spatialReference);a=await q.getAttachmentEditsJSON(this.layer,a);d=c.capabilities.editing.supportsAsyncApplyEdits&&d;const u=b?.gdbVersion||c.gdbVersion,n={gdbVersion:u,rollbackOnFailure:b?.rollbackOnFailureEnabled,useGlobalIds:f,returnEditMoment:b?.returnEditMoment,usePreviousEditMoment:b?.usePreviousEditMoment,async:d};await A.isSafeToEditVersion(this.layer.url,u,!0);const D=A.isVersionInEditSession(this.layer.url,u||null);if(await A.isHistoricVersion(c.url,u,c.historicMoment))throw new v("feature-layer-source:historic-version",
"Editing a historic version is not allowed");b?.returnServiceEditsOption?(n.edits=JSON.stringify([{id:c.layerId,adds:h.length?h:null,updates:m.length?m:null,deletes:k.length?k:null,attachments:a,assetMaps:g}]),n.returnServiceEditsOption=ba.toJSON(b?.returnServiceEditsOption),n.returnServiceEditsInSourceSR=b?.returnServiceEditsInSourceSR):(n.adds=h.length?JSON.stringify(h):null,n.updates=m.length?JSON.stringify(m):null,n.deletes=k.length?f?JSON.stringify(k):k.join(","):null,n.attachments=a&&JSON.stringify(a),
n.assetMaps=null!=g?JSON.stringify(g):void 0);f=this._getLayerRequestOptions({method:"post",query:n});D&&(f.authMode="immediate",f.query.returnEditMoment=!0,f.query.sessionId=A.currentSessionId);b=b?.returnServiceEditsOption?c.url:c.parsedUrl.path;let p;try{p=d?await this._asyncApplyEdits(b+"/applyEdits",f):await l(b+"/applyEdits",f)}catch(r){if(q.isProtectedOrPrivateVersionError(r))f.authMode="immediate",p=d?await this._asyncApplyEdits(b+"/applyEdits",f):await l(b+"/applyEdits",f);else throw r;}return this._createEditsResult(p)}async deleteAttachments(a,
b){await this.load();var {layer:c}=this;await z.ensureLayerCredential(c,"editing");a=a.attributes[c.objectIdField];c=c.parsedUrl.path+"/"+a+"/deleteAttachments";try{return(await l(c,this._getLayerRequestOptions({query:{attachmentIds:b.join(",")},method:"post"}))).data.deleteAttachmentResults.map(q.createFeatureEditResult)}catch(e){throw this._createAttachmentErrorResult(a,e);}}fetchRecomputedExtents(a={}){return this.load({signal:a.signal}).then(async()=>{var b=this._getLayerRequestOptions({...a,
query:{returnUpdates:!0}});const {layerId:c,url:e}=this.layer;({data:b}=await l(`${e}/${c}`,b));const {id:d,extent:f,fullExtent:g,timeExtent:h}=b;b=f||g;return{id:d,fullExtent:b&&P.fromJSON(b),timeExtent:h&&J.fromJSON({start:h[0],end:h[1]})}})}async queryAttachments(a,b={}){await this.load();b=this._getLayerRequestOptions(b);return this.queryTask.executeAttachmentQuery(a,b)}async queryFeatures(a,b){await this.load();b=await this.queryTask.execute(a,{...b,query:this._createRequestQueryOptions(b)});
a.outStatistics?.length&&b.features.length&&b.features.forEach(c=>{const e=c.attributes;a.outStatistics?.forEach(({outStatisticFieldName:d})=>{if(d){const f=d.toLowerCase();f&&f in e&&d!==f&&(e[d]=e[f],delete e[f])}})});return b}async queryFeaturesJSON(a,b){await this.load();return this.queryTask.executeJSON(a,{...b,query:this._createRequestQueryOptions(b)})}async queryObjectIds(a,b){await this.load();return this.queryTask.executeForIds(a,{...b,query:this._createRequestQueryOptions(b)})}async queryFeatureCount(a,
b){await this.load();return this.queryTask.executeForCount(a,{...b,query:this._createRequestQueryOptions(b)})}async queryExtent(a,b){await this.load();return this.queryTask.executeForExtent(a,{...b,query:this._createRequestQueryOptions(b)})}async queryRelatedFeatures(a,b){await this.load();return this.queryTask.executeRelationshipQuery(a,{...b,query:this._createRequestQueryOptions(b)})}async queryRelatedFeaturesCount(a,b){await this.load();return this.queryTask.executeRelationshipQueryForCount(a,
{...b,query:this._createRequestQueryOptions(b)})}async queryTopFeatures(a,b){await this.load();return this.queryTask.executeTopFeaturesQuery(a,{...b,query:this._createRequestQueryOptions(b)})}async queryTopObjectIds(a,b){await this.load();return this.queryTask.executeForTopIds(a,{...b,query:this._createRequestQueryOptions(b)})}async queryTopExtents(a,b){await this.load();return this.queryTask.executeForTopExtents(a,{...b,query:this._createRequestQueryOptions(b)})}async queryTopCount(a,b){await this.load();
return this.queryTask.executeForTopCount(a,{...b,query:this._createRequestQueryOptions(b)})}async fetchPublishingStatus(){if(!V.isHostedAgolService(this.layer.url))return"unavailable";var a=C.join(this.layer.url,"status");a=await l(a,{query:{f:"json"}});return ca.fromJSON(a.data.status)}async uploadAssets(a,b){const {uploadAssets:c}=await new Promise((e,d)=>E(["./support/uploadAssets"],e,d));return c(a,{layer:this.layer,ongoingUploads:this._ongoingAssetUploads},b)}_handleLastEditsEventChange(a){const b=
this.layer;if(null!=a&&"capabilities"in b&&"effectiveCapabilities"in b&&!b.capabilities?.operations?.supportsEditing&&b.effectiveCapabilities?.operations?.supportsEditing){var c=b.url;null!=c&&("layerId"in b&&C.join(c,b.layerId.toString()),this._getOrCreateEditInterceptor(c).before=e=>{var d=e.requestOptions.method??"auto";if("auto"===d||"head"===d)d=e.requestOptions.query??{},d._ts=a.getTime(),e.requestOptions.query=d})}}_getOrCreateEditInterceptor(a){null==this._editInterceptor&&(this._editInterceptor=
{urls:a},F.request.internalInterceptors.push(this._editInterceptor));return this._editInterceptor}_removeEditInterceptor(){null!=this._editInterceptor&&(x.remove(F.request.internalInterceptors,this._editInterceptor),this._editInterceptor=null)}async _asyncApplyEdits(a,b){for(a=(await l(a,b)).data.statusUrl;;){b=(await l(a,{query:{f:"json"},responseType:"json"})).data;switch(b.status){case "Completed":return l(b.resultUrl,{query:{f:"json"},responseType:"json"});case "CompletedWithErrors":throw new v("async-applyEdits-failed",
"asynchronous applyEdits call failed.");case "Failed ImportChanges":case "InProgress":case "Pending":case "ExportAttachments":case "ExportChanges":case "ExportingData":case "ExportingSnapshot":case "ImportAttachments":case "ProvisioningReplica":case "UnRegisteringReplica":break;default:throw new v("async-applyEdits-failed","asynchronous applyEdits call failed (undefined response status)");}await B.after(1E3)}}_createRequestQueryOptions(a){a={...this.layer.customParameters,token:this.layer.apiKey,
...a?.query};this.layer.datesInUnknownTimezone&&(a.timeReferenceUnknownClient=!0);return a}async _fetchService(a,b){a||(a={},G("featurelayer-advanced-symbols")&&(a.returnAdvancedSymbols=!0),b?.cacheBust&&(a._ts=Date.now()),{data:a}=await l(this.layer.parsedUrl.path,this._getLayerRequestOptions({query:a,signal:b?.signal})));this.sourceJSON=await this._patchServiceJSON(a,b?.signal);b=a.type;if(!this.supportedSourceTypes.has(b))throw new v("feature-layer-source:unsupported-type",`Source type "${b}" is not supported`);
}async _patchServiceJSON(a,b){if("Table"!==a.type&&a.geometryType&&!a?.drawingInfo?.renderer&&!a.defaultSymbol){const c=T.createDrawingInfo(a.geometryType).renderer;L.setDeepValue("drawingInfo.renderer",c,a)}"esriGeometryMultiPatch"===a.geometryType&&a.infoFor3D&&(a.geometryType="mesh");if(null==a.extent)try{const {data:c}=await l(this.layer.url,this._getLayerRequestOptions({signal:b}));c.spatialReference&&(a.extent={xmin:0,ymin:0,xmax:0,ymax:0,spatialReference:c.spatialReference})}catch(c){B.throwIfAbortError(c)}return a}async _ensureLatestMetadata(a){if(this.layer.userHasUpdateItemPrivileges&&
0<this.sourceJSON.cacheMaxAge)return this._fetchService(null,{...a,cacheBust:!0})}async _uploadMeshesAndGetAssetMapEditsJSON(a){const {addAssetFeatures:b}=a;if(!b?.length||await this._areAllAssetsAlreadyMapped(b))return null;var c=a.addFeatures.filter(d=>d.geometry);if(b.length!==c.length+a.updateFeatures.length)throw new v("feature-layer-source:unsupported-mesh-edits","Mixing attribute only edits with mesh geometry edits is not currently supported");a=[];c=new Map;for(const d of b){const {geometry:f}=
d;var {vertexSpace:e}=f;if(R.isRelativeVertexSpace(e))a.push(f);else{e=f.anchor;const {convertMeshVertexSpace:g}=await new Promise((h,m)=>E(["../../../geometry/support/meshUtils/convertMeshVertexSpace"],h,m));e=await g(f,new Q({origin:[e.x,e.y,e.z??0]}));c.set(e,f);d.geometry=e;a.push(e)}}await this.uploadAssets(a);for(const [d,f]of c)f.addExternalSources(d.metadata.externalSources.items);return{adds:this._getAssetMapEditsJSON(b),updates:[],deletes:[]}}_getAssetMapEditsJSON(a){const b=[],c=this.layer.globalIdField,
e=this.layer.parsedUrl;for(const f of a){({metadata:a}=f.geometry);var d=a.getExternalSourcesOnService(e);a=f.getAttribute(c);if(0===d.length)I.getLogger(this).error(`Skipping feature ${a}. The mesh it is associated with has not been uploaded to the service and cannot be mapped to it.`);else{({source:d}=d.find(S.isOriginalExternal)??d[0]);for(const g of d)1!==g.parts.length?I.getLogger(this).error(`Skipping asset ${g.assetName}. It does not have exactly one part, so we cannot map it to a feature.`):
b.push({globalId:N.generateBracedUUID(),parentGlobalId:a,assetName:g.assetName,assetHash:g.parts[0].partHash,flags:[]})}}return b}_createEditsResult(a){var b=a.data;const {layerId:c}=this.layer;a=[];let e=null;if(Array.isArray(b))for(var d of b)a.push({id:d.id,editedFeatures:d.editedFeatures}),d.id===c&&(e={addResults:d.addResults??[],updateResults:d.updateResults??[],deleteResults:d.deleteResults??[],attachments:d.attachments,editMoment:d.editMoment});else e=b;d=q.unpackEditResultData(e);if(0<a.length){d.editedFeatureResults=
[];for(const f of a)({editedFeatures:a}=f),b=a?.spatialReference?new aa(a.spatialReference):null,d.editedFeatureResults.push({layerId:f.id,editedFeatures:q.createEditedFeatures(a,b)})}return d}_createAttachmentErrorResult(a,b){return{objectId:a,globalId:null,error:new v("feature-layer-source:attachment-failure",b.details.messages?.[0]||b.message,{code:b.details.httpStatus||b.details.messageCode})}}_getFormDataForAttachment(a,b){if(a=a instanceof FormData?a:a&&a.elements?new FormData(a):null)for(const c in b){const e=
b[c];null!=e&&(a.set?a.set(c,e):a.append(c,e))}return a}_getLayerRequestOptions(a={}){const {layer:b,layer:{parsedUrl:c,gdbVersion:e}}=this;return{...a,query:{gdbVersion:e,layer:"dynamicDataSource"in b&&b.dynamicDataSource?JSON.stringify({source:b.dynamicDataSource}):void 0,...c.query,f:"json",...this._createRequestQueryOptions(a)},responseType:"json"}}async _areAllAssetsAlreadyMapped(a){var {layer:b}=this;const {globalIdField:c,parsedUrl:e}=b,d="infoFor3D"in b?b.infoFor3D:null;if(null==d||null==
c)return!1;b=W.getAssetMapTable(d);if(null==b)return!1;const f=C.join(e.path,`../${b.id}`);b=[];for(const k of a)if(0<k.geometry.metadata.getExternalSourcesOnService(e).length)b.push(k);else return!1;a=b.map(k=>k.getAttribute(c)).filter(x.isSome);if(0===a.length)return!1;const {assetMapFieldRoles:{parentGlobalId:g,assetHash:h}}=d;a=new Z({where:`${g} IN (${a.map(k=>`'${k}'`)})`,outFields:[h,g],returnGeometry:!1});a=await X.executeQueryJSON(f,a);const {features:m}=a;return 0===m.length?!1:!b.some(k=>
{const u=k.getAttribute(c);if(!u)return!0;({metadata:k}=k.geometry);const n=m.filter(p=>p.getAttribute(g)===u);if(0===n.length)return!0;const D=n.map(p=>p.getAttribute(h));return k.getExternalSourcesOnService(e).flatMap(({source:p})=>p.flatMap(r=>r.parts.map(da=>da.partHash))).some(p=>D.every(r=>p!==r))})}};w.__decorate([y.property()],t.prototype,"type",void 0);w.__decorate([y.property({constructOnly:!0})],t.prototype,"layer",void 0);w.__decorate([y.property({constructOnly:!0})],t.prototype,"supportedSourceTypes",
void 0);w.__decorate([y.property({readOnly:!0})],t.prototype,"queryTask",null);return t=w.__decorate([O.subclass("esri.layers.graphics.sources.FeatureLayerSource")],t)});