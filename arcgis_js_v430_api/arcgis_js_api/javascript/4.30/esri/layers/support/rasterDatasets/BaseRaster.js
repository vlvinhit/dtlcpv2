// All material copyright Esri, All Rights Reserved, unless otherwise specified.
// See https://js.arcgis.com/4.30/esri/copyright.txt for details.
//>>built
define("../../../chunks/tslib.es6 ../../../geometry ../../../request ../../../core/Error ../../../core/JSONSupport ../../../core/Logger ../../../core/Promise ../../../core/promiseUtils ../../../core/accessorSupport/decorators/property ../../../core/accessorSupport/ensureType ../../../core/RandomLCG ../../../core/has ../../../core/accessorSupport/decorators/subclass ../arcgisLayerUrl ../commonProperties ../DimensionalDefinition ../LOD ../RasterStorageInfo ../TileInfo ./multidimensionalUtils ./RawBlockCache ../rasterFormats/pixelRangeUtils ../rasterFormats/RasterCodec ../rasterFunctions/pixelUtils ../rasterFunctions/rasterProjectionHelper ../rasterFunctions/vectorFieldUtils ../../../views/support/QueueProcessor ../../../geometry/Extent ../../../geometry/Point ../../../geometry/SpatialReference".split(" "),
function(y,w,W,R,X,Y,Z,aa,A,ba,pa,qa,ca,da,ea,fa,ha,ia,S,L,D,ja,ka,I,v,T,la,H,E,ma){let na=0;w=class extends Z.EsriPromiseMixin(X.JSONSupport){constructor(){super(...arguments);this._tileFetchQueue=new la.QueueProcessor({concurrency:32,process:(a,b)=>this._fetchRawTile(a.pyramidLevel,a.row,a.col,{...a.options,signal:b})});this.datasetFormat=this.datasetName=null;this.hasUniqueSourceStorageInfo=!0;this.rasterInfo=null;this.ioConfig={sampling:"closest"}}async init(){const a=v.load();this.addResolvingPromise(a);
await this.when()}normalizeCtorArgs(a){a?.ioConfig&&(a={...a,ioConfig:{resolution:null,bandIds:null,sampling:"closest",tileInfo:S.create(),...a.ioConfig}});return a}get _isGlobalWrappableSource(){const {rasterInfo:a}=this,b=v.getWorldWidth(a.spatialReference);return null!=b&&a.extent.width>=b/2}get _hasNoneOrGCSShiftTransform(){const {transform:a}=this.rasterInfo;return null==a||"gcs-shift"===a.type}set rasterJobHandler(a){this._set("rasterJobHandler",a);"Function"===this.datasetFormat&&this.primaryRasters?.rasters?.forEach(b=>
b.rasterJobHandler=a)}get rasterId(){return this.url||`rasterId-${na++}`}set url(a){this._set("url",da.sanitizeUrl(a,Y.getLogger(this)))}async open(a){throw new R("BaseRaster:open-not-implemented","open() is not implemented");}async fetchTile(a,b,d,c={}){const e=c.tileInfo||this.rasterInfo.storageInfo.tileInfo;a=this.getTileExtentFromTileInfo(a,b,d,e);c={noClip:!0,...c};return this.fetchPixels(a,e.size[0],e.size[1],c)}async identify(a,b={}){a=ba.ensureClass(E,a).clone().normalize();const {multidimensionalDefinition:d,
timeExtent:c}=b;var {rasterInfo:e}=this;const {hasMultidimensionalTranspose:g,multidimensionalInfo:k}=e;var {transposedVariableName:f}=b,l=null!=k&&g&&(null!=c||L.isMultiSliceOrRangeDefinition(d));l&&!f&&(f=null!=d&&0<d.length?d[0].variableName??void 0:k.variables[0].name,b={...b,transposedVariableName:f});b=this._getRequestOptionsWithSliceId(b);const {spatialReference:h,extent:n}=e;var {datumTransformation:p}=b;p=v.projectPoint(a,h,p);if(!n.intersects(p)||null!=e.transform&&(p=e.transform.inverseTransform(p),
!e.nativeExtent.intersects(p)))return{location:p,value:null};var q=0,r=null!=f&&null!=k&&e.hasMultidimensionalTranspose;if("Function"===this.datasetFormat){l=this.primaryRasters.rasters[0];if(r)return l.identify(p,b);({pixelSize:q}=e);r=3*q.x/2;q=3*q.y/2;r=new H({xmin:p.x-r,xmax:p.x+r,ymin:p.y-q,ymax:p.y+q,spatialReference:h});b={interpolation:"nearest",multidimensionalDefinition:d,sliceId:b.sliceId};({pixelBlock:l}=await l.fetchPixels(r,3,3,b));({pixelBlock:b}=await this.fetchPixels(r,3,3,b));if(null==
l)return{location:p,value:null};l=!l.mask||l.mask[4]?l.pixels.map(B=>B[4]):null;var m;null!=b&&(m=!b.mask||b.mask[4]?b.pixels.map(B=>B[4]):void 0);return{location:p,value:l,processedValue:m,pyramidLevel:0}}if(!r)if(b.srcResolution)q=v.snapPyramid(b.srcResolution,e,this.ioConfig.sampling).pyramidLevel;else if(q=await this.computeBestPyramidLevelForLocation(a,b),null==q)return{location:p,value:null};m=this.identifyPixelLocation(p,q,null,r);if(null===m)return{location:p,value:null};const {row:t,col:u,
rowOffset:x,colOffset:z,blockWidth:F}=m;m=D.getRasterId(this.rasterId,f??b.sliceId);e=`${q}/${t}/${u}`;f=D.getBlock(m,null,e);null==f&&(f=this.fetchRawTile(q,t,u,b),D.putBlock(m,null,e,f));m=await f;return m?.pixels?.length?this._processIdentifyResult(m,{srcLocation:p,position:x*F+z,pyramidLevel:q,useTransposedTile:!!r,requestSomeSlices:l,identifyOptions:b}):{location:p,value:null}}async fetchPixels(a,b,d,c={}){a=v.shiftExtent(a);c=this._getRequestOptionsWithSliceId(c);var {_hasNoneOrGCSShiftTransform:e}=
this;if(c.requestRawData&&e)return this._fetchPixels(a,b,d,c);var g=v.getWorldWidth(a.spatialReference),k=v.getWorldWrapCount(a);if(null==g||0===k||1===k&&this._isGlobalWrappableSource&&e)return this._fetchPixels(a,b,d,c);if(3<=k)return{extent:a,pixelBlock:null};const f=[],{xmin:l,xmax:h}=a,n=Math.round(g/(h-l)*b),p=n-Math.round((g/2-l)/(h-l)*b);let q=0;e=[];for(let m=0;m<=k;m++){var r=new H({xmin:0===m?l:-g/2,xmax:m===k?h-g*m:g/2,ymin:a.ymin,ymax:a.ymax,spatialReference:a.spatialReference});const t=
0===m?n-p:m===k?b-q:n;q+=t;e.push(t);r=c.disableWrapAround&&0<m?null:this._fetchPixels(r,t,d,c);f.push(r)}g=(await Promise.all(f)).map(m=>m?.pixelBlock);k=null;b={width:b,height:d};k=this.rasterJobHandler?(await this.rasterJobHandler.mosaicAndTransform({srcPixelBlocks:g,srcMosaicSize:b,destDimension:null,coefs:null,sampleSpacing:null,interpolation:"nearest",alignmentInfo:null,blockWidths:e},c)).pixelBlock:I.mosaic(g,b,{blockWidths:e});c=v.projectExtent(a,this.rasterInfo.spatialReference,c.datumTransformation);
return{extent:a,srcExtent:c,pixelBlock:k}}async fetchRawPixels(a,b,d,c={}){b={x:Math.floor(b.x),y:Math.floor(b.y)};const e=await this._fetchRawTiles(a,b,d,c),{nativeExtent:g,nativePixelSize:k,storageInfo:f}=this.rasterInfo;var l=2**a,h=k.x*l;l*=k.y;h=new H({xmin:g.xmin+h*b.x,xmax:g.xmin+h*(b.x+d.width-1),ymin:g.ymax-l*(b.y+d.height-1),ymax:g.ymax-l*b.y,spatialReference:g.spatialReference});if(!e)return{extent:h,srcExtent:h,pixelBlock:null};const {pixelBlocks:n,mosaicSize:p}=e;if(1===n.length&&null!=
n[0]&&n[0].width===d.width&&n[0].height===d.height)return{extent:h,srcExtent:h,pixelBlock:e.pixelBlocks[0]};a={x:b.x%(0<a?f.pyramidBlockWidth:f.blockWidth),y:b.y%(0<a?f.pyramidBlockHeight:f.blockHeight)};d=this.rasterJobHandler?(await this.rasterJobHandler.mosaicAndTransform({srcPixelBlocks:n,srcMosaicSize:p,destDimension:d,clipOffset:a,clipSize:d,coefs:null,sampleSpacing:null,interpolation:c.interpolation,alignmentInfo:null,blockWidths:null},c)).pixelBlock:I.mosaic(n,p,{clipOffset:a,clipSize:d});
return{extent:h,srcExtent:h,pixelBlock:d}}fetchRawTile(a,b,d,c){throw new R("BaseRaster:read-not-implemented","fetchRawTile() is not implemented");}computeExtent(a){return v.projectExtent(this.rasterInfo.extent,a)}decodePixelBlock(a,b){return!this.rasterJobHandler||b.useCanvas?ka.decode(a,b):this.rasterJobHandler.decode({data:a,options:b})}async request(a,b,d=0){const {customFetchParameters:c}=this.ioConfig,{range:e,query:g,headers:k}=b;d=d??b.retryCount??this.ioConfig.retryCount;const f=e?{Range:`bytes=${e.from}-${e.to}`}:
null;try{return await W(a,{...b,query:{...g,...c},headers:{...k,...f}})}catch(l){if(0<d)return d--,this.request(a,b,d);throw l;}}getSliceIndex(a){const {multidimensionalInfo:b}=this.rasterInfo;return null==b||null==a||0===a.length?null:L.getSliceIndex(a,b)}getTileExtentFromTileInfo(a,b,d,c){a=c.lodAt(a);return this.getTileExtent({x:a.resolution,y:a.resolution},b,d,c.origin,c.spatialReference,c.size)}updateTileInfo(){const {storageInfo:a,spatialReference:b,extent:d,pixelSize:c}=this.rasterInfo;var {pyramidResolutions:e}=
a;if(!a.tileInfo){const g=[],k=a.maximumPyramidLevel||0;let f=(c.x+c.y)/2,l=1/.0254*96*f;for(let h=0;h<=k;h++){g.unshift(new ha({level:k-h,resolution:f,scale:l}));if(h===k)break;if(e){const n=(e[h].x+e[h].y)/2;l*=n/f;f=n}else f*=2,l*=2}e=new E({x:d.xmin,y:d.ymax,spatialReference:b});a.tileInfo=new S({origin:e,size:[a.blockWidth,a.blockHeight],spatialReference:b,lods:g});a.isVirtualTileInfo=!0}}createRemoteDatasetStorageInfo(a,b=512,d=512,c){const {width:e,height:g,nativeExtent:k,pixelSize:f,spatialReference:l}=
a,h=new E({x:k.xmin,y:k.ymax,spatialReference:l});null==c&&(c=Math.max(0,Math.round(Math.log(Math.max(e,g))/Math.LN2-8)));const n=this.computeBlockBoundary(k,512,512,{x:k.xmin,y:k.ymax},[f],c);a.storageInfo=new ia({blockWidth:b,blockHeight:d,pyramidBlockWidth:b,pyramidBlockHeight:d,origin:h,firstPyramidLevel:1,maximumPyramidLevel:c,blockBoundary:n})}async computeBestPyramidLevelForLocation(a,b){return 0}computeBlockBoundary(a,b,d,c,e,g=0,k=2){if(1===e.length&&0<g){e=[...e];let {x:h,y:n}=e[0];for(let p=
0;p<g;p++)h*=k,n*=k,e.push({x:h,y:n})}g=[];const {x:f,y:l}=c;for(c=0;c<e.length;c++){const {x:h,y:n}=e[c];g.push({minCol:Math.floor((a.xmin-f+.1*h)/b/h),maxCol:Math.floor((a.xmax-f-.1*h)/b/h),minRow:Math.floor((l-a.ymax+.1*n)/d/n),maxRow:Math.floor((l-a.ymin-.1*n)/d/n)})}return g}getPyramidPixelSize(a){const {nativePixelSize:b}=this.rasterInfo,{pyramidResolutions:d,pyramidScalingFactor:c}=this.rasterInfo.storageInfo;if(0===a)return b;if(null!=d&&d.length)return d[a-1];a=c**a;return{x:b.x*a,y:b.y*
a}}identifyPixelLocation(a,b,d,c){const {spatialReference:e,nativeExtent:g,storageInfo:k}=this.rasterInfo,{maximumPyramidLevel:f,origin:l,transposeInfo:h}=k,n=c&&null!=h?h.tileSize[0]:k.blockWidth;c=c&&null!=h?h.tileSize[1]:k.blockHeight;a=v.projectPoint(a,e,d);if(!g.intersects(a)||0>b||b>f)return null;d=this.getPyramidPixelSize(b);const {x:p,y:q}=d;d=(l.y-a.y)/q/c;const r=(a.x-l.x)/p/n;return{pyramidLevel:b,row:Math.floor(d),col:Math.floor(r),rowOffset:Math.min(c-1,Math.floor((d-Math.floor(d))*c)),
colOffset:Math.min(n-1,Math.floor((r-Math.floor(r))*n)),blockWidth:n,srcLocation:a}}getTileExtent(a,b,d,c,e,g){const [k,f]=g;d=c.x+d*k*a.x;b=c.y-b*f*a.y;return new H({xmin:d,xmax:d+k*a.x,ymin:b-f*a.y,ymax:b,spatialReference:e})}getBlockWidthHeight(a){return{blockWidth:0<a?this.rasterInfo.storageInfo.pyramidBlockWidth:this.rasterInfo.storageInfo.blockWidth,blockHeight:0<a?this.rasterInfo.storageInfo.pyramidBlockHeight:this.rasterInfo.storageInfo.blockHeight}}isBlockOutside(a,b,d){a=this.rasterInfo.storageInfo.blockBoundary[a];
return!a||a.maxRow<b||a.maxCol<d||a.minRow>b||a.minCol>d}updateImageSpaceRasterInfo(a){const {extent:b,pixelSize:d}=a;if(-.5!==b.xmin||.5!==b.ymax||1!==d.x||1!==d.y||null!=a.transform){var {width:c,height:e}=a,g=ma.WebMercator;a.spatialReference=g;a.extent=a.nativeExtent=new H({xmin:-.5,ymax:.5,xmax:c-.5,ymin:.5-e,spatialReference:g});a.isPseudoSpatialReference=!0;a.transform=null;a.pixelSize=new E({x:1,y:1,spatialReference:g});var {extent:k,storageInfo:f}=a;if(f){f.origin=new E({x:k.xmin,y:k.ymax,
spatialReference:g});const {pyramidResolutions:l,tileInfo:h}=f;l&&l.forEach(n=>{n.x/=d.x;n.y/=d.y});if(h){h.origin=f.origin;const n=(a.nativePixelSize.x+a.nativePixelSize.y)/2;h.lods.forEach((p,q)=>{p.resolution=n*2**q;p.scale=96*p.resolution/.0254})}}}}async _fetchPixels(a,b,d,c={}){var e=v.getWorldWrapCount(a);if(2<=e)return{extent:a,pixelBlock:null};var g=this._getSourceDataInfo(a,b,d,c);const {pyramidLevel:k,srcResolution:f,srcExtent:l,srcWidth:h,srcHeight:n,ul:p}=g;if(0===h||0===n)return{extent:a,
srcExtent:l,pixelBlock:null};var {rasterInfo:q}=this,r=q.transform,m="gcs-shift"===r?.type,t=null!=v.getWorldWidth(a.spatialReference);if(m||!t)e=v.getWorldWrapCount(g.srcExtent,m);g=await this._fetchRawTiles(k,p,{width:h,height:n,wrapCount:e},c);if(!g)return{extent:a,srcExtent:l,pixelBlock:null};var u=q.storageInfo;m=0<k?u.pyramidBlockWidth:u.blockWidth;var x=0<k?u.pyramidBlockHeight:u.blockHeight;let {x:z,y:F}=q.pixelSize;if(0<k){const {pyramidResolutions:C,pyramidScalingFactor:G}=u;null!=C&&C[k-
1]?{x:z,y:F}=C[k-1]:(u=G**k,z*=u,F*=u)}var B=q.spatialReference;q=new E({x:z,y:F,spatialReference:B});const M=m===h&&x===n&&0===p.x%m&&0===p.y%x;u=new E({x:(a.xmax-a.xmin)/b,y:(a.ymax-a.ymin)/d,spatialReference:a.spatialReference});const N=!a.spatialReference.equals(B),J=B.isGeographic?1E-9:1E-4;({datumTransformation:B}=c);if(!N&&M&&1===g.pixelBlocks.length&&m===b&&x===d&&Math.abs(f.x-u.x)<J&&Math.abs(f.y-u.y)<J)return{extent:a,srcExtent:l,srcTilePixelSize:q,pixelBlock:g.pixelBlocks[0]};m=t&&null!=
v.getWorldWidth(l.spatialReference)&&this._hasNoneOrGCSShiftTransform;(t=c.requestProjectedLocalDirections&&this.rasterInfo.dataType.startsWith("vector"))&&!this.rasterJobHandler&&await v.load();e=this.rasterJobHandler?await this.rasterJobHandler.getProjectionOffsetGrid({projectedExtent:a,srcBufferExtent:g.extent,pixelSize:u.toJSON(),datumTransformation:B,rasterTransform:r,hasWrapAround:0<e||m,isAdaptive:!1!==this.ioConfig.optimizeProjectionAccuracy,includeGCSGrid:t},c):v.getProjectionOffsetGrid({projectedExtent:a,
srcBufferExtent:g.extent,pixelSize:u,datumTransformation:B,rasterTransform:r,hasWrapAround:0<e||m,isAdaptive:!1,includeGCSGrid:t});r=!c.requestRawData;m={rows:e.spacing[0],cols:e.spacing[1]};x=this._hasNoneOrGCSShiftTransform?this._getRasterTileAlignmentInfo(k,g.extent.xmin):void 0;const {pixelBlocks:O,mosaicSize:K,isPartiallyFilled:P}=g;g=null;this.rasterJobHandler?(b=await this.rasterJobHandler.mosaicAndTransform({srcPixelBlocks:O,srcMosaicSize:K,destDimension:r?{width:b,height:d}:null,coefs:r?
e.coefficients:null,sampleSpacing:r?m:null,projectDirections:t,gcsGrid:t?e.gcsGrid:null,isUV:"vector-uv"===this.rasterInfo.dataType,interpolation:c.interpolation,alignmentInfo:x,blockWidths:null},c),{pixelBlock:r,localNorthDirections:g}=b):(x=I.mosaic(O,K,{alignmentInfo:x}),r=r?I.approximateTransform(x,{width:b,height:d},e.coefficients,m,c.interpolation):x,t&&e.gcsGrid&&(g=I.getLocalArithmeticNorthRotations({width:b,height:d},e.gcsGrid),r=T.convertToLocalDirections(r,this.rasterInfo.dataType,g)));
return c.requestRawData||t?{extent:a,srcExtent:l,srcTilePixelSize:q,pixelBlock:r,transformGrid:e,localNorthDirections:g,isPartiallyFilled:P}:{extent:a,srcExtent:l,srcTilePixelSize:q,pixelBlock:r}}async _fetchRawTiles(a,b,d,c){const {origin:e,blockBoundary:g}=this.rasterInfo.storageInfo,{blockWidth:k,blockHeight:f}=this.getBlockWidthHeight(a);let {x:l,y:h}=b,{width:n,height:p,wrapCount:q}=d;var r=this._getRasterTileAlignmentInfo(a,0);c.buffer&&(l-=c.buffer.cols,h-=c.buffer.rows,n+=2*c.buffer.cols,
p+=2*c.buffer.rows);var m=0,t=0;let u=0;q&&null!=r&&({worldColumnCountFromOrigin:t,originColumnOffset:u,rightPadding:m}=r,t*r.blockWidth-m>=l+n&&(m=0));b=Math.floor(l/k);d=Math.floor(h/f);const x=Math.floor((l+n+m-1)/k);m=Math.floor((h+p+m-1)/f);var z=g[a];if(!z)return null;const {minRow:F,minCol:B,maxCol:M,maxRow:N}=z;if(0===q&&(m<F||x<B||d>N||b>M))return null;z=[];let J=!1;const O=null==this.ioConfig.allowPartialFill?c.allowPartialFill:this.ioConfig.allowPartialFill;for(let C=d;C<=m;C++)for(let G=
b;G<=x;G++){let Q=G;!c.disableWrapAround&&q&&null!=r&&t<=G&&(Q=G-t-u);if(C>=F&&Q>=B&&N>=C&&M>=Q){const U=this._tileFetchQueue.push({pyramidLevel:a,row:C,col:Q,options:c},{signal:c.signal});O?z.push(new Promise(V=>{U.then(oa=>V(oa)).catch(()=>{J=!0;V(null)})})):z.push(U)}else z.push(Promise.resolve(null))}if(0===z.length)return null;c=await Promise.all(z);r={height:(m-d+1)*f,width:(x-b+1)*k};({spatialReference:t}=this.rasterInfo);a=this.getPyramidPixelSize(a);const {x:K,y:P}=a;return{extent:new H({xmin:e.x+
b*k*K,xmax:e.x+(x+1)*k*K,ymin:e.y-(m+1)*f*P,ymax:e.y-d*f*P,spatialReference:t}),pixelBlocks:c,mosaicSize:r,isPartiallyFilled:J}}_fetchRawTile(a,b,d,c){var e=this.rasterInfo.storageInfo.blockBoundary[a];if(!e)return Promise.resolve(null);const {minRow:g,minCol:k,maxCol:f,maxRow:l}=e;if(b<g||d<k||b>l||d>f)return Promise.resolve(null);const h=D.getRasterId(this.rasterId,c.sliceId),n=`${a}/${b}/${d}`;e=D.getBlock(h,c.registryId,n);if(null==e){const p=new AbortController;e=this.fetchRawTile(a,b,d,{...c,
signal:p.signal});D.putBlock(h,c.registryId,n,e,p);e.catch(()=>D.deleteBlock(h,c.registryId,n))}if(c.signal)aa.onAbort(c,()=>{D.decreaseRefCount(h,c.registryId,n)});return e}_computeMagDirValues(a){const {bandCount:b,dataType:d}=this.rasterInfo;if((2!==b||"vector-magdir"!==d)&&"vector-uv"!==d||2!==a?.length||!a[0]?.length)return null;var c=a[0].length;if("vector-magdir"===d)return c=a[1].map(f=>(f+360)%360),[a[0],c];const [e,g]=a;a=[];const k=[];for(let f=0;f<c;f++){const [l,h]=T.uvComponentToVector([e[f],
g[f]]);a.push(l);k.push(h)}return[a,k]}_getRasterTileAlignmentInfo(a,b){null==this._rasterTileAlignmentInfo&&(this._rasterTileAlignmentInfo=v.getRasterDatasetAlignmentInfo(this.rasterInfo));return null==this._rasterTileAlignmentInfo.pyramidsInfo?null:{startX:b,halfWorldWidth:this._rasterTileAlignmentInfo.halfWorldWidth,hasGCSSShiftTransform:this._rasterTileAlignmentInfo.hasGCSSShiftTransform,...this._rasterTileAlignmentInfo.pyramidsInfo[a]}}_getSourceDataInfo(a,b,d,c={}){const e={datumTransformation:c.datumTransformation,
pyramidLevel:0,pyramidResolution:null,srcExtent:null,srcHeight:0,srcResolution:null,srcWidth:0,ul:{x:0,y:0}};c.srcResolution&&(e.srcResolution=c.srcResolution,this._updateSourceDataInfo(a,e));var g=this.rasterInfo.storageInfo.maximumPyramidLevel||0;const {srcWidth:k,srcHeight:f,pyramidLevel:l}=e;var h=k/b;const n=f/d,p=l<g&&16<=h*n;var q=l===g&&this._requireTooManySrcTiles(k,f,b,d);if(p||q||0===k||0===f){q=new E({x:(a.xmax-a.xmin)/b,y:(a.ymax-a.ymin)/d,spatialReference:a.spatialReference});q=v.projectResolution(q,
this.rasterInfo.spatialReference,a,e.datumTransformation);const r=!q||c.srcResolution&&q.x+q.y<c.srcResolution.x+c.srcResolution.y;p&&c.srcResolution&&r&&(h=Math.round(Math.log(Math.max(h,n))/Math.LN2)-1,g-l+3>=h&&(g=2**h,q={x:c.srcResolution.x*g,y:c.srcResolution.y*g}));q&&(e.srcResolution=q,this._updateSourceDataInfo(a,e))}this._requireTooManySrcTiles(e.srcWidth,e.srcHeight,b,d)&&(e.srcWidth=0,e.srcHeight=0);return e}_requireTooManySrcTiles(a,b,d,c){const {tileInfo:e}=this.rasterInfo.storageInfo;
return Math.ceil(a/e.size[0])*Math.ceil(b/e.size[1])>=256*Math.max(1,(d+c)/1024)||8<a/d||8<b/c}_updateSourceDataInfo(a,b){b.srcWidth=0;b.srcHeight=0;var {rasterInfo:d}=this,c=d.spatialReference;const {srcResolution:e,datumTransformation:g}=b,{pyramidLevel:k,pyramidResolution:f,excessiveReading:l}=v.snapPyramid(e,d,this.ioConfig.sampling);if(!l&&(a=b.srcExtent||v.projectExtent(a,c,g),null!=a)){(c=d.transform)&&(a=c.inverseTransform(a));b.srcExtent=a;var {x:h,y:n}=d.storageInfo.origin;d=Math.floor((a.xmin-
h)/f.x+.1);c=Math.floor((n-a.ymax)/f.y+.1);var p=Math.floor((a.xmax-h)/f.x-.1),q=Math.floor((n-a.ymin)/f.y-.1);p=a.width<.1*f.x?0:p-d+1;a=a.height<.1*f.y?0:q-c+1;b.pyramidLevel=k;b.pyramidResolution=f;b.srcWidth=p;b.srcHeight=a;b.ul={x:d,y:c}}}_getRequestOptionsWithSliceId(a){null!=this.rasterInfo.multidimensionalInfo&&null==a.sliceId&&(a={...a,sliceId:this.getSliceIndex(a.multidimensionalDefinition)});return a}_processIdentifyResult(a,b){const {srcLocation:d,position:c,pyramidLevel:e,useTransposedTile:g}=
b,k=a.pixels[0].length/a.width/a.height;if(a.mask&&!a.mask[c])return{location:d,value:null};const {multidimensionalInfo:f}=this.rasterInfo;if(null==f||!g)return b=a.pixels.map(m=>m[c]),a={location:d,value:b,pyramidLevel:e},b=this._computeMagDirValues(b.map(m=>[m])),b?.length&&(a.magdirValue=b.map(m=>m[0])),a;let l=a.pixels.map(m=>m.slice(c*k,c*k+k)),h=this._computeMagDirValues(l);const {requestSomeSlices:n,identifyOptions:p}=b;let q=L.createSlices(f,p.transposedVariableName);if(n){const m=L.getSliceIds(q,
p.multidimensionalDefinition,p.timeExtent);l=l.map(t=>m.map(u=>t[u]));h=h?.map(t=>m.map(u=>t[u]));q=m.map(t=>q[t])}b=a.noDataValues||this.rasterInfo.noDataValue;a={pixels:l,pixelType:a.pixelType};let r;null!=b&&(ja.convertNoDataToMask(a,b),r=a.mask);a=q.map((m,t)=>{m={value:0===r?.[t]?null:l.map(u=>u[t]),multidimensionalDefinition:m.multidimensionalDefinition.map(u=>new fa({...u,isSlice:!0}))};h?.length&&(m.magdirValue=[h[0][t],h[1][t]]);return m});return{location:d,value:null,dataSeries:a,pyramidLevel:e}}};
y.__decorate([A.property()],w.prototype,"_rasterTileAlignmentInfo",void 0);y.__decorate([A.property()],w.prototype,"_tileFetchQueue",void 0);y.__decorate([A.property({readOnly:!0})],w.prototype,"_isGlobalWrappableSource",null);y.__decorate([A.property({readOnly:!0})],w.prototype,"_hasNoneOrGCSShiftTransform",null);y.__decorate([A.property()],w.prototype,"rasterJobHandler",null);y.__decorate([A.property({readOnly:!0})],w.prototype,"rasterId",null);y.__decorate([A.property(ea.url)],w.prototype,"url",
null);y.__decorate([A.property({type:String,json:{write:!0}})],w.prototype,"datasetName",void 0);y.__decorate([A.property({type:String,json:{write:!0}})],w.prototype,"datasetFormat",void 0);y.__decorate([A.property()],w.prototype,"hasUniqueSourceStorageInfo",void 0);y.__decorate([A.property()],w.prototype,"rasterInfo",void 0);y.__decorate([A.property()],w.prototype,"ioConfig",void 0);y.__decorate([A.property()],w.prototype,"sourceJSON",void 0);return w=y.__decorate([ca.subclass("esri.layers.support.rasterDatasets.BaseRaster")],
w)});