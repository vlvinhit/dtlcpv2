// All material copyright Esri, All Rights Reserved, unless otherwise specified.
// See https://js.arcgis.com/4.30/esri/copyright.txt for details.
//>>built
define("require ../../../chunks/tslib.es6 ../../../core/Error ../../../core/accessorSupport/decorators/property ../../../core/has ../../../core/Logger ../../../core/RandomLCG ../../../core/accessorSupport/decorators/subclass ../../../geometry/Polygon ./BaseRaster ../rasterFunctions/clipUtils ../rasterFunctions/pixelUtils ../rasterFunctions/rasterProjectionHelper ../../../rest/support/FeatureSet".split(" "),function(x,r,y,t,p,G,H,z,A,B,u,C,v,D){p=class extends B{constructor(){super(...arguments);this.datasetFormat=
"Function";this.tileType="Raster";this.rasterFunction=null;this._clippingGeometry=new Map}async open(b){await this.init();const {rasterFunction:a}=this;this.primaryRasters?.rasters?.length?a.sourceRasters=this.primaryRasters.rasters:(this.primaryRasters=a.getPrimaryRasters(),this.rasterJobHandler&&this.primaryRasters.rasters?.forEach(d=>d.rasterJobHandler=this.rasterJobHandler));const {rasters:k,rasterIds:c}=this.primaryRasters;var g=k.map(d=>d.rasterInfo?void 0:d.open(b));await Promise.all(g);g=
k.map(({rasterInfo:d})=>d);var m=a.bind({rasterInfos:g,rasterIds:c});a.rawSourceRasterInfos=g;if(!m.success||0===g.length)throw new y("raster-function:open",`cannot bind the function: ${m.error??""}`);m="Table"===a.functionName?a:a.functionArguments?.raster;"Table"===m?.functionName&&(a.rasterInfo.attributeTable=D.fromJSON(m.functionArguments.attributeTableAsRecordSet));await this.syncJobHandler();const l=g[0];this.hasUniqueSourceStorageInfo=1===g.length||g.slice(1).every(d=>{const {storageInfo:f,
pixelSize:e,spatialReference:n,extent:q}=d,{storageInfo:h,pixelSize:w,spatialReference:E,extent:F}=l;return e.x===w.x&&e.y===w.y&&n.equals(E)&&q.equals(F)&&f.blockHeight===h.blockHeight&&f.blockWidth===h.blockWidth&&f.maximumPyramidLevel===h.maximumPyramidLevel});this.set("sourceJSON",k[0].sourceJSON);this.set("rasterInfo",a.rasterInfo);await this._updateClipGeometry()}async syncJobHandler(){return this.rasterJobHandler?.updateRasterFunction(this.rasterFunction)}async fetchPixels(b,a,k,c={}){const {rasters:g,
rasterIds:m}=this.primaryRasters;var l=!1,{interpolation:d}=c,f=this.rasterFunction.flatWebGLFunctionChain?.hasFocalFunction;!c.requestRawData&&f&&(l=1===g.length&&!c.skipRasterFunction,c={...c,interpolation:"bilinear",requestRawData:l});f=g.map(h=>h.fetchPixels(b,a,k,c));f=await Promise.all(f);var e=f.map(h=>h.pixelBlock),n=l||c.requestRawData?f.map(h=>h.srcTilePixelSize):null;if(c.skipRasterFunction||e.every(h=>null==h))return f[0];const q=f.find(h=>null!=h.pixelBlock)?.extent??b;e=this.rasterJobHandler?
await this.rasterJobHandler.process({extent:q,primaryPixelBlocks:e,primaryPixelSizes:n,primaryRasterIds:m}):this.rasterFunction.process({extent:q,primaryPixelBlocks:e,primaryPixelSizes:n,primaryRasterIds:m});({transformGrid:n}=f[0]);if(!l||null==e||null==n)return d=c.noClip?null:this.getClippingGeometry(q.spatialReference),c.noClip||c.requestRawData||null==e||!d||(e=await u.clip(e,q,d)),{...f[0],pixelBlock:e};l={rows:n.spacing[0],cols:n.spacing[1]};d=this.rasterJobHandler?(await this.rasterJobHandler.mosaicAndTransform({srcPixelBlocks:[e],
srcMosaicSize:{width:e.width,height:e.height},destDimension:{width:a,height:k},coefs:n.coefficients,sampleSpacing:l,projectDirections:!1,gcsGrid:null,isUV:!1,interpolation:d,alignmentInfo:void 0,blockWidths:null},c)).pixelBlock:C.approximateTransform(e,{width:a,height:k},n.coefficients,l,d);l=c.noClip?null:this.getClippingGeometry(b.spatialReference);c.noClip||c.requestRawData||null==d||null==l||(d=await u.clip(d,b,l));return{extent:b,srcExtent:f[0].srcExtent,pixelBlock:d}}getClippingGeometry(b){const a=
this._clippingGeometry.get("0");if(!b||!a)return a;const k=String(b.wkid??b.wkt??b.wkt2);let c=this._clippingGeometry.get(k);if(null!=c)return c;c=b.equals(a.spatialReference)?a:v.projectPolygon(a,b);this._clippingGeometry.set(k,c);return c}async _updateClipGeometry(){var b=this.rasterFunction.getClippingGeometries()[0];let a=b?.clippingGeometry;if(a&&"inside"===b.clippingType){({extent:b}=this.rasterInfo);const {difference:k,densify:c}=await new Promise((g,m)=>x(["../../../geometry/geometryEngine"],
g,m));b=c(A.fromExtent(b),2*(b.width+b.height)/40);b=v.projectPolygon(b,a.spatialReference);a=k(b,a)}this._clippingGeometry.clear();a&&this._clippingGeometry.set("0",a)}};r.__decorate([t.property({type:String,json:{write:!0}})],p.prototype,"datasetFormat",void 0);r.__decorate([t.property()],p.prototype,"tileType",void 0);r.__decorate([t.property()],p.prototype,"rasterFunction",void 0);r.__decorate([t.property()],p.prototype,"primaryRasters",void 0);return p=r.__decorate([z.subclass("esri.layers.support.rasterDatasets.FunctionRaster")],
p)});