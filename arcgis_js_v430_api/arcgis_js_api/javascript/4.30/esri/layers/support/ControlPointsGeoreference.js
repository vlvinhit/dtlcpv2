// All material copyright Esri, All Rights Reserved, unless otherwise specified.
// See https://js.arcgis.com/4.30/esri/copyright.txt for details.
//>>built
define("../../chunks/tslib.es6 ../../core/Clonable ../../core/Error ../../core/JSONSupport ../../core/Logger ../../core/perspectiveUtils ../../core/screenUtils ../../core/accessorSupport/decorators/property ../../core/has ../../core/RandomLCG ../../core/accessorSupport/decorators/reader ../../core/accessorSupport/decorators/subclass ../../core/accessorSupport/decorators/writer ../../core/libs/gl-matrix-2/math/mat3 ../../core/libs/gl-matrix-2/factories/mat3f64 ../../core/libs/gl-matrix-2/math/vec2 ../../core/libs/gl-matrix-2/factories/vec2f64 ../../geometry/Point ../../geometry/Polygon ../../geometry/projection ../../geometry/SpatialReference ./GeoreferenceBase".split(" "),
function(g,E,W,k,S,n,K,q,I,fa,X,O,Y,Z,L,l,m,y,aa,T,U,ba){function h(a){return null!=a?.sourcePoint&&null!=a.mapPoint}function t(a,b,d){l.set(a,d.sourcePoint.x,d.sourcePoint.y);l.set(b,d.mapPoint.x,d.mapPoint.y)}function ca(a,b,d){t(u,v,b);t(w,x,d);l.rotate(F,w,u,M);l.rotate(z,u,w,M);l.rotate(G,x,v,-M);l.rotate(A,v,x,-M);b=v;d=x;var e=G,c=A;return n.getProjectiveTransform(a,J(P,u,w,F,z),J(Q,b,d,e,c))}function da(a,b,d,e){t(u,v,b);t(w,x,d);t(F,G,e);l.lerp(z,u,w,.5);l.rotate(z,F,z,Math.PI);l.lerp(A,
v,x,.5);l.rotate(A,G,A,Math.PI);b=v;d=x;e=G;var c=A;return n.getProjectiveTransform(a,J(P,u,w,F,z),J(Q,b,d,e,c))}function V(a,b,d,e,c){t(u,v,b);t(w,x,d);t(F,G,e);t(z,A,c);b=v;d=x;e=G;c=A;return n.getProjectiveTransform(a,J(P,u,w,F,z),J(Q,b,d,e,c))}function J(a,b,d,e,c){a[0]=b[0];a[1]=b[1];a[2]=d[0];a[3]=d[1];a[4]=e[0];a[5]=e[1];a[6]=c[0];a[7]=c[1];return a}const R=L.create(),f=m.create();I=class extends k.JSONSupport{};g.__decorate([q.property({type:Number,json:{write:!0}})],I.prototype,"x",void 0);
g.__decorate([q.property({type:Number,json:{write:!0}})],I.prototype,"y",void 0);I=g.__decorate([O.subclass("esri.layers.support.ControlPointsGeoreference.ControlPointJSONType")],I);E=class extends E.Clonable{constructor(){super(...arguments);this.mapPoint=this.sourcePoint=null}};g.__decorate([q.property()],E.prototype,"sourcePoint",void 0);g.__decorate([q.property({type:y})],E.prototype,"mapPoint",void 0);E=g.__decorate([O.subclass("esri.layers.support.ControlPointsGeoreference.ControlPoint")],E);
k=class extends k.JSONSupportMixin(ba){constructor(a){super(a);this.controlPoints=null;this.height=0;this.type="control-points";this.width=0}readControlPoints(a,b){const d=U.fromJSON(b.spatialReference),e=L.fromValues(...b.coefficients,1);return a.map(c=>{l.set(f,c.x,c.y);n.transformProjective(f,f,e);return{sourcePoint:c,mapPoint:new y({x:f[0],y:f[1],spatialReference:d})}})}writeControlPoints(a,b,d,e){null==this.transform?(a=new W("web-document-write:invalid-georeference","Invalid 'controlPoints', 'width', 'height' configuration.",
{layer:e?.layer,georeference:this}),e?.messages?e.messages.push(a):S.getLogger(this).error(a.name,a.message)):null!=a&&h(a[0])&&(b.controlPoints=a.map(c=>{c=c.sourcePoint;return{x:c.x,y:c.y}}),b.spatialReference=a[0].mapPoint.spatialReference.toJSON(),b.coefficients=this.transform.slice(0,8))}get coords(){if(null==this.controlPoints)return null;const a=this._updateTransform(R);if(null==a||!h(this.controlPoints[0]))return null;var b=this.width,d=this.height,e=this.controlPoints[0].mapPoint.spatialReference;
const c=m.fromValues(0,d),p=m.fromValues(0,0),B=m.fromValues(b,0);b=m.fromValues(b,d);n.transformProjective(c,c,a);n.transformProjective(p,p,a);n.transformProjective(B,B,a);n.transformProjective(b,b,a);return new aa({rings:[[c,p,B,b,c]],spatialReference:e})}set coords(a){if(null!=this.controlPoints&&h(this.controlPoints[0])){var b=this.controlPoints[0].mapPoint.spatialReference;a=this.projectOrWarn(a,b);if(null!=a){var {width:d,height:e}=this,{rings:[[c,p,B,N]]}=a;a={sourcePoint:K.createScreenPoint(0,
e),mapPoint:new y({x:c[0],y:c[1],spatialReference:b})};var r={sourcePoint:K.createScreenPoint(0,0),mapPoint:new y({x:p[0],y:p[1],spatialReference:b})},C={sourcePoint:K.createScreenPoint(d,0),mapPoint:new y({x:B[0],y:B[1],spatialReference:b})},D={sourcePoint:K.createScreenPoint(d,e),mapPoint:new y({x:N[0],y:N[1],spatialReference:b})};h(a)&&h(r)&&h(C)&&h(D)&&(V(R,a,r,C,D),this.controlPoints=this.controlPoints.map(({sourcePoint:H})=>{l.set(f,H.x,H.y);n.transformProjective(f,f,R);return{sourcePoint:H,
mapPoint:new y({x:f[0],y:f[1],spatialReference:b})}}))}}}get inverseTransform(){return null==this.transform?null:Z.invert(L.create(),this.transform)}get transform(){return this._updateTransform()}toMap(a){if(null==a||null==this.transform||null==this.controlPoints||!h(this.controlPoints[0]))return null;l.set(f,a.x,a.y);a=this.controlPoints[0].mapPoint.spatialReference;n.transformProjective(f,f,this.transform);return new y({x:f[0],y:f[1],spatialReference:a})}toSource(a){if(null==a||null==this.inverseTransform||
null==this.controlPoints||!h(this.controlPoints[0]))return null;const b=this.controlPoints[0].mapPoint.spatialReference;a=a.normalize();a=T.projectOrLoad(a,b).geometry;if(null==a)return null;l.set(f,a.x,a.y);n.transformProjective(f,f,this.inverseTransform);return K.createScreenPoint(f[0],f[1])}toSourceNormalized(a){a=this.toSource(a);null!=a&&(a.x/=this.width,a.y/=this.height);return a}_updateTransform(a){const {controlPoints:b,width:d,height:e}=this;if(!(null!=b&&0<d&&0<e))return null;const [c,p,
B,N]=b;if(!h(c))return null;var r=c.mapPoint.spatialReference;const C=this._projectControlPoint(p,r),D=this._projectControlPoint(B,r);r=this._projectControlPoint(N,r);if(!(C.valid&&D.valid&&r.valid&&h(C.controlPoint)))return null;null==a&&(a=L.create());let H=null;H=h(D.controlPoint)&&h(r.controlPoint)?V(a,c,C.controlPoint,D.controlPoint,r.controlPoint):h(D.controlPoint)?da(a,c,C.controlPoint,D.controlPoint):ca(a,c,C.controlPoint);return H.every(ea=>0===ea)?null:H}_projectControlPoint(a,b){if(!h(a))return{valid:!0,
controlPoint:a};const {sourcePoint:d,mapPoint:e}=a,{geometry:c,pending:p}=T.projectOrLoad(e,b);return p?{valid:!1,controlPoint:null}:p||c?{valid:!0,controlPoint:{sourcePoint:d,mapPoint:c}}:(S.getLogger(this).warn("map point could not be projected to the spatial reference",{georeference:this,controlPoint:a,sourceSpatialReference:e.spatialReference,targetSpatialReference:b}),{valid:!1,controlPoint:null})}};g.__decorate([q.property({type:[E],json:{write:{allowNull:!1,isRequired:!0,target:{controlPoints:{type:[I]},
coefficients:{type:[Number]},spatialReference:{type:U}}}}})],k.prototype,"controlPoints",void 0);g.__decorate([X.reader("controlPoints")],k.prototype,"readControlPoints",null);g.__decorate([Y.writer("controlPoints")],k.prototype,"writeControlPoints",null);g.__decorate([q.property({clonable:!1})],k.prototype,"coords",null);g.__decorate([q.property({type:Number,nonNullable:!0,json:{write:!0}})],k.prototype,"height",void 0);g.__decorate([q.property({readOnly:!0})],k.prototype,"inverseTransform",null);
g.__decorate([q.property({readOnly:!0})],k.prototype,"transform",null);g.__decorate([q.property({type:Number,nonNullable:!0,json:{write:!0}})],k.prototype,"width",void 0);k=g.__decorate([O.subclass("esri.layers.support.ControlPointsGeoreference")],k);const u=m.create(),w=m.create(),F=m.create(),z=m.create(),v=m.create(),x=m.create(),G=m.create(),A=m.create(),M=Math.PI/2,P=Array(8).fill(0),Q=Array(8).fill(0);return k});