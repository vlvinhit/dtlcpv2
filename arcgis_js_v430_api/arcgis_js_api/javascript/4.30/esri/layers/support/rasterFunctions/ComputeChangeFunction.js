// All material copyright Esri, All Rights Reserved, unless otherwise specified.
// See https://js.arcgis.com/4.30/esri/copyright.txt for details.
//>>built
define("../../../chunks/tslib.es6 ../../../core/accessorSupport/decorators/property ../../../core/has ../../../core/Logger ../../../core/RandomLCG ../../../core/accessorSupport/decorators/subclass ../Field ../rasterFormats/pixelRangeUtils ./BaseRasterFunction ./changeDetectionUtils ./ComputeChangeFunctionArguments".split(" "),function(r,v,m,I,J,E,l,z,F,G,H){m=class extends F{constructor(){super(...arguments);this.functionName="ComputeChange";this.functionArguments=null;this.rasterArgumentNames=["raster",
"raster2"]}_bindSourceRasters(){const {method:b}=this.functionArguments,a=this.sourceRasterInfos[0].clone();this.outputPixelType=this._getOutputPixelType(a.pixelType);a.pixelType=this.outputPixelType;this._removeStatsHistColormapVAT(a);if("categorical"===b){var g=this.sourceRasterInfos.map(h=>h.attributeTable);const d=this._getFieldNames(g,"value");g=g.map(h=>this._getClassFieldName(h));if(null==d[0]||null==d[1]||null==g[0]||null==g[1])return{success:!1,supportsGPU:!1,error:"both inputs must have proper attribute table with value and class fields"};
this._updateAttributeTable(a,d,g)}a.bandCount=1;this.rasterInfo=a;return{success:!0,supportsGPU:"difference"===b||"relative-difference"===b}}_processPixels(b){({pixelBlocks:b}=b);if(null==b?.[0]||null==b?.[1])return null;const {method:a}=this.functionArguments;return G.computeChange(b,a,this.outputPixelType,this._categoryConfig)}_getWebGLParameters(){var b=this.outputPixelType??"f32";let [a,g]=z.getPixelValueRange(b);if(b=z.isIntegerPixelType(b))a-=1E-4,g+=1E-4;return{method:this.functionArguments.method,
domainRange:[a,g],isOutputRounded:b}}_updateAttributeTable(b,a,g){var d=this.sourceRasterInfos.map(c=>c.attributeTable),h=d.map((c,e)=>c.features.map(f=>f.attributes[a[e]])),k=d.map((c,e)=>c.features.map(f=>f.attributes[g[e]])),p=h.map(c=>{const e=[];c.forEach((f,n)=>e[f]=n);return e});const {keepMethod:t}=this.functionArguments;this._categoryConfig={categoryIndexLookups:p,classNames:k,keepMethod:t};p=d[0].clone();p.fields=[new l({name:"OID",type:"oid"}),new l({name:"Value",type:"integer"}),new l({name:"ClassName",
type:"string"}),new l({name:"Class_From",type:"string"}),new l({name:"Class_To",type:"string"})];const A=this._getFieldNames(d,"red"),B=this._getFieldNames(d,"green"),C=this._getFieldNames(d,"blue"),q=[],D=2===A.length&&2===B.length&&2===C.length;D&&(q.push(...d.map((c,e)=>c.features.map(f=>[f.attributes[A[e]],f.attributes[B[e]],f.attributes[C[e]]]))),p.fields.push(new l({name:"Red",type:"integer"}),new l({name:"Green",type:"integer"}),new l({name:"Blue",type:"integer"})));const w=p.features[0].clone();
w.geometry=null;d=[];const [y,x]=h.map(c=>c.length);h=1;for(let c=0;c<y;c++){const e=k[0][c];for(let f=0;f<x;f++){const n=k[1][f];if("changed"===t&&e===n||"unchanged"===t&&e!==n)continue;const u=w.clone();u.attributes={OID:h++,Value:c*x+f,ClassName:e===n?e:`${e} -> ${n}`,Class_From:e,Class_To:n};D&&(u.attributes.Red=q[0][c][0]+q[1][f][0]>>1,u.attributes.Green=q[0][c][1]+q[1][f][1]>>1,u.attributes.Blue=q[0][c][2]+q[1][f][2]>>1);d.push(u)}}"changed"===t?(k=w.clone(),k.attributes={OID:h++,Value:y*x+
1,ClassName:"No Change",Class_From:"Same",Class_To:"Same"},d.push(k)):"unchanged"===t&&(k=w.clone(),k.attributes={OID:h++,Value:y*x+2,ClassName:"Changed",Class_From:"Any",Class_To:"Any"},d.push(k));p.features=d;b.attributeTable=p}_getFieldNames(b,a){return b.map(({fields:g})=>g.find(d=>d.name.toLowerCase()===a)?.name).filter(g=>g)}_getClassFieldName(b){return(b.fields.find(a=>"string"===a.type&&a.name.toLowerCase().startsWith("class"))??b.fields.find(a=>"string"===a.type&&a.name.toLowerCase().includes("class")||
a.name.toLowerCase().includes("type")||a.name.toLowerCase().includes("name"))??b.fields.find(a=>"string"===a.type))?.name}};r.__decorate([v.property({json:{write:!0,name:"rasterFunction"}})],m.prototype,"functionName",void 0);r.__decorate([v.property({type:H,json:{write:!0,name:"rasterFunctionArguments"}})],m.prototype,"functionArguments",void 0);r.__decorate([v.property()],m.prototype,"rasterArgumentNames",void 0);r.__decorate([v.property({json:{write:!0}})],m.prototype,"_categoryConfig",void 0);
return m=r.__decorate([E.subclass("esri.layers.support.rasterFunctions.ComputeChangeFunction")],m)});