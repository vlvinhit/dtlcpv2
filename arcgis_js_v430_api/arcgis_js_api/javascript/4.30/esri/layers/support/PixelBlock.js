// All material copyright Esri, All Rights Reserved, unless otherwise specified.
// See https://js.arcgis.com/4.30/esri/copyright.txt for details.
//>>built
define("../../chunks/tslib.es6 ../../core/Error ../../core/JSONSupport ../../core/lang ../../core/Logger ../../core/accessorSupport/decorators/property ../../core/accessorSupport/decorators/cast ../../core/accessorSupport/decorators/subclass ./SimpleBandStatistics ./rasterFormats/pixelRangeUtils".split(" "),function(p,w,m,x,u,q,y,z,v,A){var t;m=t=class extends m.JSONSupport{static createEmptyBand(a,b){return new (t.getPixelArrayConstructor(a))(b)}static combineBandMasks(a){if(2>a.length)return a[0];
const b=a[0].length,k=(new Uint8Array(b)).fill(255);for(let l=0;l<a.length;l++){const f=a[l];for(let c=0;c<b;c++)f[c]||(k[c]=0)}return k}static getPixelArrayConstructor(a){let b;switch(a){case "u1":case "u2":case "u4":case "u8":b=Uint8Array;break;case "u16":b=Uint16Array;break;case "u32":b=Uint32Array;break;case "s8":b=Int8Array;break;case "s16":b=Int16Array;break;case "s32":b=Int32Array;break;case "f32":b=Float32Array;break;case "f64":b=Float64Array;break;case "c64":case "c128":case "unknown":b=
Float32Array}return b}constructor(a){super(a);this.height=this.width=null;this.pixelType="f32";this.mask=this.validPixelCount=null;this.premultiplyAlpha=this.maskIsAlpha=!1;this.statistics=null;this.depthCount=1}castPixelType(a){if(!a)return"f32";a=a.toLowerCase();["u1","u2","u4"].includes(a)?a="u8":"unknown u8 s8 u16 s16 u32 s32 f32 f64".split(" ").includes(a)||(a="f32");return a}getPlaneCount(){return this.pixels?.length}addData(a){if(!a.pixels||a.pixels.length!==this.width*this.height)throw new w("pixelblock:invalid-or-missing-pixels",
"add data requires valid pixels array that has same length defined by pixel block width * height");this.pixels||(this.pixels=[]);this.statistics||(this.statistics=[]);this.pixels.push(a.pixels);this.statistics.push(a.statistics??new v.SimpleBandStatistics)}getAsRGBA(){const a=new ArrayBuffer(this.width*this.height*4);switch(this.pixelType){case "s8":case "s16":case "u16":case "s32":case "u32":case "f32":case "f64":this._fillFromNon8Bit(a);break;default:this._fillFrom8Bit(a)}return new Uint8ClampedArray(a)}getAsRGBAFloat(){const a=
new Float32Array(this.width*this.height*4);this._fillFrom32Bit(a);return a}updateStatistics(){if(this.pixels){this.statistics=this.pixels.map(k=>{var l=this.mask;let f=Infinity,c=-Infinity;const d=k.length;let h,g=0;if(null!=l)for(h=0;h<d;h++)l[h]&&(g=k[h],f=g<f?g:f,c=g>c?g:c);else for(h=0;h<d;h++)g=k[h],f=g<f?g:f,c=g>c?g:c;return new v.SimpleBandStatistics(f,c)});var a=this.mask,b=0;if(null!=a)for(let k=0;k<a.length;k++)a[k]&&b++;else b=this.width*this.height;this.validPixelCount=b}}clamp(a){if(a&&
"f64"!==a&&"f32"!==a&&this.pixels){var [b,k]=A.getPixelValueRange(a),l=this.pixels,f=this.width*this.height,c=l.length,d=[];for(let e=0;e<c;e++){var h=t.createEmptyBand(a,f);var g=l[e];for(let r=0;r<f;r++){var n=g[r];h[r]=n>k?k:n<b?b:n}d.push(h)}this.pixels=d;this.pixelType=a}}extractBands(a){const {pixels:b,statistics:k}=this;if(null==a||0===a.length||!b||0===b.length)return this;var l=b.length;const f=a.some(e=>e>=b.length),c=l===a.length&&!a.some((e,r)=>e!==r);if(f||c)return this;l=this.bandMasks?.length===
l?a.map(e=>this.bandMasks[e]):void 0;let {mask:d,validPixelCount:h}=this;const {width:g,height:n}=this;l?.length&&(d=t.combineBandMasks(l),h=d.filter(e=>!!e).length);return new t({pixelType:this.pixelType,width:g,height:n,mask:d,bandMasks:l,validPixelCount:h,maskIsAlpha:this.maskIsAlpha,pixels:a.map(e=>b[e]),statistics:k&&a.map(e=>k[e])})}clone(){const a=new t({width:this.width,height:this.height,pixelType:this.pixelType,maskIsAlpha:this.maskIsAlpha,validPixelCount:this.validPixelCount});null!=this.mask&&
(a.mask=new Uint8Array(this.mask));this.bandMasks&&(a.bandMasks=this.bandMasks.map(l=>new Uint8Array(l)));let b;const k=t.getPixelArrayConstructor(this.pixelType);if(this.pixels&&0<this.pixels.length){a.pixels=[];const l=!!this.pixels[0].slice;for(b=0;b<this.pixels.length;b++)a.pixels[b]=l?this.pixels[b].slice(0,this.pixels[b].length):new k(this.pixels[b])}if(this.statistics)for(a.statistics=[],b=0;b<this.statistics.length;b++)a.statistics[b]=x.clone(this.statistics[b]);a.premultiplyAlpha=this.premultiplyAlpha;
return a}_fillFrom8Bit(a){const {mask:b,maskIsAlpha:k,premultiplyAlpha:l,pixels:f}=this;if(a&&f?.length){var c,d;var h=c=d=f[0];3<=f.length?(c=f[1],d=f[2]):2===f.length&&(c=f[1]);var g=new Uint32Array(a),n=this.width*this.height;if(h.length!==n)u.getLogger(this).error("getAsRGBA()","Unable to convert to RGBA. The pixelblock is invalid.");else if(null!=b&&b.length===n)if(k)for(a=0;a<n;a++){const e=b[a];if(e){const r=e/255;g[a]=l?e<<24|d[a]*r<<16|c[a]*r<<8|h[a]*r:e<<24|d[a]<<16|c[a]<<8|h[a]}}else for(a=
0;a<n;a++)b[a]&&(g[a]=-16777216|d[a]<<16|c[a]<<8|h[a]);else for(a=0;a<n;a++)g[a]=-16777216|d[a]<<16|c[a]<<8|h[a]}else u.getLogger(this).error("getAsRGBA()","Unable to convert to RGBA. The input pixel block is empty.")}_fillFromNon8Bit(a){const {pixels:b,mask:k,statistics:l}=this;if(a&&b?.length){var f=this.pixelType,c=1,d=0;c=1;if(l&&0<l.length){for(var h of l)null!=h.minValue&&(d=Math.min(d,h.minValue)),null!=h.maxValue&&null!=h.minValue&&(c=Math.max(c,h.maxValue-h.minValue));c=255/c}else c=255,
"s8"===f?(d=-128,c=127):"u16"===f?c=65535:"s16"===f?(d=-32768,c=32767):"u32"===f?c=4294967295:"s32"===f?(d=-2147483648,c=2147483647):"f32"===f?(d=-3.4*1E39,c=3.4*1E39):"f64"===f&&(d=-Number.MAX_VALUE,c=Number.MAX_VALUE),c=255/(c-d);a=new Uint32Array(a);f=this.width*this.height;var g,n,e;h=g=n=b[0];if(h.length!==f)return u.getLogger(this).error("getAsRGBA()","Unable to convert to RGBA. The pixelblock is invalid.");if(2<=b.length)if(g=b[1],3<=b.length&&(n=b[2]),null!=k&&k.length===f)for(e=0;e<f;e++)k[e]&&
(a[e]=-16777216|(n[e]-d)*c<<16|(g[e]-d)*c<<8|(h[e]-d)*c);else for(e=0;e<f;e++)a[e]=-16777216|(n[e]-d)*c<<16|(g[e]-d)*c<<8|(h[e]-d)*c;else if(null!=k&&k.length===f)for(e=0;e<f;e++)g=(h[e]-d)*c,k[e]&&(a[e]=-16777216|g<<16|g<<8|g);else for(e=0;e<f;e++)g=(h[e]-d)*c,a[e]=-16777216|g<<16|g<<8|g}else u.getLogger(this).error("getAsRGBA()","Unable to convert to RGBA. The input pixel block is empty.")}_fillFrom32Bit(a){const {pixels:b,mask:k}=this;if(!a||!b?.length)return u.getLogger(this).error("getAsRGBAFloat()",
"Unable to convert to RGBA. The input pixel block is empty.");let l,f,c,d;l=f=c=b[0];3<=b.length?(f=b[1],c=b[2]):2===b.length&&(f=b[1]);const h=this.width*this.height;if(l.length!==h)return u.getLogger(this).error("getAsRGBAFloat()","Unable to convert to RGBA. The pixelblock is invalid.");let g=0;if(null!=k&&k.length===h)for(d=0;d<h;d++)a[g++]=l[d],a[g++]=f[d],a[g++]=c[d],a[g++]=k[d]&1;else for(d=0;d<h;d++)a[g++]=l[d],a[g++]=f[d],a[g++]=c[d],a[g++]=1}};p.__decorate([q.property({json:{write:!0}})],
m.prototype,"width",void 0);p.__decorate([q.property({json:{write:!0}})],m.prototype,"height",void 0);p.__decorate([q.property({json:{write:!0}})],m.prototype,"pixelType",void 0);p.__decorate([y.cast("pixelType")],m.prototype,"castPixelType",null);p.__decorate([q.property({json:{write:!0}})],m.prototype,"validPixelCount",void 0);p.__decorate([q.property({json:{write:!0}})],m.prototype,"mask",void 0);p.__decorate([q.property({json:{write:!0}})],m.prototype,"maskIsAlpha",void 0);p.__decorate([q.property({json:{write:!0}})],
m.prototype,"pixels",void 0);p.__decorate([q.property()],m.prototype,"premultiplyAlpha",void 0);p.__decorate([q.property({json:{write:!0}})],m.prototype,"statistics",void 0);p.__decorate([q.property({json:{write:!0}})],m.prototype,"depthCount",void 0);p.__decorate([q.property({json:{write:!0}})],m.prototype,"noDataValues",void 0);p.__decorate([q.property({json:{write:!0}})],m.prototype,"bandMasks",void 0);return m=t=p.__decorate([z.subclass("esri.layers.support.PixelBlock")],m)});