// All material copyright Esri, All Rights Reserved, unless otherwise specified.
// See https://js.arcgis.com/4.30/esri/copyright.txt for details.
//>>built
define("exports ../../../core/Logger ../../../chunks/vec32 ../../../core/libs/gl-matrix-2/factories/vec3f64 ../MeshComponent ../MeshVertexAttributes ./vertexSpaceConversion".split(" "),function(B,C,A,D,E,F,G){function H(a){var c=null,b=null;let e=!0,p=!0,g=null;const k=D.create();let f=0;for(const m of a){const {vertexSpace:n,transform:l}=m;null==b&&(b=n,(a=b.origin)&&(g=a));if(b.type!==n.type)return x().error("merge()",`Inconsistent mesh vertex space for provided geometries. One was ${b.type} while another is ${n.type}. Unable to merge geometries.`),
null;null==c||null!=l&&l.equals(c)||(e=!1);null!=l&&null==c&&(c=l);if(a=n.origin)g&&!A.equals(a,g)&&(p=!1),f++,A.add(k,k,a)}if(null==b)throw Error();b=b.clone();if(null==b.origin)return{rebake:!1,vertexSpace:b};if(p&&e)return{rebake:!1,vertexSpace:b,transform:c?.clone()};c=A.scale(k,k,1/f);b.origin=c;return{rebake:!0,vertexSpace:b}}function y(a,c,b,e,p){if(c){var g=c.position;if(g)if(c=c[a],b=b[a],null==c){c=e[a];var k=q[a];if(null!=b){for(var f=0;f<g.length;f+=3)for(let m=0;m<k;m++)b[c++]=p;e[a]=
c}}else if(null!=b&&null!=c){p=0;g=e[a];k=c.length;for(f=0;f<k;f++)b[g++]=c[p++];e[a]+=c.length}}}const x=()=>C.getLogger("esri.geometry.support.triangleMeshMerge"),q={position:3,normal:3,tangent:4,uv:2,color:4};B.merge=function(a,c){var b,e;if(0===a.length)return x().error("merge()","Must specify one more geometries to merge"),null;const p=a[0].spatialReference;for(var g of a){if(!g.spatialReference.equals(p))return x().error("merge()","Geometries must all be in the same spatial reference"),null;
if(!g.loaded)return x().error("merge()","Geometries must all be loaded before merging"),null}g=H(a);if(null==g)return null;var k=0,f=0,m=0,n=0,l=0,d=b=!1;var w=e=!1;for(t of a){var h=t.vertexAttributes;if(h?.position&&(h.uv&&(b=!0),h.normal&&(d=!0),h.tangent&&(w=!0),h.color&&(e=!0),d&&b&&e&&w))break}var t=d;for(u of a)d=u.vertexAttributes,d?.position&&(k+=d.position.length,b&&(f+=d.position.length/q.position*q.uv),t&&(m+=d.position.length/q.position*q.normal),e&&(n+=d.position.length/q.position*q.color),
w&&(l+=d.position.length/q.position*q.tangent));var u=new F.MeshVertexAttributes({position:new Float64Array(k),uv:f?new Float32Array(f):null,normal:m?new Float32Array(m):null,tangent:l?new Float32Array(l):null,color:n?new Uint8Array(n):null});k=[];f={position:0,uv:0,normal:0,tangent:0,color:0};m=new Map;n=new Map;for(const v of a){t=g.rebake?G.convertVertexSpace(v,g.vertexSpace,{allowBufferReuse:!0}):v.vertexAttributes;if(!t)return x().error("merge()","Failed to convert vertex space due to projection errors"),
null;if(c&&c.reuseMaterials&&v.components)for(const z of v.components)z.material&&m.set(z.material,z.material);a=v;l=f;e=m;b=n;w=k;if(a.components)for(const z of a.components){d=z.cloneWithDeduplication(e,b);h=l.position/3;if(d.faces)for(var r=0;r<d.faces.length;r++)d.faces[r]+=h;else for(d.faces=new Uint32Array(a.vertexAttributes.position.length/3),r=0;r<d.faces.length;r++)d.faces[r]=r+h;h=d;0<l.normal&&!a.vertexAttributes.normal&&"source"===h.shading&&(h.shading="flat");w.push(d)}else if(a.vertexAttributes&&
a.vertexAttributes.position){e=a.vertexAttributes.position.length/3;b=new Uint32Array(e);d=l.position/3;for(h=0;h<e;h++)b[h]=h+d;e=b=new E({faces:b});0<l.normal&&!a.vertexAttributes.normal&&"source"===e.shading&&(e.shading="flat");w.push(b)}y("position",t,u,f,0);y("normal",t,u,f,0);y("tangent",t,u,f,0);y("uv",v.vertexAttributes,u,f,0);y("color",v.vertexAttributes,u,f,255)}return{vertexAttributes:u,components:k,vertexSpace:g.vertexSpace,transform:g.rebake?null:g.transform,spatialReference:p}};Object.defineProperty(B,
Symbol.toStringTag,{value:"Module"})});