// All material copyright Esri, All Rights Reserved, unless otherwise specified.
// See https://js.arcgis.com/4.30/esri/copyright.txt for details.
//>>built
define("exports ../../../core/Logger ../../../core/libs/gl-matrix-2/math/mat4 ../../../core/libs/gl-matrix-2/factories/mat4f64 ../../../core/libs/gl-matrix-2/factories/quatf64 ../../../chunks/vec32 ../../../core/libs/gl-matrix-2/factories/vec3f64 ../../Point ../../spatialReferenceEllipsoidUtils ../../projection/projectPointToVector ../axisAngleDegrees ../MeshTransform ../meshVertexSpaceUtils ./geographicUtils ./projection ./vertexSpaceConversion".split(" "),function(y,B,v,C,D,w,p,E,F,x,G,H,I,J,c,
K){function z(a,d,b=p.ZEROS){if(a)for(let q=0;q<a.length;q+=3){for(var g=0;3>g;g++)r[g]=a[q+g]-b[g];w.scale(r,r,d);for(g=0;3>g;g++)a[q+g]=r[g]+b[g]}}const k=()=>B.getLogger("esri.geometry.support.meshUtils.scale"),r=p.create(),L=p.create(),A=C.create(),m=p.create();y.scale=function(a,d,b){if(a.vertexAttributes?.position){var {vertexSpace:g,spatialReference:q}=a,e=b?.origin??a.anchor;b=J.performGlobalOperation(k,g,q,b?.geographic);if(I.isMeshWithRelativeVertexSpace(a))a:{a.transform??(a.transform=
new H);const {vertexSpace:n,transform:f,spatialReference:l}=a,[t,u,M]=n.origin;var h=new E({x:t,y:u,z:M,spatialReference:l});b=r;if(h.equals(e))w.set(b,0,0,0);else if(!K.projectPointToVertexSpace(b,e,a)){c.logProjectionError(k(),e.spatialReference,l,c.loadProjectErrorMessage);break a}a=w.set(L,d,d,d);a=v.fromRotationTranslationScaleOrigin(A,D.IDENTITY,p.ZEROS,a,b);({localMatrix:d}=f);a=v.multiply(A,a,d);f.scale=v.getScaling(p.create(),a);v.scale(a,a,w.inverse(r,f.scale));d=f.rotationAxis;f.rotation=
G.fromMatrix(a);0===f.rotationAngle&&(f.rotationAxis=d);f.translation=v.getTranslation(p.create(),a)}else if(b)a:{b=a.spatialReference;h=F.getSphericalPCPF(b);if(!x.projectPointToVector(e,m,h)&&(c.logProjectionError(k(),e.spatialReference,h,"Falling back to mesh origin"),!x.projectPointToVector(a.origin,m,h))){c.logProjectionError(k(),a.origin.spatialReference,h);break a}e=a.vertexAttributes.position;const n=a.vertexAttributes.normal,f=a.vertexAttributes.tangent,l=new Float64Array(e.length),t=null!=
n?new Float32Array(n.length):null,u=null!=f?new Float32Array(f.length):null;c.projectToPCPF(e,b,l)?null==n||null==t||c.projectNormalToPCPF(n,e,l,b,t)?null==f||null==u||c.projectTangentToPCPF(f,e,l,b,u)?(z(l,d,m),c.projectFromPCPF(l,e,b)?null==n||null==t||c.projectNormalFromPCPF(t,e,l,b,n)?null==f||null==u||c.projectTangentFromPCPF(u,e,l,b,f)?a.vertexAttributesChanged():c.logProjectionError(k(),h,b):c.logProjectionError(k(),h,b):c.logProjectionError(k(),h,b)):c.logProjectionError(k(),b,h):c.logProjectionError(k(),
b,h):c.logProjectionError(k(),b,h)}else x.projectPointToVector(e,m,a.spatialReference)?(z(a.vertexAttributes.position,d,m),a.vertexAttributesChanged()):(d=a.origin,m[0]=d.x,m[1]=d.y,m[2]=d.z,c.logProjectionError(k(),e.spatialReference,a.spatialReference,c.loadProjectErrorMessage))}};Object.defineProperty(y,Symbol.toStringTag,{value:"Module"})});