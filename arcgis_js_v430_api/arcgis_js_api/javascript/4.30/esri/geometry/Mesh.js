// All material copyright Esri, All Rights Reserved, unless otherwise specified.
// See https://js.arcgis.com/4.30/esri/copyright.txt for details.
//>>built
define("require ../chunks/tslib.es6 ../core/deprecate ../core/Error ../core/Loadable ../core/Logger ../core/Promise ../core/promiseUtils ../core/reactiveUtils ../core/accessorSupport/decorators/property ../core/has ../core/RandomLCG ../core/accessorSupport/decorators/subclass ../core/libs/gl-matrix-2/factories/vec3f64 ./Extent ./Geometry ./Point ./Polygon ./support/axisAngleDegrees ./support/MeshComponent ./support/meshErrors ./support/MeshGeoreferencedVertexSpace ./support/MeshLocalVertexSpace ./support/MeshTransform ./support/MeshVertexAttributes ./support/meshVertexSpaceUtils ./support/triangulationUtils ./support/meshUtils/bounds ./support/meshUtils/centerAt ./support/meshUtils/loadExternal ./support/meshUtils/Metadata ./support/meshUtils/primitives ./support/meshUtils/rotate ./support/meshUtils/scale".split(" "),
function(z,g,G,A,e,H,I,B,J,h,C,X,K,L,M,N,r,O,D,u,q,v,P,w,x,t,Q,y,R,S,E,m,T,U){function n(){return H.getLogger("esri.geometry.Mesh")}var k;C={base:null,key:"type",defaultKeyValue:"georeferenced",typeMap:{georeferenced:v,local:P}};e=k=class extends e.LoadableMixin(I.EsriPromiseMixin(N)){constructor(a){super(a);this.components=null;this.vertexSpace=new v;this.transform=null;this.metadata=new E.Metadata;this.hasZ=!0;this.hasM=!1;this.vertexAttributes=new x.MeshVertexAttributes;this.type="mesh"}initialize(){if(0===
this.metadata.externalSources.length||this.vertexAttributes.position.length)this.loadStatus="loaded";this.when(()=>{this.addHandles(J.watch(()=>({vertexAttributes:this.vertexAttributes,components:this.components?.map(a=>a.clone())}),()=>this._clearSources(),{once:!0,sync:!0}))})}get hasExtent(){return this.loaded?0<this.vertexAttributes.position.length&&(!this.components||0<this.components.length):null!=this.metadata.displaySource?.extent}get _transformedExtent(){const {components:a,spatialReference:b,
vertexAttributes:c,vertexSpace:d}=this,p=c.position;if(0===p.length||a&&0===a.length)return new M({xmin:0,ymin:0,zmin:0,xmax:0,ymax:0,zmax:0,spatialReference:b});if(t.isRelativeVertexSpace(d)){const {_untransformedBounds:f,transform:l}=this;return y.getExtentFromBounds(f,l,d,b)}return y.getExtentFromPositions(p,b)}get _untransformedBounds(){return y.getBoundsFromPositions(this.vertexAttributes.position)}get anchor(){const a=t.vertexSpaceOriginToPoint(this.vertexSpace,this.spatialReference);if(null!=
a)return a;const {center:b,zmin:c}=this._transformedExtent;return new r({x:b.x,y:b.y,z:c,spatialReference:this.spatialReference})}get origin(){const a=t.vertexSpaceOriginToPoint(this.vertexSpace,this.spatialReference);return null!=a?a:this._transformedExtent.center}get extent(){return this.loaded||null==this.metadata?.displaySource?.extent?this._transformedExtent:this.metadata.displaySource.extent.clone()}addComponent(a){this._checkIfLoaded("addComponent()")&&(this.components||(this.components=[]),
this.components.push(u.from(a)),this.notifyChange("components"))}removeComponent(a){if(this._checkIfLoaded("removeComponent()")){if(this.components&&(a=this.components.indexOf(a),-1!==a)){this.components.splice(a,1);this.notifyChange("components");return}n().error("removeComponent()",q.componentNotFoundMessage)}}rotate(a,b,c,d){D.composeAxes(a,b,c,F);T.rotate(this,F,d);return this}offset(a,b,c){if(!this._checkIfLoaded("offset()"))return this;const {vertexSpace:d,vertexAttributes:p}=this,f=p?.position;
if(!f)return this;if(t.isRelativeVertexSpace(d)){const [l,V,W]=d.origin;d.origin=L.fromValues(l+a,V+b,W+c)}else{for(let l=0;l<f.length;l+=3)f[l]+=a,f[l+1]+=b,f[l+2]+=c;this.vertexAttributesChanged()}return this}scale(a,b){if(!this._checkIfLoaded("scale()"))return this;U.scale(this,a,b);return this}centerAt(a,b){if(!this._checkIfLoaded("centerAt()"))return this;R.centerAt(this,a,b);return this}load(a){const {metadata:{displaySource:b}}=this;b&&this.addResolvingPromise(S.loadExternal(this,b,a));return Promise.resolve(this)}addExternalSources(a){this.metadata.externalSources.addMany(a)}updateDisplaySource(a){this.metadata.displaySource=
a}clone(){return this.cloneAndModifyVertexAttributes(this.vertexAttributes.clone(),this.vertexSpace.clone())}cloneAndModifyVertexAttributes(a,b){let c=null;if(this.components){const d=new Map,p=new Map;c=this.components.map(f=>f.cloneWithDeduplication(d,p))}a={components:c,spatialReference:this.spatialReference,vertexAttributes:a,vertexSpace:b,transform:this.transform?.clone()??null,metadata:this.metadata.clone()};return new k(a)}cloneShallow(){return new k({components:this.components,spatialReference:this.spatialReference,
vertexAttributes:this.vertexAttributes,vertexSpace:this.vertexSpace.clone(),transform:this.transform,metadata:this.metadata})}vertexAttributesChanged(){this.notifyChange("vertexAttributes")}async toBinaryGLTF(a){const [{toBinaryGLTF:b}]=await Promise.all([new Promise((c,d)=>z(["./support/meshUtils/exporters/gltf/gltfexport"],c,d)),this.load(a)]);B.throwIfAborted(a);return await b(this,a)}get memoryUsage(){let a;a=0+this.vertexAttributes.memoryUsage;if(null!=this.components)for(const b of this.components)a+=
b.memoryUsage;return a}_clearSources(){this.metadata.clearSources()}_checkIfLoaded(a){return this.loaded?!0:(n().error(a,q.meshNotLoadedMessage),!1)}static createBox(a,b){if(!(a instanceof r))return n().error(".createBox()",q.invalidLocationMessage),null;a=new k(m.convertUnitGeometry(m.createUnitSizeBox(),a,b));return b?.imageFace&&"all"!==b.imageFace?m.extractSingleFaceOfBox(a,b.imageFace):a}static createSphere(a,b){return a instanceof r?new k(m.convertUnitGeometry(m.createUnitSizeSphere(b?.densificationFactor||
0),a,b)):(n().error(".createSphere()",q.invalidLocationMessage),null)}static createCylinder(a,b){return a instanceof r?new k(m.convertUnitGeometry(m.createUnitSizeCylinder(b?.densificationFactor||0),a,b)):(n().error(".createCylinder()",q.invalidLocationMessage),null)}static createPlane(a,b){if(!(a instanceof r))return n().error(".createPlane()",q.invalidLocationMessage),null;const c=b?.facing??"up",d=m.convertPlaneSizeParameter(c,b?.size);return new k(m.convertUnitGeometry(m.createUnitSizePlane(c),
a,{...b,size:d}))}static createFromPolygon(a,b){if(!(a instanceof O))return n().error(".createFromPolygon()",q.invalidPolygonMessage),null;const c=Q.triangulate(a);return new k({vertexAttributes:new x.MeshVertexAttributes({position:c.position}),components:[new u({faces:c.faces,shading:"flat",material:b?.material??null})],spatialReference:a.spatialReference,vertexSpace:new v})}static async createFromGLTF(a,b,c){if(!(a instanceof r))throw a=new q.InvalidLocationError,n().error(".createfromGLTF()",a.message),
a;const {loadGLTFMesh:d}=await B.whenOrAbort(new Promise((p,f)=>z(["./support/meshUtils/loadGLTFMesh"],p,f)),c);return new k(await d(a,b,c))}static async createFromFiles(a,b,c){G.deprecatedFunction(n(),"`Mesh.createFromFiles` is deprecated in favor of 'SceneLayer.convertMesh'",{replacement:"SceneLayer.convertMesh",version:"4.29"});if(!(a instanceof r))throw a=b=new q.InvalidLocationError,n().error(".createFromFiles()",a.message),b;if(!c?.layer)throw new A("invalid:no-layer","SceneLayer required for file to mesh conversion.");
return c.layer.convertMesh(b,{location:a,...c})}static createWithExternalSource(a,b,c){var d=c?.extent??null;const {spatialReference:p}=a,f=c?.transform?.clone()??new w;a=t.selectVertexSpace(a,c);b={source:b,extent:d};d=new E.Metadata;d.externalSources.push(b);return new k({metadata:d,transform:f,vertexSpace:a,spatialReference:p})}static createIncomplete(a,b){var {spatialReference:c}=a;const d=b?.transform?.clone()??new w;a=t.selectVertexSpace(a,b);c=new k({transform:d,vertexSpace:a,spatialReference:c});
c.addResolvingPromise(Promise.reject(new A("mesh-incomplete","Mesh resources are not complete")));return c}};g.__decorate([h.property({type:[u],json:{write:!0}})],e.prototype,"components",void 0);g.__decorate([h.property({nonNullable:!0,types:C,constructOnly:!0,json:{write:!0}})],e.prototype,"vertexSpace",void 0);g.__decorate([h.property({type:w,json:{write:!0}})],e.prototype,"transform",void 0);g.__decorate([h.property({constructOnly:!0})],e.prototype,"metadata",void 0);g.__decorate([h.property()],
e.prototype,"hasExtent",null);g.__decorate([h.property()],e.prototype,"_transformedExtent",null);g.__decorate([h.property()],e.prototype,"_untransformedBounds",null);g.__decorate([h.property()],e.prototype,"anchor",null);g.__decorate([h.property()],e.prototype,"origin",null);g.__decorate([h.property({readOnly:!0,json:{read:!1}})],e.prototype,"extent",null);g.__decorate([h.property({readOnly:!0,json:{read:!1,write:!0,default:!0}})],e.prototype,"hasZ",void 0);g.__decorate([h.property({readOnly:!0,json:{read:!1,
write:!0,default:!1}})],e.prototype,"hasM",void 0);g.__decorate([h.property({type:x.MeshVertexAttributes,nonNullable:!0,json:{write:!0}})],e.prototype,"vertexAttributes",void 0);e=k=g.__decorate([K.subclass("esri.geometry.Mesh")],e);const F=D.create();return e});