// All material copyright ESRI, All Rights Reserved, unless otherwise specified.
// See https://js.arcgis.com/4.27/esri/copyright.txt for details.
//>>built
define("exports ../../../../../chunks/_rollupPluginBabelHelpers ../../../../../core/Logger ../../../../../core/MapUtils ../../../../../core/mathUtils ../../../../../chunks/quat ../../../../../chunks/quatf64 ../../../../../chunks/vec3 ../../../../../chunks/vec3f64 ../../../MeshGeoreferencedRelativeVertexSpace ../../../MeshGeoreferencedVertexSpace ../../../MeshMaterialMetallicRoughness ../../georeference ./buffer ./geometry ./types ./imageutils ../../../../../views/3d/glTF/internal/resourceUtils ../../../../../views/webgl/enums".split(" "),
function(H,N,B,O,P,Q,I,J,r,R,S,T,U,K,L,g,C,D,l){const E=B.getLogger("gltf");B=function(){function M(b,a,c){this.params={};this._materialMap=[];this._imageMap=new Map;this._textureMap=new Map;this.gltf={asset:{version:"2.0",copyright:b.copyright,generator:b.generator},extras:{options:a,binChunkBuffer:null,promises:[]}};c&&(this.params=c);this._addScenes(b)}var n=M.prototype;n._addScenes=function(b){this.gltf.scene=b.defaultScene;const a=this.gltf.extras,c=a.options.bufferOutputType===g.BufferOutputType.GLB||
a.options.imageOutputType===g.ImageOutputType.GLB;c&&(a.binChunkBuffer=new K.Buffer(this.gltf));b.forEachScene(e=>{this._addScene(e)});c&&a.binChunkBuffer.finalize()};n._addScene=function(b){this.gltf.scenes||(this.gltf.scenes=[]);const a={};b.name&&(a.name=b.name);b.forEachNode(c=>{a.nodes||(a.nodes=[]);c=this._addNode(c);a.nodes.push(c)});this.gltf.scenes.push(a)};n._addNode=function(b){this.gltf.nodes||(this.gltf.nodes=[]);const a={};b.name&&(a.name=b.name);var c=b.translation;J.exactEquals(c,
r.ZEROS)||(a.translation=r.clone(c));c=b.rotation;Q.exactEquals(c,I.IDENTITY)||(a.rotation=I.clone(c));c=b.scale;J.exactEquals(c,r.ONES)||(a.scale=r.clone(c));b.mesh&&b.mesh.vertexAttributes.position?a.mesh=this._addMesh(b.mesh):b.forEachNode(e=>{a.children||(a.children=[]);e=this._addNode(e);a.children.push(e)});b=this.gltf.nodes.length;this.gltf.nodes.push(a);return b};n._addMesh=function(b){this.gltf.meshes||(this.gltf.meshes=[]);const a={primitives:[]};var c=this.gltf.extras;const e=c.options.bufferOutputType===
g.BufferOutputType.GLB;c=e?c.binChunkBuffer:new K.Buffer(this.gltf);this.params.origin||(this.params.origin=L.computeOrigin(b));var {ignoreLocalTransform:f}=this.params,h=f?null:b.transform,{vertexSpace:d}=b;f=f?d.isRelative?new R({origin:r.clone(d.origin)}):new S:d;d=U.ungeoreferenceByTransform(b.vertexAttributes,f,h,this.params.origin,{geographic:this.params.geographic,unit:"meters"});L.smoothNormals(b,d);this._flipYZAxis(d);h=c.addBufferView(l.DataType.FLOAT,g.AttributeType.VEC3,g.TargetBuffer.ARRAY_BUFFER);
let m;d.normal&&(m=c.addBufferView(l.DataType.FLOAT,g.AttributeType.VEC3,g.TargetBuffer.ARRAY_BUFFER));let k;b.vertexAttributes.uv&&(k=c.addBufferView(l.DataType.FLOAT,g.AttributeType.VEC2,g.TargetBuffer.ARRAY_BUFFER));let p;d.tangent&&(p=c.addBufferView(l.DataType.FLOAT,g.AttributeType.VEC4,g.TargetBuffer.ARRAY_BUFFER));let q;b.vertexAttributes.color&&(q=c.addBufferView(l.DataType.UNSIGNED_BYTE,g.AttributeType.VEC4,g.TargetBuffer.ARRAY_BUFFER));h.startAccessor("POSITION");m&&m.startAccessor("NORMAL");
k&&k.startAccessor("TEXCOORD_0");p&&p.startAccessor("TANGENT");q&&q.startAccessor("COLOR_0");f=d.position.length/3;const {position:F,normal:v,tangent:t}=d,{color:u,uv:G}=b.vertexAttributes;for(d=0;d<f;++d)h.push(F[3*d]),h.push(F[3*d+1]),h.push(F[3*d+2]),m&&null!=v&&(m.push(v[3*d]),m.push(v[3*d+1]),m.push(v[3*d+2])),k&&null!=G&&(k.push(G[2*d]),k.push(G[2*d+1])),p&&null!=t&&(p.push(t[4*d]),p.push(t[4*d+1]),p.push(t[4*d+2]),p.push(t[4*d+3])),q&&null!=u&&(q.push(u[4*d]),q.push(u[4*d+1]),q.push(u[4*d+
2]),q.push(u[4*d+3]));f=h.endAccessor();f=this._addAccessor(h.index,f);if(m){var w=m.endAccessor();w=this._addAccessor(m.index,w)}if(k){var x=k.endAccessor();x=this._addAccessor(k.index,x)}if(p){var y=p.endAccessor();y=this._addAccessor(p.index,y)}if(q){var z=q.endAccessor();z=this._addAccessor(q.index,z)}let A;b.components&&0<b.components.length&&b.components[0].faces?(A=c.addBufferView(l.DataType.UNSIGNED_INT,g.AttributeType.SCALAR,g.TargetBuffer.ELEMENT_ARRAY_BUFFER),this._addMeshVertexIndexed(A,
b.components,a,f,w,x,y,z)):this._addMeshVertexNonIndexed(b.components,a,f,w,x,y,z);h.finalize();m&&m.finalize();k&&k.finalize();p&&p.finalize();A&&A.finalize();q&&q.finalize();e||c.finalize();b=this.gltf.meshes.length;this.gltf.meshes.push(a);return b};n._flipYZAxis=function({position:b,normal:a,tangent:c}){this._flipYZBuffer(b,3);this._flipYZBuffer(a,3);this._flipYZBuffer(c,4)};n._flipYZBuffer=function(b,a){if(null!=b)for(let c=1,e=2;c<b.length;c+=a,e+=a){const f=b[c];b[c]=b[e];b[e]=-f}};n._addMaterial=
function(b){if(null!==b){var a=this._materialMap.indexOf(b);if(-1!==a)return a;this.gltf.materials||(this.gltf.materials=[]);a={};switch(b.alphaMode){case "mask":a.alphaMode=g.AlphaMode.MASK;break;case "auto":case "blend":a.alphaMode=g.AlphaMode.BLEND}.5!==b.alphaCutoff&&(a.alphaCutoff=b.alphaCutoff);b.doubleSided&&(a.doubleSided=b.doubleSided);a.pbrMetallicRoughness={};var c=e=>{e=e.toRgba();e[0]=(e[0]/255)**2.1;e[1]=(e[1]/255)**2.1;e[2]=(e[2]/255)**2.1;return e};null!=b.color&&(a.pbrMetallicRoughness.baseColorFactor=
c(b.color));null!=b.colorTexture&&(a.pbrMetallicRoughness.baseColorTexture=this._createTextureInfo(b.colorTexture,b.colorTextureTransform));null!=b.normalTexture&&(a.normalTexture=this._createTextureInfo(b.normalTexture,b.normalTextureTransform));b instanceof T?(null!=b.emissiveTexture&&(a.emissiveTexture=this._createTextureInfo(b.emissiveTexture,b.emissiveTextureTransform)),null!=b.emissiveColor&&(c=c(b.emissiveColor),a.emissiveFactor=[c[0],c[1],c[2]]),null!=b.occlusionTexture&&(a.occlusionTexture=
this._createTextureInfo(b.occlusionTexture,b.occlusionTextureTransform)),null!=b.metallicRoughnessTexture&&(a.pbrMetallicRoughness.metallicRoughnessTexture=this._createTextureInfo(b.metallicRoughnessTexture,b.metallicRoughnessTextureTransform)),a.pbrMetallicRoughness.metallicFactor=b.metallic,a.pbrMetallicRoughness.roughnessFactor=b.roughness):(a.pbrMetallicRoughness.metallicFactor=1,a.pbrMetallicRoughness.roughnessFactor=1,E.warnOnce("Meshes exported to GLTF without MeshMaterialMetallicRoughness material will appear different when imported back."));
c=this.gltf.materials.length;this.gltf.materials.push(a);this._materialMap.push(b);return c}};n._createTextureInfo=function(b,a){b={index:this._addTexture(b)};if(!a)return b;b.extensions||(b.extensions={});b.extensions.KHR_texture_transform={scale:a.scale,offset:a.offset,rotation:P.deg2rad(a.rotation)};return b};n._addTexture=function(b){const a=this.gltf.textures??[];this.gltf.textures=a;return O.getOrCreateMapValue(this._textureMap,b,()=>{const c={sampler:this._addSampler(b),source:this._addImage(b)},
e=a.length;a.push(c);return e})};n._addImage=function(b){var a=this._imageMap.get(b);if(null!=a)return a;this.gltf.images||(this.gltf.images=[]);const c={};if(b.url)c.uri=b.url;else{a=b.data;c.extras=a;for(var e=0;e<this.gltf.images.length;++e)if(a===this.gltf.images[e].extras)return e;e=this.gltf.extras;switch(e.options.imageOutputType){case g.ImageOutputType.GLB:const f=e.binChunkBuffer.addBufferView(l.DataType.UNSIGNED_BYTE,g.AttributeType.SCALAR);D.isEncodedMeshTexture(a)?null!=a.data&&f.writeOutToBuffer(a.data,
0):(a=C.imageToArrayBuffer(a).then(({data:h,type:d})=>{c.mimeType=d;return h}),f.writeAsync(a).then(()=>{f.finalize()}));c.bufferView=f.index;break;case g.ImageOutputType.DataURI:D.isEncodedMeshTexture(a)?E.warnOnce("Image export for basis compressed textures not available."):c.uri=C.imageToDataURI(a);break;default:D.isEncodedMeshTexture(a)?E.warnOnce("Image export for basis compressed textures not available."):e.promises.push(C.imageToArrayBuffer(a).then(({data:h,type:d})=>{c.uri=h;c.mimeType=d}))}}a=
this.gltf.images.length;this.gltf.images.push(c);this._imageMap.set(b,a);return a};n._addSampler=function(b){this.gltf.samplers||(this.gltf.samplers=[]);var a=l.TextureWrapMode.REPEAT;let c=l.TextureWrapMode.REPEAT;if("string"===typeof b.wrap)switch(b.wrap){case "clamp":c=a=l.TextureWrapMode.CLAMP_TO_EDGE;break;case "mirror":c=a=l.TextureWrapMode.MIRRORED_REPEAT}else{switch(b.wrap.vertical){case "clamp":c=l.TextureWrapMode.CLAMP_TO_EDGE;break;case "mirror":c=l.TextureWrapMode.MIRRORED_REPEAT}switch(b.wrap.horizontal){case "clamp":a=
l.TextureWrapMode.CLAMP_TO_EDGE;break;case "mirror":a=l.TextureWrapMode.MIRRORED_REPEAT}}b={wrapS:a,wrapT:c};for(a=0;a<this.gltf.samplers.length;++a)if(JSON.stringify(b)===JSON.stringify(this.gltf.samplers[a]))return a;a=this.gltf.samplers.length;this.gltf.samplers.push(b);return a};n._addAccessor=function(b,a){this.gltf.accessors||(this.gltf.accessors=[]);b={bufferView:b,byteOffset:a.byteOffset,componentType:a.componentType,count:a.count,type:a.type,min:a.min,max:a.max,name:a.name};a.normalized&&
(b.normalized=!0);a=this.gltf.accessors.length;this.gltf.accessors.push(b);return a};n._addMeshVertexIndexed=function(b,a,c,e,f,h,d,m){for(const k of a){b.startAccessor("INDICES");for(a=0;a<k.faces.length;++a)b.push(k.faces[a]);a=b.endAccessor();a={attributes:{POSITION:e},indices:this._addAccessor(b.index,a),material:this._addMaterial(k.material)};f&&"flat"!==k.shading&&(a.attributes.NORMAL=f);h&&(a.attributes.TEXCOORD_0=h);d&&"flat"!==k.shading&&(a.attributes.TANGENT=d);m&&(a.attributes.COLOR_0=
m);c.primitives.push(a)}};n._addMeshVertexNonIndexed=function(b,a,c,e,f,h,d){c={attributes:{POSITION:c}};e&&(c.attributes.NORMAL=e);f&&(c.attributes.TEXCOORD_0=f);h&&(c.attributes.TANGENT=h);d&&(c.attributes.COLOR_0=d);b&&(c.material=this._addMaterial(b[0].material));a.primitives.push(c)};return N._createClass(M)}();H.GLTF=B;Object.defineProperty(H,Symbol.toStringTag,{value:"Module"})});