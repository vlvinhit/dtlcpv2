// All material copyright ESRI, All Rights Reserved, unless otherwise specified.
// See https://js.arcgis.com/4.27/esri/copyright.txt for details.
//>>built
define("exports ../../../geometry ../../../core/Error ../../../core/screenUtils ../../../geometry/SpatialReference ../../../geometry/support/quantizationUtils ../../../geometry/support/spatialReferenceUtils ../../../layers/support/fieldUtils ../../../renderers/support/heatmapUtils ../../../statistics/utils ../../../support/arcadeOnDemand ../../../geometry/Point".split(" "),function(q,Q,w,G,H,I,C,D,E,y,J,K){function F(a,b){a=null!=a?a:"";null!=b&&b&&(a=a?"("+a+") AND ("+b+")":b);return a}function L(a){const b=
a.layer;return a.fields.filter(c=>!b.getField(c))}function M(a){const b=a.layer;return a.fields.filter(c=>{c=b.getFieldUsageInfo(c);return!c||!c.supportsStatistics})}let v=null;q.calculateHeatmapStats=function(a,b=18,c,d,g,u){const n=new Float64Array(g*u);b=Math.round(G.pt2px(b));let e=Number.POSITIVE_INFINITY,k=Number.NEGATIVE_INFINITY;var f=0;let p=0,h=0,l=0;c=E.createValueFunction(d,c);for(const {geometry:z,attributes:x}of a){const {x:r,y:m}=z;a=Math.max(0,r-b);f=Math.max(0,m-b);d=Math.min(u,m+
b);const N=Math.min(g,r+b),O=+c(x);for(let A=f;A<d;A++)for(let B=a;B<N;B++){f=A*g+B;const P=E.evaluateDensityKernel(B-r,A-m,b);var t=n[f];f=n[f]+=P*O;t=f-t;p+=t;h+=t*t;f<e&&(e=f);f>k&&(k=f);l++}}return l?{mean:p/l,stdDev:Math.sqrt((h-p*p/l)/l),min:e,max:k,mid:(k-e)/2,count:l}:{mean:0,stddev:0,min:0,max:0,mid:0,count:0}};q.getDataValues=async function(a,b){if(!b)return[];const {field:c,field2:d,field3:g,fieldDelimiter:u}=a,n=a.valueExpression,e=a.normalizationType,k=a.normalizationField,f=a.normalizationTotal,
p=[],h=a.viewInfoParams;let l=null,t=null;if(n){if(!v){const {arcadeUtils:x}=await J.loadArcade();v=x}v.hasGeometryOperations(n)&&await v.enableGeometryOperations();l=v.createFunction(n);t=h&&v.getViewInfo({viewingMode:h.viewingMode,scale:h.scale,spatialReference:new H(h.spatialReference)})}a=a.fieldInfos;const z=b[0]&&"declaredClass"in b[0]&&"esri.Graphic"===b[0].declaredClass||!a?null:{fields:a};b.forEach(x=>{var r=x.attributes;if(n){var m=v.createExecContext(z?{...x,layer:z}:x,t);m=v.executeFunction(l,
m)}else r&&(m=r[c],d&&(m=`${y.processNullValue(m)}${u}${y.processNullValue(r[d])}`,g&&(m=`${m}${u}${y.processNullValue(r[g])}`)));e&&"number"===typeof m&&isFinite(m)&&(r=r&&parseFloat(r[k]),m=y.getNormalizedValue(m,e,r,f));p.push(m)});return p};q.getRangeExpr=function(a,b,c){b=null!=b?a+" \x3e\x3d "+b:"";a=null!=c?a+" \x3c\x3d "+c:"";c="";return(c=b&&a?F(b,a):b||a)?"("+c+")":""};q.getSQLFilterForNormalization=function(a){const b=a.field,c=a.normalizationType;a=a.normalizationField;let d;if("field"===
c)d="(NOT "+a+" \x3d 0)";else if("log"===c||"natural-log"===c||"square-root"===c)d=`(${b} > 0)`;return d};q.getSumOfAttributesExpr=function(a,b,c){const d=[],g=[],u=[],n=[],e=[];a.forEach((p,h)=>{const l=p.field?"field":"expression",t=p.field||p.valueExpression;p.field?(e.push(t),g.push(`var ${l}${h} = Number($feature["${t}"]);`)):(d.push(`function getValueForExpr${h}() {\n  ${t} \n}`),g.push(`var ${l}${h} = Number(getValueForExpr${h}());`));c||u.push(`${l}${h} = IIf(${l}${h} < 0, 0, ${l}${h});`);
n.push(`${l}${h}`)});a="return sum;";const k=d.length?null:e.reduce((p,h)=>`${p} + ${h}`);let f=null;b||c?b?c||(a="return IIf(sum \x3e\x3d 0, sum, null);",k&&(f=`(( ${k} ) >= 0)`)):(a="return IIf(sum !\x3d 0, sum, null);",k&&(f=`(( ${k} ) <> 0)`)):(a="return IIf(sum \x3e 0, sum, null);",k&&(f=`(( ${k} ) > 0)`));return{valueExpression:[d.length?d.join("\n"):"",g.join("\n"),u.join("\n"),`var sum = ${n.join(" + ")};`,a].filter(Boolean).join("\n\n"),sqlExpression:k,sqlWhere:f}};q.mergeWhereClauses=F;
q.quantizeFeatures=function(a,b,c,d){const g=C.isWrappable(c)?C.getInfo(c):null,u=g?Math.round((g.valid[1]-g.valid[0])/b.scale[0]):null;return a.map(n=>{const e=new K(n.geometry);I.quantizePoint(b,e,e,e.hasZ,e.hasM);if(g){var k=u??0,f=d[0];0>e.x?e.x+=k:e.x>f&&(e.x-=k)}n.geometry=e;return n})};q.verifyBasicFieldValidity=function(a,b,c){const d=L({layer:a,fields:b});if(d.length)return new w(c,"Unknown fields: "+d.join(", ")+". You can only use fields defined in the layer schema");a=M({layer:a,fields:b});
if(a.length)return new w(c,"Unsupported fields: "+a.join(", ")+". You can only use fields that can be fetched i.e. AdapterFieldUsageInfo.supportsStatistics must be true")};q.verifyFieldType=function(a,b,c,d){let g;b?b.name!==a.objectIdField&&d.includes(b.type)||(g=new w(c,"'field' should be one of these types: "+d.join(","))):g=new w(c,"'field' is not defined in the layer schema");return g};q.verifyFilterValidty=function(a,b){if(a&&"intersects"!==a.spatialRelationship)return new w(b,"Only 'intersects' spatialRelationship is supported for featureFilter")};
q.verifyNumericField=function(a,b,c){let d;b?b.name!==a.objectIdField&&D.isNumericField(b)||(d=new w(c,"'field' should be one of these numeric types: "+D.numericTypes.join(","))):d=new w(c,"'field' is not defined in the layer schema");return d};Object.defineProperty(q,Symbol.toStringTag,{value:"Module"})});