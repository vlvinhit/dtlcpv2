// All material copyright ESRI, All Rights Reserved, unless otherwise specified.
// See https://js.arcgis.com/4.27/esri/copyright.txt for details.
//>>built
define("../../../chunks/_rollupPluginBabelHelpers ../../../chunks/tslib.es6 ../../../core/arrayUtils ../../../core/Error ../../../core/maybe ../../../core/promiseUtils ../../../core/accessorSupport/decorators/property ../../../core/accessorSupport/ensureType ../../../core/has ../../../core/accessorSupport/decorators/subclass ../../../layers/support/arcgisLayerUrl ../../../layers/support/fieldUtils ../../../rest/generateRenderer ../../../rest/support/GenerateRendererParameters ../../../rest/support/StatisticDefinition ../../../rest/support/UniqueValueDefinition ../../statistics/support/predominanceUtils ../../statistics/support/utils ../../statistics/support/WorkerClient ../utils ./InMemoryLayerAdapter ./support/utils ../../../statistics/utils".split(" "),
function(G,H,I,w,M,y,N,B,W,O,P,C,Q,D,R,S,J,r,T,K,U,m,x){B=function(L){function E(){var a=L.apply(this,arguments)||this;a.adapterName="feature-layer-adapter";return a}G._inherits(E,L);var n=E.prototype;n._isStatsSupportedOnService=function(){const a=this.layer;if(!a.get("capabilities.query.supportsStatistics")||"multipatch"===this.geometryType&&!P.isHostedAgolService(a.url)&&10.5>a.version)throw new w(`${this.adapterName}:not-supported`,"Layer does not support statistics query");return Promise.resolve()};
n._fetchFeaturesFromService=function(a,c){return this.layer.queryFeatures(a,{signal:c}).then(b=>b.features)};n._fetchFeaturesJSONFromService=function(a,c){return this._fetchFeaturesFromService(a,c).then(m.ensureFeaturesJSON)};n._summaryStatsFromGenRend=function(a){const c=a.normalizationType,b=a.normalizationField;return this.classBreaks({field:a.field,numClasses:5,classificationMethod:"standard-deviation",standardDeviationInterval:.25,normalizationType:c,normalizationField:"field"===c?b:void 0,minValue:a.minValue,
maxValue:a.maxValue,filter:a.filter,signal:a.signal}).then(d=>{let f,k;d.classBreakInfos?.some(h=>{h.hasAvg&&(f=h);return!!f});if(f){var g=f.maxValue-f.minValue;k=f.minValue+g/2;g*=4}return x.processSummaryStatisticsResult({min:d.minValue,max:d.maxValue,avg:k,stddev:g})})};n._summaryStatsFromServiceQuery=async function(a,c){await this._isStatsSupportedOnService();"percent-of-total"===a.normalizationType&&(a.normalizationTotal=await this._getNormalizationTotal(a.field,a.normalizationType,a.filter));
const b=m.getSummaryStatsQuery(this,a,c);a=await this.layer.queryFeatures(b,{signal:a.signal});c=m.getSummaryStatisticsFromFeatureSet(a,c);return x.processSummaryStatisticsResult(c)};n._uvFromGenRenderer=function(a,c){const b=a.field??void 0,d=new S;d.attributeField=b;const f=new D;f.classificationDefinition=d;return this.generateRenderer(f,a.signal).then(k=>{const g={},h=this.getField(b);k.uniqueValues.forEach(e=>{let l=e.value;if(null==l||""===l||"string"===typeof l&&(""===l.trim()||"\x3cnull\x3e"===
l.toLowerCase()))l=null;null==g[l]?g[l]={count:e.count,data:C.isNumericField(h)&&l?Number(l):l}:g[l].count+=e.count});return{count:g}}).then(k=>x.createUVResult(k,[c],a.returnAllCodedValues))};n._uvFromServiceQuery=async function(a,c){return this._isStatsSupportedOnService().then(()=>this.layer.queryFeatures(m.getUVQuery(this,a),{signal:a.signal})).then(b=>m.getUniqueValuesFromFeatureSet(b,{layer:this,field:a.field,field2:a.field2,field3:a.field3,fieldDelimiter:K.FIELD_DELIMITER,view:a.view,signal:a.signal})).then(b=>
x.createUVResult(b,c,a.returnAllCodedValues,K.FIELD_DELIMITER))};n._calcBinsSQL=function(a,c,b){const d=[],f=c.length;c.forEach((k,g)=>{const [h,e]=k;k=null;k=0!==g||b?g!==f-1||b?r.mergeWhereClauses(`${a} >= ${h}`,`${a} ${g===f-1?" \x3c\x3d ":" \x3c "} ${e}`):`${a} >= ${h}`:`${a} < ${e}`;d.push("WHEN ("+k+") THEN "+(g+1))});return["CASE",d.join(" "),"ELSE 0 END"].join(" ")};n._getNormalizationTotal=function(a,c,b,d){return a&&"percent-of-total"===c?this.summaryStatistics({field:a,filter:b,signal:d}).then(f=>
f.sum):Promise.resolve(null)};n._getQueryParamsForExpr=function(a,c){const b=a.signal;if(!a.valueExpression&&!a.sqlExpression){const {field:f,normalizationType:k,normalizationField:g}=a;var d=f?this.getField(f):null;d=C.isDateField(d);c={field:f,normalizationType:k,normalizationField:g,normalizationTotal:c,layer:this};return{sqlExpression:d?m.msSinceUnixEpochSQL(this,f):m.getFieldExpr(c),sqlWhere:d?null:a.sqlWhere||r.getSQLFilterForNormalization({field:f,normalizationType:k,normalizationField:g}),
filter:a.filter,signal:b}}return{valueExpression:a.valueExpression,sqlExpression:a.sqlExpression,sqlWhere:a.sqlWhere,filter:a.filter,signal:b}};n._getDataRange=function(a,c,b){return null!=c&&null!=b?Promise.resolve({min:c,max:b}):this.summaryStatistics(a).then(d=>({min:d.min,max:d.max}))};n._histogramForExpr=function(a){return this._getNormalizationTotal(a.field,a.normalizationType,a.filter,a.signal).then(c=>{const b=this._getQueryParamsForExpr(a,c);return this._getDataRange(b,a.minValue,a.maxValue).then(d=>
{const f=d.min,k=d.max;if(null==f||null==k)return{bins:[],minValue:f,maxValue:k,normalizationTotal:c};const g=a.numBins||m.defaultNumBins;d=x.getEqualIntervalBins(f,k,g);d=this._calcBinsSQL(b.sqlExpression,d,null!=a.minValue&&null!=a.maxValue);const h=new R({statisticType:"count",outStatisticFieldName:"countOFExpr",onStatisticField:"1"}),e=this.layer.createQuery();e.where=r.mergeWhereClauses(e.where,b.sqlWhere);e.sqlFormat="standard";e.outStatistics=[h];e.groupByFieldsForStatistics=[d];e.orderByFields=
[d];m.updateQueryWithFeatureFilter(e,a.filter);return this._isStatsSupportedOnService().then(()=>this.layer.queryFeatures(e,{signal:b.signal})).then(l=>m.getHistogramFromFeatureSet(l,f,k,g,c))})})};n._binParamsFromGenRend=function(a,c){const {field:b,normalizationType:d,normalizationField:f,signal:k}=a,g=r.getSQLFilterForNormalization({field:b,normalizationType:d,normalizationField:f});a=new D({classificationDefinition:x.createClassBreaksDefinition({field:b,normalizationType:d,normalizationField:f,
classificationMethod:a.classificationMethod,standardDeviationInterval:a.standardDeviationInterval,breakCount:a.numBins||m.defaultNumBins}),where:r.mergeWhereClauses(g,c)});return this.generateRenderer(a,k).then(h=>{const {normalizationTotal:e,classBreaks:l}=h;return m.generateBinParams({field:b,normalizationType:d,normalizationField:f,normalizationTotal:e,classBreaks:l,where:g,layer:this})})};n._classBreaksFromGenRend=function(a){const {field:c,normalizationType:b,normalizationField:d,normalizationTotal:f,
signal:k}=a,g=r.getSQLFilterForNormalization({field:c,normalizationType:b,normalizationField:d});var h=m.getFieldExpr({field:c,normalizationType:b,normalizationField:d,normalizationTotal:f,layer:this});h=r.getRangeExpr(h,a.minValue,a.maxValue);const e=x.createClassBreaksDefinition({field:c,normalizationType:b,normalizationField:d,classificationMethod:a.classificationMethod,standardDeviationInterval:a.standardDeviationInterval,breakCount:a.numClasses||5}),l=new D;l.classificationDefinition=e;l.where=
r.mergeWhereClauses(g,h);return this.generateRenderer(l,k).then(p=>x.resolveCBResult(p,a.classificationMethod))};n.summaryStatistics=async function(a){const {field:c,normalizationType:b,sqlExpression:d,view:f,features:k,useFeaturesInView:g}=a,h=c?this.getField(c):null,e=C.isDateField(h),l=a.valueExpression||d,p=l&&!d,u=f&&"3d"===f.type;if(this._hasLocalSource||k||g||p)return p||k||g||u?this._summaryStatsFromMemory(a,h):this._summaryStatsFromClientQuery(a,e);if(!this.supportsSQLExpression&&(e||l||
"natural-log"===b||"square-root"===b))throw new w(`${this.adapterName}:not-supported`,"Layer does not support standardized SQL expression for queries");return(b&&!this.supportsSQLExpression?this._summaryStatsFromGenRend(a):this._summaryStatsFromServiceQuery(a,e)).catch(()=>{y.throwIfAborted(a.signal);return this._summaryStatsFromMemory(a,h)})};n.uniqueValues=async function(a){const {valueExpression:c,sqlExpression:b,features:d,useFeaturesInView:f,signal:k}=a,g=c&&(!b||!this.supportsSQLExpression),
h=this._hasLocalSource||d||f||g,e=a.view,l=e&&"3d"===e.type,p=await m.getDomainsForFields(a,this);return h?g||d||f||l?this._uvFromMemory(a,p):this._uvFromClientQuery(a,p):this._uvFromServiceQuery(a,p).catch(u=>{y.throwIfAborted(k);return!a.field||a.field2||a.field3||a.filter?u:this._uvFromGenRenderer(a,p[0])}).catch(()=>{y.throwIfAborted(k);return l?this._uvFromMemory(a,p):this._uvFromClientQuery(a,p)})};n.histogram=async function(a){const {field:c,normalizationType:b,normalizationField:d,classificationMethod:f,
view:k,filter:g,signal:h}=a;var e=c?this.getField(c):null;e=C.isDateField(e);const l=a.valueExpression||a.sqlExpression,p=l&&!a.sqlExpression,u=this.supportsSQLExpression,q=!f||"equal-interval"===f,v=a.minValue,z=a.maxValue,F=null!=v&&null!=z,A=a.numBins||m.defaultNumBins;if(this._hasLocalSource||a.features||a.useFeaturesInView||p)return this._histogramFromMemory(a);if((l||u)&&q){if(!u&&(l||"natural-log"===b||"square-root"===b))throw new w(`${this.adapterName}:not-supported`,"Layer does not support standardized SQL expression for queries");
return this._histogramForExpr(a)}if(e&&q)throw new w(`${this.adapterName}:not-supported`,"Normalization and date field are not allowed when layer does not support standardized SQL expression for queries");return b||!q?this._binParamsFromGenRend(a).then(t=>{if(!F)return m.getBins(this,t,c,A,k,g,h);if(v>t.max||z<t.min)throw new w(`${this.adapterName}:insufficient-data`,"Range defined by 'minValue' and 'maxValue' does not intersect available data range of the field");if(q)return m.getBins(this,{min:v,
max:z,sqlExpr:t.sqlExpr,excludeZerosExpr:t.excludeZerosExpr},c,A,k,g,h);t=m.getFieldExpr({field:c,normalizationType:b,normalizationField:d,normalizationTotal:t.normTotal,layer:this});t=r.getRangeExpr(t,v,z);return this._binParamsFromGenRend(a,t).then(V=>m.getBins(this,V,c,A,k,g,h))}):this._histogramForField(a)};n.classBreaks=async function(a){const c=!1!==a.analyzeData,b=this._hasLocalSource||a.features||a.useFeaturesInView||a.valueExpression||a.filter;return c&&b?this._classBreaksFromMemory(a):(c?
this._classBreaksFromGenRend(a):this._classBreaksFromInterpolation(a)).catch(()=>{y.throwIfAborted(a.signal);return this._classBreaksFromMemory(a)})};n.queryFeatureCount=async function(a){if(this._hasLocalSource)throw new w(`${this.adapterName}:not-supported`,"Layer does not support count query");const c=this.layer,b=c.createQuery();b.where=r.mergeWhereClauses(b.where,a.whereClause);m.updateQueryWithFeatureFilter(b,a.filter);return c.queryFeatureCount(b,{signal:a.signal})};n.generateRenderer=async function(a,
c){const b=this.layer;if(this._hasLocalSource||10.1>b.version)throw new w(`${this.adapterName}:not-supported`,"Layer does not support generateRenderer operation (requires ArcGIS Server version 10.1+)");const d=b.createQuery();a.where=r.mergeWhereClauses(a.where,d.where);return Q.generateRenderer(b.parsedUrl.path,{source:b.dynamicDataSource??void 0,gdbVersion:b.gdbVersion??void 0},a,{signal:c})};n.heatmapStatistics=async function(a){const {field:c,fieldOffset:b,view:d,signal:f}=a;return(c&&null==b?
this.summaryStatistics({field:c,view:d,signal:f}):Promise.resolve(null)).then(k=>{let g=b||0;if(k){const {count:h,min:e,max:l}=k;h?e===l&&0===e?g=1:0>=l?g="abs":0>e&&(g=-1.01*e):g=1}return this._heatmapStatsFromMemory(a,g).then(h=>({...h,summaryStatistics:k,fieldOffset:g}))})};n.predominantCategories=async function(a){if(!this._hasLocalSource&&!this.supportsSQLExpression)throw new w(`${this.adapterName}:not-supported`,"Layer does not support advanced SQL expressions and standardized queries");const {fields:c,
view:b,signal:d}=a;a=J.getArcadeForPredominantCategory(c);const f=J.getSQLForPredominantCategoryName(c);a=b&&this._hasLocalSource?await this._uvFromMemory({valueExpression:a,view:b,signal:d}):await this._uvFromServiceQuery({sqlExpression:f.expression,valueExpression:a,signal:d});return m.getPredominantCategoriesFromUVInfos(a.uniqueValueInfos,c)};n.getSampleFeatures=async function(a,c){const {view:b,sampleSize:d,requiredFields:f,returnGeometry:k,filter:g,signal:h}=a,e=this.layer.createQuery(),l="json"===
c;e.outSpatialReference=a.spatialReference||b&&b.spatialReference;e.returnGeometry=!!k;e.outFields=f;m.updateQueryWithFeatureFilter(e,g);let p=[],u=!1;if(b)try{const q=await b.whenLayerView(this.layer);if(u=!m.getMissingFields(this,f,q).length)if(p=await this._fetchFeaturesFromMemory(q,e,h,c),p.length&&null!=d&&0<d&&d<=p.length)return I.pickRandom(p,d,1)}catch(q){y.throwIfAborted(h)}try{if(this._hasLocalSource)return u?p:l?this._fetchFeaturesJSONFromService(e,h):this._fetchFeaturesFromService(e,h);
const q=await this.queryFeatureCount({view:b,filter:g,signal:h}),v=this.layer.capabilities.query.maxRecordCount;c=-1===d?q:d;c=v&&c>v?v:c;if(q<=p.length||p.length>=v)return p;M.assertIsSome(b,"FeatureLayerAdapter: must have a view");const z=b.extent.width/b.width/b.scale*4E5;e.maxAllowableOffset=a.resolution||z;if(q<=c)return l?this._fetchFeaturesJSONFromService(e,h):this._fetchFeaturesFromService(e,h);if(2E4>=q){const F=this.layer.createQuery();m.updateQueryWithFeatureFilter(F,g);const A=await this.layer.queryObjectIds();
e.objectIds=I.pickRandom(A,c,1);return l?this._fetchFeaturesJSONFromService(e,h):this._fetchFeaturesFromService(e,h)}this.layer.get("capabilities.query.supportsPagination")&&(e.num=Math.min(c,2E4));return l?this._fetchFeaturesJSONFromService(e,h):this._fetchFeaturesFromService(e,h)}catch(q){return y.throwIfAborted(h),p}};n.load=function(a){const c=this.layer.load(a).then(async b=>{this.geometryType=b.geometryType;this.objectIdField=b.objectIdField;this.supportsSQLExpression=b.get("capabilities.query.supportsSqlExpression");
this.hasQueryEngine=this._hasLocalSource=!b.url&&!!b.source;this.minScale=b.minScale;this.maxScale=b.maxScale;this.fullExtent=b.fullExtent;this.workerClient=T.WorkerClient.getInstance();await this.workerClient.open(a.signal)});this.addResolvingPromise(c);return Promise.resolve(this)};return G._createClass(E)}(U);H.__decorate([N.property({constructOnly:!0})],B.prototype,"layer",void 0);return B=H.__decorate([O.subclass("esri.smartMapping.support.adapters.FeatureLayerAdapter")],B)});