// All material copyright ESRI, All Rights Reserved, unless otherwise specified.
// See https://js.arcgis.com/4.27/esri/copyright.txt for details.
//>>built
define("../../../chunks/_rollupPluginBabelHelpers ../../../chunks/tslib.es6 ../../../core/arrayUtils ../../../core/Error ../../../core/promiseUtils ../../../core/Logger ../../../core/accessorSupport/ensureType ../../../core/has ../../../core/accessorSupport/decorators/subclass ../../../layers/support/fieldType ../../../layers/support/fieldUtils ../../statistics/support/predominanceUtils ../../statistics/support/statsWorker ../../statistics/support/utils ../../statistics/support/WorkerClient ../utils ./FeatureLayerAdapter ./support/utils".split(" "),
function(A,F,G,p,H,x,O,P,I,J,B,K,u,L,M,C,N,q){x=function(D){function y(){var a=D.apply(this,arguments)||this;a.adapterName="feature-layer-binning-adapter";return a}A._inherits(y,D);var n=y.prototype;n._getNormalizationTotalFromMemory=async function(a,b,c){const {featuresJSON:e,graphics:m,layerView:g,query:k}=b;a=(!e&&!m&&g&&"queryAggregateSummaryStatistics"in g?await g.queryAggregateSummaryStatistics(k,{field:a},{signal:c}):e?await this.workerClient.summaryStatistics({field:a},e):await u.summaryStatistics({attribute:{field:a},
features:m})).sum;if(null==a)throw new p(`${this.adapterName}:invalid`,"invalid normalizationTotal");return a};n._processStatsFromMemoryParams=async function(a){const {features:b,filter:c}=a;if(b?.length)return this._getFilteredFeatures(b,c);const {view:e,field:m,field2:g,field3:k,normalizationField:d,valueExpression:f,returnGeometry:l,layerViewFunc:h,signal:t}=a;let r=a=null,v=null,z=null,E=null;if(e)try{if(a=await e.whenLayerView(this.layer),r=null!=h&&h in a&&"function"===typeof a[h]){await this._waitForLayerViewUpdate(a);
const w=await C.getFieldsList({field:m,field2:g,field3:k,normalizationField:d,valueExpression:f});q.getMissingFieldsForBinning(this,w).length?r=!1:(v="createAggregateQuery"in a?a.createAggregateQuery():null)?(v.outFields=w,v.returnGeometry=!1,q.updateQueryWithFeatureFilter(v,c)):r=!1;a.suspended&&(r=!1)}}catch{r=!1}if(!r&&(E=q.getFeatureReductionFields(this.layer).map(w=>w.toJSON()),z=await this._fetchFeaturesForStats({field:m,field2:g,field3:k,valueExpression:f,normalizationField:d,returnGeometry:l,
filter:c,view:e,signal:t},"json"),!z?.length))throw new p(`${this.adapterName}:insufficient-data`,"No features are available to calculate statistics");return{layerView:a,query:v,featuresJSON:z,fieldInfos:E}};n._summaryStatsFromMemory=async function(a,b){const {view:c,field:e,valueExpression:m,normalizationType:g,signal:k}=a,d={field:e,valueExpression:m,normalizationType:g,normalizationField:a.normalizationField,normalizationTotal:a.normalizationTotal,minValue:a.minValue,maxValue:a.maxValue},{featuresJSON:f,
graphics:l,layerView:h,query:t,fieldInfos:r}=await this._processStatsFromMemoryParams({...a,layerViewFunc:"queryAggregateSummaryStatistics"});m&&c&&(f||l)&&(d.fieldType=b?.type?J.kebabDict.toJSON(b.type):null,d.viewInfoParams=q.getViewInfoParams(c),d.fieldInfos=r);"percent-of-total"===g&&null==a.normalizationTotal&&(d.normalizationTotal=await this._getNormalizationTotalFromMemory(e,{featuresJSON:f,graphics:l,layerView:h,query:t},k));return!f&&!l&&h&&"queryAggregateSummaryStatistics"in h?h.queryAggregateSummaryStatistics(t,
d,{signal:k}):f?this.workerClient.summaryStatistics(d,f):u.summaryStatistics({attribute:d,features:l})};n._uvFromMemory=async function(a,b){const {view:c,field:e,valueExpression:m,returnAllCodedValues:g,signal:k}=a,{featuresJSON:d,graphics:f,layerView:l,query:h,fieldInfos:t}=await this._processStatsFromMemoryParams({...a,layerViewFunc:"queryAggregateUniqueValues"});a={field:e,field2:a.field2,field3:a.field3,fieldDelimiter:C.FIELD_DELIMITER,valueExpression:m,domains:b,returnAllCodedValues:g};m&&c&&
(d||f)&&(a.viewInfoParams=q.getViewInfoParams(c),a.fieldInfos=t);return!d&&!f&&l&&"queryAggregateUniqueValues"in l?l.queryAggregateUniqueValues(h,a,{signal:k}):d?this.workerClient.uniqueValues(a,d):u.uniqueValues({attribute:a,features:f})};n._histogramFromMemory=async function(a){const {view:b,field:c,valueExpression:e,signal:m}=a,{featuresJSON:g,graphics:k,layerView:d,query:f,fieldInfos:l}=await this._processStatsFromMemoryParams({...a,layerViewFunc:"queryAggregateHistogram"}),h={field:c,valueExpression:e,
normalizationType:a.normalizationType,normalizationField:a.normalizationField,normalizationTotal:a.normalizationTotal,minValue:a.minValue,maxValue:a.maxValue,standardDeviationInterval:a.standardDeviationInterval,classificationMethod:a.classificationMethod,numBins:a.numBins};e&&b&&(g||k)&&(h.viewInfoParams=q.getViewInfoParams(b),h.fieldInfos=l);"percent-of-total"===a.normalizationType&&null==a.normalizationTotal&&(h.normalizationTotal=await this._getNormalizationTotalFromMemory(c,{featuresJSON:g,graphics:k,
layerView:d,query:f},m));return!g&&!k&&d&&"queryAggregateHistogram"in d?d.queryAggregateHistogram(f,h,{signal:m}):g?this.workerClient.histogram(h,g):u.histogram({attribute:h,features:k})};n._classBreaksFromMemory=async function(a){const {view:b,field:c,valueExpression:e,signal:m}=a,{featuresJSON:g,graphics:k,layerView:d,query:f,fieldInfos:l}=await this._processStatsFromMemoryParams({...a,layerViewFunc:"queryAggregateClassBreaks"}),h={field:c,valueExpression:e,normalizationType:a.normalizationType,
normalizationField:a.normalizationField,normalizationTotal:a.normalizationTotal,minValue:a.minValue,maxValue:a.maxValue,standardDeviationInterval:a.standardDeviationInterval,classificationMethod:a.classificationMethod,numClasses:a.numClasses};e&&b&&(g||k)&&(h.viewInfoParams=q.getViewInfoParams(b),h.fieldInfos=l);"percent-of-total"===a.normalizationType&&null==a.normalizationTotal&&(h.normalizationTotal=await this._getNormalizationTotalFromMemory(c,{featuresJSON:g,graphics:k,layerView:d,query:f},m));
return!g&&!k&&d&&"queryAggregateClassBreaks"in d?d.queryAggregateClassBreaks(f,h,{signal:m}):g?this.workerClient.classBreaks(h,g):u.classBreaks({attribute:h,features:k})};n.getField=function(a=""){return q.getFeatureReductionFields(this.layer)?.find(b=>b.name.toLowerCase()===a?.toLowerCase())};n.getFieldUsageInfo=function(a){return this.getField(a)?{supportsLabelingInfo:!0,supportsRenderer:!0,supportsPopupTemplate:!0,supportsLayerQuery:!1,supportsStatistics:!0}:null};n.getFieldDomain=function(a,b){return null};
n.summaryStatistics=async function(a){var {field:b}=a;const c=b?this.getField(b):null,e=B.isDateField(c);b=a.sqlExpression&&!a.valueExpression&&!b;if(e||b)throw new p(`${this.adapterName}:not-supported`,"Date field and sqlExpression are not supported");return this._summaryStatsFromMemory(a,c)};n.uniqueValues=async function(a){const b=await q.getDomainsForFields(a,this);return this._uvFromMemory(a,b)};n.histogram=async function(a){var {field:b}=a,c=b?this.getField(b):null;c=B.isDateField(c);b=a.sqlExpression&&
!a.valueExpression&&!b;if(c||b)throw new p(`${this.adapterName}:not-supported`,"Date field and sqlExpression are not supported");return this._histogramFromMemory(a)};n.classBreaks=async function(a){return(!1!==a.analyzeData?this._classBreaksFromMemory(a):this._classBreaksFromInterpolation(a)).catch(()=>{H.throwIfAborted(a.signal);return this._classBreaksFromMemory(a)})};n.queryFeatureCount=async function(a){const b=await a.view?.whenLayerView(this.layer);if(!(b&&"queryAggregateCount"in b&&b.queryAggregateCount))throw new p(`${this.adapterName}:not-supported`,
"LayerView is not supported.");await this._waitForLayerViewUpdate(b);const c=b.createAggregateQuery();c.where=L.mergeWhereClauses(c.where,a.whereClause);q.updateQueryWithFeatureFilter(c,a.filter);return b.queryAggregateCount(c,{signal:a.signal})};n.generateRenderer=function(a,b){throw new p(`${this.adapterName}:not-supported`,"'generateRenderer' is not supported.");};n.heatmapStatistics=function(a){throw new p(`${this.adapterName}:not-supported`,"'heatmapStatistics' is not supported.");};n.predominantCategories=
async function(a){const {fields:b,view:c,signal:e}=a;a=K.getArcadeForPredominantCategory(b);a=await this._uvFromMemory({valueExpression:a,view:c,signal:e});return q.getPredominantCategoriesFromUVInfos(a.uniqueValueInfos,b)};n.getSampleFeatures=async function(a,b){const {view:c,sampleSize:e,requiredFields:m,returnGeometry:g,filter:k,signal:d}=a;if(!c)throw new p(`${this.adapterName}:not-supported`,"'view' is required to get sample features for binning.");if("3d"===c.type)throw new p(`${this.adapterName}:not-supported`,
"3d 'view' is not supported to get sample features for binning.");const f=await c.whenLayerView(this.layer);if(!("queryAggregateJSON"in f&&f.queryAggregateJSON&&"queryAggregates"in f&&f.queryAggregates))throw new p(`${this.adapterName}:not-supported`,"LayerView is not supported.");await this._waitForLayerViewUpdate(f);if(q.getMissingFieldsForBinning(this,m).length)throw new p(`${this.adapterName}:insufficient-data`,"Layer does not have required fields");b="json"===b;const l=f.createAggregateQuery();
l.outSpatialReference=a.spatialReference||c&&c.spatialReference;l.returnGeometry=!!g;l.outFields=m;q.updateQueryWithFeatureFilter(l,k);({features:a}=b?await f.queryAggregateJSON(l,{signal:d}):await f.queryAggregates(l,{signal:d}));return a.length&&null!=e&&0<e&&e<=a.length?G.pickRandom(a,e,1):a};n.load=function(a){const b=this.layer.load(a).then(async c=>{this.geometryType="polygon";this.objectIdField=null;this._hasLocalSource=this.supportsSQLExpression=!1;this.hasQueryEngine=!0;this.minScale=c.minScale;
this.maxScale=c.maxScale;this.fullExtent=c.fullExtent;if("geometryType"in c&&"point"!==c.geometryType)throw new p(`${this.adapterName}:invalid-parameters`,"Only 'point' geometry type is supported");c="featureReduction"in c?c.featureReduction:null;if("binning"!==c?.type&&"cluster"!==c?.type)throw new p(`${this.adapterName}:invalid-parameters`,`Feature reduction type ${c?.type} is not supported`);this.workerClient=M.WorkerClient.getInstance();await this.workerClient.open(a.signal)});this.addResolvingPromise(b);
return Promise.resolve(this)};return A._createClass(y)}(N);return x=F.__decorate([I.subclass("esri.smartMapping.support.adapters.FeatureLayerBinningAdapter")],x)});