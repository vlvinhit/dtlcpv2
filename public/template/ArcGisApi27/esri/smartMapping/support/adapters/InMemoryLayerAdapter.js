// All material copyright ESRI, All Rights Reserved, unless otherwise specified.
// See https://js.arcgis.com/4.27/esri/copyright.txt for details.
//>>built
define("require ../../../chunks/_rollupPluginBabelHelpers ../../../chunks/tslib.es6 ../../../core/arrayUtils ../../../core/Error ../../../core/Logger ../../../core/maybe ../../../core/promiseUtils ../../../core/reactiveUtils ../../../core/accessorSupport/decorators/property ../../../core/accessorSupport/ensureType ../../../core/has ../../../core/accessorSupport/decorators/subclass ../../../geometry/support/quantizationUtils ../../../layers/support/fieldType ../../../layers/support/fieldUtils ../../../rest/support/QuantizationParameters ../../statistics/support/predominanceUtils ../../statistics/support/statsWorker ../../statistics/support/utils ../../statistics/support/WorkerClient ../utils ./LayerAdapter ./support/utils ../../../statistics/utils ../../../support/arcadeOnDemand".split(" "),
function(I,C,D,J,q,K,L,M,E,N,x,Y,O,P,Q,R,S,T,u,U,V,v,W,p,A,X){let y=null;x=function(F){function B(){var a=F.apply(this,arguments)||this;a._hasLocalSource=!1;a.adapterName="in-memory-layer-adapter";return a}C._inherits(B,F);var l=B.prototype;l.destroy=function(){this.workerClient?.destroy()};l._waitForLayerViewUpdate=async function(a){if(!a)throw new q(`${this.adapterName}:insufficient-data", "layerView is required to fetch the features`);const b=new AbortController,c=E.whenOnce(()=>!a.updating,b.signal);
await M.timeout(c,5E3,b).catch(d=>{K.getLogger(this).warn("LayerView is taking too long to update. Aborting fetch from layerView.");throw d;})};l._fetchFeatureSetFromMemory=async function(a,b,c){const d=this.layer;if(this._hasLocalSource)return d.queryFeatures(a);if(!b)throw new q(`${this.adapterName}:insufficient-data`,"view is required to fetch the features from layerView");b=await b.whenLayerView(this.layer);await this._waitForLayerViewUpdate(b);return b.queryFeatures(a,{signal:c})};l._fetchFeaturesFromMemory=
async function(a,b,c,d){const e=this.layer;d="json"===d;if(this._hasLocalSource)return a=await e.queryFeatures(b),d?p.ensureFeaturesJSON(a.features):a.features;await this._waitForLayerViewUpdate(a);if(d&&"queryFeaturesJSON"in a&&a.queryFeaturesJSON)return{features:d}=await a.queryFeaturesJSON(b,{signal:c}),d;if(!("queryFeatures"in a))throw new q(`${this.adapterName}:not-supported`,"'queryFeatures' is not supported on the layerView");a=await a.queryFeatures(b,{signal:c});return d?p.ensureFeaturesJSON(a.features):
a.features};l._fetchFeaturesForStats=function(a,b){return v.getFieldsList({field:a.field,field2:a.field2,field3:a.field3,normalizationField:a.normalizationField,valueExpression:a.valueExpression}).then(c=>this.getSampleFeatures({sampleSize:-1,view:a.view,returnGeometry:a.returnGeometry,filter:a.filter,requiredFields:c,signal:a.signal},b))};l._summaryStatsFromClientQuery=async function(a,b){const {view:c,signal:d}=a;a=p.getSummaryStatsQuery(this,a,b);a=await this._fetchFeatureSetFromMemory(a,c,d);
b=p.getSummaryStatisticsFromFeatureSet(a,b);return A.processSummaryStatisticsResult(b)};l._getNormalizationTotalFromMemory=async function(a,b,c){const {featuresJSON:d,graphics:e,layerView:f,query:g}=b;a=(!d&&!e&&f&&"querySummaryStatistics"in f?await f.querySummaryStatistics(g,{field:a},{signal:c}):d?await this.workerClient.summaryStatistics({field:a},d):await u.summaryStatistics({attribute:{field:a},features:e??[]})).sum;if(null==a)throw new q(`${this.adapterName}:invalid`,"invalid normalizationTotal");
return a};l._summaryStatsFromMemory=async function(a,b){const {view:c,field:d,valueExpression:e,normalizationType:f,signal:g}=a,h={field:d,valueExpression:e,normalizationType:f,normalizationField:a.normalizationField,normalizationTotal:a.normalizationTotal,minValue:a.minValue,maxValue:a.maxValue},{featuresJSON:k,graphics:n,layerView:m,query:r,fieldInfos:t}=await this._processStatsFromMemoryParams({...a,layerViewFunc:"querySummaryStatistics"});e&&c&&(k||n)&&(h.fieldType=b?.type?Q.kebabDict.toJSON(b.type):
null,h.viewInfoParams=p.getViewInfoParams(c),h.fieldInfos=t);"percent-of-total"===f&&null==a.normalizationTotal&&(h.normalizationTotal=await this._getNormalizationTotalFromMemory(d,{featuresJSON:k,graphics:n,layerView:m,query:r},g));return!k&&!n&&m&&"querySummaryStatistics"in m?m.querySummaryStatistics(r,h,{signal:g}):k?this.workerClient.summaryStatistics(h,k):u.summaryStatistics({attribute:h,features:n})};l._getFilteredFeatures=async function(a,b){let c=[];if("intersects"===b?.spatialRelationship){const {intersect:d}=
await new Promise((e,f)=>I(["../../../geometry/geometryEngineAsync"],e,f));b=null!=b.geometry?b.geometry:null;for(const e of a){const f=null!=e.geometry?e.geometry:null;f&&b&&await d(f,b)&&c.push(e)}}else c=a;return a.length&&"declaredClass"in a[0]&&"esri.Graphic"===a[0].declaredClass?{graphics:c}:{featuresJSON:c}};l._processStatsFromMemoryParams=async function(a){const {features:b,filter:c}=a;if(b?.length)return this._getFilteredFeatures(b,c);const {view:d,field:e,field2:f,field3:g,normalizationField:h,
valueExpression:k,layerViewFunc:n,signal:m}=a;a=a.returnGeometry;null==a&&k&&(y||({arcadeUtils:a}=await X.loadArcade(),y=a),(a=y.hasGeometryOperations(k))&&await y.enableGeometryOperations());let r=null,t=null,w=null,G=null,H=null;if(d)try{r=await d.whenLayerView(this.layer),t=null!=n&&n in r&&"function"===typeof r[n]}catch{t=!1}if(t)try{await this._waitForLayerViewUpdate(r);const z=await v.getFieldsList({field:e,field2:f,field3:g,normalizationField:h,valueExpression:k});p.getMissingFields(this,z,
r).length?t=!1:(w=this.layer.createQuery(),w.outFields=z,w.returnGeometry=!1,p.updateQueryWithFeatureFilter(w,c));r.suspended&&(t=!1)}catch{t=!1}t||(G=await this._fetchFeaturesForStats({field:e,field2:f,field3:g,valueExpression:k,normalizationField:h,returnGeometry:a,filter:c,view:d,signal:m},"json"),H=(await v.getFieldsList({valueExpression:k})).map(z=>this.getField(z)?.toJSON()).filter(Boolean));return{layerView:r,query:w,featuresJSON:G,fieldInfos:H}};l._uvFromClientQuery=async function(a,b){const {view:c,
signal:d}=a;var e=p.getUVQuery(this,a);e=await this._fetchFeatureSetFromMemory(e,c,d);e=await p.getUniqueValuesFromFeatureSet(e,{layer:this,field:a.field,field2:a.field2,field3:a.field3,fieldDelimiter:v.FIELD_DELIMITER,view:a.view,signal:a.signal});return A.createUVResult(e,b,a.returnAllCodedValues,v.FIELD_DELIMITER)};l._uvFromMemory=async function(a,b){const {view:c,field:d,valueExpression:e,returnAllCodedValues:f,signal:g}=a,{featuresJSON:h,graphics:k,layerView:n,query:m,fieldInfos:r}=await this._processStatsFromMemoryParams({...a,
layerViewFunc:"queryUniqueValues"});a={field:d,field2:a.field2,field3:a.field3,fieldDelimiter:v.FIELD_DELIMITER,valueExpression:e,domains:b,returnAllCodedValues:f};e&&c&&(h||k)&&(a.viewInfoParams=p.getViewInfoParams(c),a.fieldInfos=r);return!h&&!k&&n&&"queryUniqueValues"in n?n.queryUniqueValues(m,a,{signal:g}):h?this.workerClient.uniqueValues(a,h):u.uniqueValues({attribute:a,features:k})};l._histogramForField=function(a){let b=null;b=null!=a.minValue&&null!=a.maxValue?Promise.resolve({min:a.minValue,
max:a.maxValue}):this.summaryStatistics(a).then(c=>{if(!c.count)throw new q(`${this.adapterName}:insufficient-data`,"Either the layer has no features or none of the features have data for the field");return{min:c.min,max:c.max}});return b.then(c=>p.getBins(this,{min:c.min,max:c.max},a.field,a.numBins??void 0,a.view,a.filter,a.signal))};l._histogramFromMemory=async function(a){const {view:b,field:c,valueExpression:d,signal:e}=a,{featuresJSON:f,graphics:g,layerView:h,query:k,fieldInfos:n}=await this._processStatsFromMemoryParams({...a,
layerViewFunc:"queryHistogram"}),m={field:c,valueExpression:d,normalizationType:a.normalizationType,normalizationField:a.normalizationField,normalizationTotal:a.normalizationTotal,minValue:a.minValue,maxValue:a.maxValue,standardDeviationInterval:a.standardDeviationInterval,classificationMethod:a.classificationMethod,numBins:a.numBins};d&&b&&(f||g)&&(m.viewInfoParams=p.getViewInfoParams(b),m.fieldInfos=n);"percent-of-total"===a.normalizationType&&null==a.normalizationTotal&&(m.normalizationTotal=await this._getNormalizationTotalFromMemory(c,
{featuresJSON:f,graphics:g,layerView:h,query:k},e));return!f&&!g&&h&&"queryHistogram"in h?h.queryHistogram(k,m,{signal:e}):f?this.workerClient.histogram(m,f):u.histogram({attribute:m,features:g})};l._classBreaksFromInterpolation=function(a){const {minValue:b,maxValue:c}=a,d=a.numClasses||5,e=[],f=(c-b)/d;for(let g=0;g<d;g++){const h=b+g*f;e.push({minValue:h,maxValue:h+f})}e[d-1].maxValue=c;a=A.resolveCBResult({classBreaks:e,normalizationTotal:a.normalizationTotal},a.classificationMethod);return Promise.resolve(a)};
l._classBreaksFromMemory=async function(a){const {view:b,field:c,valueExpression:d,signal:e}=a,{featuresJSON:f,graphics:g,layerView:h,query:k,fieldInfos:n}=await this._processStatsFromMemoryParams({...a,layerViewFunc:"queryClassBreaks"}),m={field:c,valueExpression:d,normalizationType:a.normalizationType,normalizationField:a.normalizationField,normalizationTotal:a.normalizationTotal,minValue:a.minValue,maxValue:a.maxValue,standardDeviationInterval:a.standardDeviationInterval,classificationMethod:a.classificationMethod,
numClasses:a.numClasses};d&&b&&(f||g)&&(m.viewInfoParams=p.getViewInfoParams(b),m.fieldInfos=n);"percent-of-total"===a.normalizationType&&null==a.normalizationTotal&&(m.normalizationTotal=await this._getNormalizationTotalFromMemory(c,{featuresJSON:f,graphics:g,layerView:h,query:k},e));return!f&&!g&&h&&"queryClassBreaks"in h?h.queryClassBreaks(k,m,{signal:e}):f?this.workerClient.classBreaks(m,f):u.classBreaks({attribute:m,features:g})};l._heatmapStatsFromMemory=async function(a,b){const {view:c,field:d,
radius:e}=a,{featuresJSON:f,graphics:g}=await this._processStatsFromMemoryParams({...a,returnGeometry:!0});L.assertIsSome(c,"InMemoryLayerAdapter: must have a view");a=new S({extent:c.extent,tolerance:"2d"===c.type?c.state.resolution:c.pixelSizeAt?.(c.center)});b={field:d,fieldOffset:b,radius:e,transform:P.toQuantizationTransform(a),spatialReference:c.spatialReference?.toJSON(),size:c.size};return f?.length||g?.length?f?this.workerClient.heatmapStatistics(b,f):u.heatmapStatistics({attribute:b,features:g}):
{count:0,min:null,max:null,avg:null,stddev:null}};l.getField=function(a=""){return this.layer.getField(a)};l.getFieldUsageInfo=function(a){return this.getField(a)?{supportsLabelingInfo:!0,supportsRenderer:!0,supportsPopupTemplate:!0,supportsLayerQuery:!0,supportsStatistics:!0}:null};l.getFieldDomain=function(a,b){return this.layer.getFieldDomain(a,b)};l.createQuery=function(){return this.layer.createQuery()};l.summaryStatistics=async function(a){const {field:b,valueExpression:c,sqlExpression:d,features:e,
view:f}=a,g=b?this.getField(b):null,h=R.isDateField(g),k=!!c,n="3d"===f?.type;if(!c&&d&&!this.supportsSQLExpression)throw new q(`${this.adapterName}:not-supported`,"Layer does not support standardized SQL expression for queries");return k||e||n?this._summaryStatsFromMemory(a,g):this._summaryStatsFromClientQuery(a,h)};l.uniqueValues=async function(a){const {valueExpression:b,sqlExpression:c,features:d,view:e}=a,f=await p.getDomainsForFields(a,this),g=!!b,h="3d"===e?.type;if(!b&&c&&!this.supportsSQLExpression)throw new q(`${this.adapterName}:not-supported`,
"Layer does not support standardized SQL expression for queries");return g||d||h?this._uvFromMemory(a,f):this._uvFromClientQuery(a,f)};l.histogram=async function(a){const {features:b,valueExpression:c,normalizationType:d,sqlExpression:e}=a,f=b||!!c;if(!c&&e&&!this.supportsSQLExpression)throw new q(`${this.adapterName}:not-supported`,"Layer does not support standardized SQL expression for queries");return f||d?this._histogramFromMemory(a):this._histogramForField(a)};l.classBreaks=async function(a){return!1!==
a.analyzeData?this._classBreaksFromMemory(a):this._classBreaksFromInterpolation(a)};l.queryFeatureCount=async function(a){const {whereClause:b,view:c,signal:d}=a;if(!c)throw new q(`${this.adapterName}:insufficient-data`,"view is required to fetch the features from layerView");a=this.layer.createQuery();a.where=U.mergeWhereClauses(a.where,b);const e=await c.whenLayerView(this.layer);await E.whenOnce(()=>!e.updating,d);return e.queryFeatureCount(a,{signal:d})};l.generateRenderer=async function(a,b){throw new q(`${this.adapterName}:not-supported`,
"Layer does not support generateRenderer operation");};l.predominantCategories=async function(a){const {fields:b,view:c,signal:d}=a;a=T.getArcadeForPredominantCategory(b);a=await this._uvFromMemory({valueExpression:a,view:c,signal:d});return p.getPredominantCategoriesFromUVInfos(a.uniqueValueInfos,b)};l.heatmapStatistics=async function(a){const {field:b,fieldOffset:c,view:d,signal:e}=a;return(b&&null==c?this.summaryStatistics({field:b,view:d,signal:e}):Promise.resolve(null)).then(f=>{let g=c||0;if(f){const {count:h,
min:k,max:n}=f;h?k===n&&0===k?g=1:0>=n?g="abs":0>k&&(g=-1.01*k):g=1}return this._heatmapStatsFromMemory(a,g).then(h=>({...h,summaryStatistics:f,fieldOffset:g}))})};l.getSampleFeatures=async function(a,b){const {view:c,sampleSize:d,requiredFields:e,returnGeometry:f,filter:g,signal:h}=a,k=this.layer.createQuery();k.outSpatialReference=a.spatialReference||c&&c.spatialReference;k.returnGeometry=!!f;k.outFields=e;p.updateQueryWithFeatureFilter(k,g);if(!c)throw new q(`${this.adapterName}:not-supported`,
"view is required to get sample features for Layer");a=await c.whenLayerView(this.layer);if(p.getMissingFields(this,e,a).length)throw new q(`${this.adapterName}:not-supported`,"Required fields need to be passed in the outFields for Layer");b=await this._fetchFeaturesFromMemory(a,k,h,b);return J.pickRandom(b,null!=d&&0<d&&d<=b.length?d:b.length,1)};l.load=function(a){const b=this.layer.load(a).then(async c=>{this.geometryType=c.geometryType;this.objectIdField=c.objectIdField;this.supportsSQLExpression=
c.get("capabilities.query.supportsSqlExpression");this.minScale=c.minScale;this.maxScale=c.maxScale;this.fullExtent=c.fullExtent;this._hasLocalSource=!1;this.hasQueryEngine=!0;this.workerClient=V.WorkerClient.getInstance();await this.workerClient.open(a.signal)});this.addResolvingPromise(b);return Promise.resolve(this)};return C._createClass(B)}(W);D.__decorate([N.property({constructOnly:!0})],x.prototype,"layer",void 0);return x=D.__decorate([O.subclass("esri.smartMapping.support.adapters.InMemoryLayerAdapter")],
x)});