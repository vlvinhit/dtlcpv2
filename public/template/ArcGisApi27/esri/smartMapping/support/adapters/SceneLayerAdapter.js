// All material copyright ESRI, All Rights Reserved, unless otherwise specified.
// See https://js.arcgis.com/4.27/esri/copyright.txt for details.
//>>built
define("../../../chunks/_rollupPluginBabelHelpers ../../../chunks/tslib.es6 ../../../Graphic ../../../core/arrayUtils ../../../core/Error ../../../core/promiseUtils ../../../core/reactiveUtils ../../../core/accessorSupport/decorators/property ../../../core/accessorSupport/ensureType ../../../core/has ../../../core/accessorSupport/decorators/subclass ../../../layers/support/fieldType ../../../layers/support/fieldUtils ../../../rest/support/FeatureSet ../../statistics/support/statsWorker ../../statistics/support/WorkerClient ../utils ./FeatureLayerAdapter ./LayerAdapter ./support/utils ../../../statistics/utils".split(" "),
function(y,z,A,B,p,t,G,H,v,O,I,J,C,D,u,K,E,L,M,r,N){v=function(F){function w(a){a=F.call(this,a)||this;a._featureLayerAdapter=null;a.workerClient=null;return a}y._inherits(w,F);var k=w.prototype;k.destroy=function(){this.workerClient?.destroy()};k._hasCachedStatistics=function(a){return this.layer.hasCachedStatistics(a)};k._updateQuery=function(a,b=[],e=[]){if(!a||!e.length)return a;const c=this.layer.objectIdField;a=a.clone();b=b.filter(d=>{d=this.layer.getField(d);return!e.includes(d.name)});const f=
b.some(d=>this.layer.getField(d).name===c);a.outFields=f?b:[...b,c];return a};k._fetchFeaturesFromMemory=async function(a,b,e){if(!a)throw new p("scene-layer-adapter:insufficient-data","view is required to fetch the features from layerView");const c=await a.whenLayerView(this.layer);var f=new AbortController;a=f.signal;const d=G.whenOnce(()=>!c.updating,a);await t.timeout(d,5E3,f);f=r.getMissingFields(this,e,c);t.throwIfAborted(a);b=this._updateQuery(b,e??[],f);b=await c.queryFeatures(b,{signal:a});
t.throwIfAborted(a);a=b.features;return f.length?c.whenGraphicAttributes(a,f):a};k._fetchFeaturesJSONFromMemory=async function(a,b,e){return this._fetchFeaturesFromMemory(a,b,e).then(r.ensureFeaturesJSON)};k._fetchFeaturesForStats=function(a,b){return E.getFieldsList({field:a.field,normalizationField:a.normalizationField,valueExpression:a.valueExpression}).then(e=>this.getSampleFeatures({sampleSize:-1,view:a.view,returnGeometry:a.returnGeometry,requiredFields:e,signal:a.signal},b))};k._processStatsFromMemoryParams=
async function(a){const b=a.features;if(b?.length)return b.length&&"declaredClass"in b[0]&&"esri.Graphic"===b[0].declaredClass?{graphics:b}:{featuresJSON:b};const {view:e,field:c,normalizationField:f,valueExpression:d,signal:l}=a;a=await this._fetchFeaturesForStats({field:c,valueExpression:d,normalizationField:f,view:e,signal:l});if(!a?.length)throw new p("scene-layer-adapter:insufficient-data","No features are available to calculate statistics");return{graphics:a}};k._generateFeatureSetForCachedHistogram=
function(a,b=a.minimum,e=a.maximum,c){const f=[];for(var d=0;d<c;d++)f[d]=0;d=a.counts.length;const l=a.minimum,h=a.maximum;for(let n=0;n<d;n++){var g=(n+.5)/d;g=((1-g)*l+g*h-b)/(e-b)*c;0<=g&&g<=c&&(f[g===c?c-1:Math.floor(g)]+=a.counts[n])}const m=[];f.forEach((n,q)=>{const x=new A({attributes:{}});x.attributes.EXPR_1=q+1;x.attributes.countOFExpr=n;m.push(x)});a=new D;a.features=m;return a};k._getCachedStatistics=function(a,b){const e=this.layer;return a.valueExpression||a.sqlExpression||a.sqlWhere||
a.minValue||a.maxValue?Promise.reject(new p("scene-layer-adapter:not-supported","This Layer does not support calculating statistics when 'valueExpression', 'sqlExpression', 'sqlWhere', 'minValue' or 'maxValue' is specified")):e.queryCachedStatistics(b?.name,{signal:a.signal}).then(c=>{c=c.stats;const {min:f,max:d,totalValuesCount:l}=c;let {avg:h,stddev:g,sum:m,variance:n,count:q}=c;if(0!==f||0!==d)h=0===h?null:h,m=0===m?null:m,g=0===g?null:g,n=0===n?null:n,q=0===q?null:q;null==q&&(null!=m&&null!=
h?q=Math.round(m/h):null!=l&&(q=l));return{avg:h,count:q,max:d,min:f,stddev:g,sum:m,variance:n}})};k._getNormalizationTotal=async function(a,b,e){a=(b?await this.workerClient.summaryStatistics({field:a},b):await u.summaryStatistics({attribute:{field:a},features:e})).sum;if(null==a)throw new p("scene-layer-adapter:invalid","invalid normalizationTotal");return a};k._getSummaryStatisticsFromMemory=async function(a,b){const {view:e,field:c,normalizationField:f,valueExpression:d}=a,{featuresJSON:l,graphics:h}=
await this._processStatsFromMemoryParams(a),g={field:c,valueExpression:d,normalizationType:a.normalizationType,normalizationField:f,normalizationTotal:a.normalizationTotal,minValue:a.minValue,maxValue:a.maxValue};a.valueExpression&&e&&l&&(g.fieldType=b?.type?J.kebabDict.toJSON(b.type):null,g.viewInfoParams=r.getViewInfoParams(e));"percent-of-total"===a.normalizationType&&null==a.normalizationTotal&&(g.normalizationTotal=await this._getNormalizationTotal(c,l,h));return l?this.workerClient.summaryStatistics(g,
l):u.summaryStatistics({attribute:g,features:h})};k._getCachedStatisticsForUniqueValues=function(a,b){const e=this.layer,c=b?.name,f=b&&a.field?this.getFieldDomain(a.field):null;return a.valueExpression||a.sqlExpression||a.sqlWhere?Promise.reject(new p("scene-layer-adapter:not-supported","This Layer does not support calculating statistics when 'valueExpression', 'sqlExpression' or 'sqlWhere' is specified")):e.queryCachedStatistics(c,{signal:a.signal}).then(d=>{var l=d.stats;if(!l.mostFrequentValues)throw Error();
d=d.labels&&d.labels.labels;const h={},g=[],m="countOF"+c;l.mostFrequentValues.forEach(n=>{const q=new A({attributes:{}});q.attributes[c]=b&&b.name!==e.objectIdField&&(C.isNumericField(b)||C.isDateField(b))?Number(n.value):n.value;q.attributes[m]=n.count;g.push(q)});d&&d.forEach(n=>{h[n.value]=n.label});l=new D;l.features=g;return r.getUniqueValuesFromFeatureSet(l,{layer:this,field:a.field,labels:h,view:a.view,signal:a.signal})}).then(d=>N.createUVResult(d,[f],a.returnAllCodedValues))};k._getUniqueValuesFromMemory=
async function(a,b){const {view:e,field:c,field2:f,field3:d,valueExpression:l,returnAllCodedValues:h}=a;b={field:c,field2:f,field3:d,fieldDelimiter:E.FIELD_DELIMITER,valueExpression:l,domains:b,returnAllCodedValues:h};const {featuresJSON:g,graphics:m}=await this._processStatsFromMemoryParams(a);a.valueExpression&&e&&g&&(b.viewInfoParams=r.getViewInfoParams(e));return g?this.workerClient.uniqueValues(b,g):u.uniqueValues({attribute:b,features:m})};k._getCachedStatisticsForHistogram=function(a,b){const e=
this.layer;return a.valueExpression||a.sqlExpression||a.sqlWhere||a.normalizationType?Promise.reject(new p("scene-layer-adapter:not-supported","This Layer does not support calculating statistics when 'valueExpression' or 'sqlExpression' or 'sqlWhere' or 'normalizationType' is specified")):e.queryCachedStatistics(b&&b.name,{signal:a.signal}).then(c=>{var f=c.stats;const {minValue:d,maxValue:l}=a;c=null!=d?d:f.min;const h=null!=l?l:f.max,g=a.numBins||10;f=this._generateFeatureSetForCachedHistogram(f.histogram,
c,h,g);return r.getHistogramFromFeatureSet(f,c,h,g)})};k._getClassBreaksFromMemory=async function(a){const {view:b,field:e,normalizationField:c,valueExpression:f}=a,{featuresJSON:d,graphics:l}=await this._processStatsFromMemoryParams(a),h={field:e,valueExpression:f,normalizationType:a.normalizationType,normalizationField:c,normalizationTotal:a.normalizationTotal,minValue:a.minValue,maxValue:a.maxValue,standardDeviationInterval:a.standardDeviationInterval,classificationMethod:a.classificationMethod,
numClasses:a.numClasses};a.valueExpression&&b&&d&&(h.viewInfoParams=r.getViewInfoParams(b));"percent-of-total"===a.normalizationType&&null==a.normalizationTotal&&(h.normalizationTotal=await this._getNormalizationTotal(e,d,l));return d?this.workerClient.classBreaks(h,d):u.classBreaks({attribute:h,features:l})};k._getHistogramFromMemory=async function(a){const {view:b,field:e}=a,{featuresJSON:c,graphics:f}=await this._processStatsFromMemoryParams(a),d={field:e,valueExpression:a.valueExpression,normalizationType:a.normalizationType,
normalizationField:a.normalizationField,normalizationTotal:a.normalizationTotal,minValue:a.minValue,maxValue:a.maxValue,standardDeviationInterval:a.standardDeviationInterval,classificationMethod:a.classificationMethod,numBins:a.numBins};a.valueExpression&&b&&c&&(d.viewInfoParams=r.getViewInfoParams(b));"percent-of-total"===a.normalizationType&&null==a.normalizationTotal&&(d.normalizationTotal=await this._getNormalizationTotal(e,c,f));return c?this.workerClient.histogram(d,c):u.histogram({attribute:d,
features:f})};k.getField=function(a){return this.layer.getField(a??"")};k.getFieldUsageInfo=function(a){a=this.getField(a);if(!a)return null;a=this.layer.getFieldUsageInfo(a.name);return{supportsLabelingInfo:a.supportsLabelingInfo,supportsPopupTemplate:a.supportsPopupTemplate,supportsRenderer:a.supportsRenderer,supportsLayerQuery:a.supportsLayerQuery,supportsStatistics:!0}};k.getFieldDomain=function(a,b){return this._featureLayerAdapter?this._featureLayerAdapter.getFieldDomain(a,b):null};k.createQuery=
function(){return this.layer.createQuery()};k.summaryStatistics=function(a){const b=this.getField(a.field);if(this._featureLayerAdapter)return this._featureLayerAdapter.summaryStatistics(a);if(a.filter)throw new p("scene-layer-adapter:not-supported","filter is not supported");return this._hasCachedStatistics(b&&b.name)?this._getCachedStatistics(a,b).catch(()=>{t.throwIfAborted(a.signal);return this._getSummaryStatisticsFromMemory(a,b)}):this._getSummaryStatisticsFromMemory(a,b)};k.uniqueValues=async function(a){if(this._featureLayerAdapter)return this._featureLayerAdapter.uniqueValues(a);
if(a.filter)throw new p("scene-layer-adapter:not-supported","filter is not supported");const b=await r.getDomainsForFields(a,this),{field:e,field2:c}=a,f=e&&c,d=this.getField(e);return!f&&d&&this._hasCachedStatistics(d.name)?this._getCachedStatisticsForUniqueValues(a,d).catch(()=>{t.throwIfAborted(a.signal);return this._getUniqueValuesFromMemory(a,b)}):this._getUniqueValuesFromMemory(a,b)};k.histogram=function(a){const b=this.getField(a.field);if(this._featureLayerAdapter)return this._featureLayerAdapter.histogram(a);
if(a.filter)throw new p("scene-layer-adapter:not-supported","filter is not supported");return b&&this._hasCachedStatistics(b.name)?this._getCachedStatisticsForHistogram(a,b).catch(()=>{t.throwIfAborted(a.signal);return this._getHistogramFromMemory(a)}):this._getHistogramFromMemory(a)};k.classBreaks=function(a){const b=this.getField(a.field);if(this._featureLayerAdapter)return this._featureLayerAdapter.classBreaks(a);if(a.filter)throw new p("scene-layer-adapter:not-supported","filter is not supported");
return this._hasCachedStatistics(b&&b.name)?Promise.reject(new p("scene-layer-adapter:not-supported","Cached stats not supported")):this._getClassBreaksFromMemory(a)};k.queryFeatureCount=function(a){return this._featureLayerAdapter?this._featureLayerAdapter.queryFeatureCount(a):Promise.reject(new p("scene-layer-adapter:not-supported","SceneLayer without associated FeatureLayer does not support count query"))};k.generateRenderer=function(a,b){return this._featureLayerAdapter?this._featureLayerAdapter.generateRenderer(a,
b):Promise.reject(new p("scene-layer-adapter:not-supported","SceneLayer without associated FeatureLayer does not support generateRenderer operation"))};k.heatmapStatistics=function(a){return this._featureLayerAdapter?this._featureLayerAdapter.heatmapStatistics(a):Promise.reject(new p("scene-layer-adapter:not-supported","SceneLayer without associated FeatureLayer does not support heatmapStatistics operation"))};k.predominantCategories=async function(a){if(this._featureLayerAdapter)return this._featureLayerAdapter.predominantCategories(a);
throw new p("scene-layer-adapter:not-supported","SceneLayer without associated FeatureLayer does not support predominantCategories");};k.getSampleFeatures=async function(a,b){if(a.filter)throw new p("scene-layer-adapter:not-supported","filter is not supported");const {view:e,sampleSize:c,requiredFields:f,returnGeometry:d,signal:l}=a;var h="json"===b;const g=this.createQuery();g.outFields=f;g.returnGeometry=!!d;g.where=null;g.num=c;let m=[];try{if(m=h?await this._fetchFeaturesJSONFromMemory(e,g,f):
await this._fetchFeaturesFromMemory(e,g,f),m.length&&null!=c&&0<c&&c<=m.length)return B.pickRandom(m,c,1)}catch(n){t.throwIfAborted(l)}h=null;this._featureLayerAdapter&&(a={...a},delete a.view,h=await this._featureLayerAdapter.getSampleFeatures(a,b));return h&&h.length?h:B.pickRandom(m,m.length,1)};k.load=function(a){const b=this.layer.load(a).then(async e=>{this.workerClient=K.WorkerClient.getInstance();await this.workerClient.open(a.signal);const c=e.associatedLayer;this.geometryType=e.geometryType;
if(null!=c)return this._featureLayerAdapter=new L({layer:c}),this._featureLayerAdapter.load(a).then(()=>{this.objectIdField=this._featureLayerAdapter.objectIdField;this.supportsSQLExpression=this._featureLayerAdapter.supportsSQLExpression;this.minScale=this._featureLayerAdapter.minScale;this.maxScale=this._featureLayerAdapter.maxScale;this.fullExtent=this._featureLayerAdapter.fullExtent});this.objectIdField=e.objectIdField;this.hasQueryEngine=this.supportsSQLExpression=!1;this.fullExtent=e.fullExtent});
this.addResolvingPromise(b);return Promise.resolve(this)};return y._createClass(w)}(M);z.__decorate([H.property({constructOnly:!0})],v.prototype,"layer",void 0);return v=z.__decorate([I.subclass("esri.smartMapping.support.adapters.SceneLayerAdapter")],v)});