// All material copyright ESRI, All Rights Reserved, unless otherwise specified.
// See https://js.arcgis.com/4.27/esri/copyright.txt for details.
//>>built
define("exports ../../../../chunks/_rollupPluginBabelHelpers ../../../../core/Error ../../../../core/Logger ../../../../core/MapUtils ../../../../core/promiseUtils ../../../../core/urlUtils ../../../../core/Version ../../../../chunks/mat4 ../../../../chunks/mat4f64 ../../../../chunks/quat ../../../../chunks/quatf64 ../../../../geometry/support/buffer/BufferView ../../../../chunks/scalar ../../../../core/has ./BinaryStreamReader ./enums ./fillDefaults ./pathUtils ./resourceUtils ../../../webgl/enums".split(" "),
function(y,H,f,I,J,C,r,D,q,t,K,L,k,z,E,F,A,B,M,u,g){function N(e){switch(e.componentType){case g.DataType.BYTE:return new k.BufferViewVec2i8(e.raw,e.byteOffset,e.byteStride,e.byteOffset+e.byteStride*e.entryCount);case g.DataType.UNSIGNED_BYTE:return new k.BufferViewVec2u8(e.raw,e.byteOffset,e.byteStride,e.byteOffset+e.byteStride*e.entryCount);case g.DataType.SHORT:return new k.BufferViewVec2i16(e.raw,e.byteOffset,e.byteStride,e.byteOffset+e.byteStride*e.entryCount);case g.DataType.UNSIGNED_SHORT:return new k.BufferViewVec2u16(e.raw,
e.byteOffset,e.byteStride,e.byteOffset+e.byteStride*e.entryCount);case g.DataType.UNSIGNED_INT:return new k.BufferViewVec2u32(e.raw,e.byteOffset,e.byteStride,e.byteOffset+e.byteStride*e.entryCount);case g.DataType.FLOAT:return new k.BufferViewVec2f(e.raw,e.byteOffset,e.byteStride,e.byteOffset+e.byteStride*e.entryCount)}}E=function(){function e(a,b,c,d){this._context=a;this.uri=b;this.json=c;this._glbBuffer=d;this._bufferLoaders=new Map;this._textureLoaders=new Map;this._textureCache=new Map;this._materialCache=
new Map;this._nodeParentMap=new Map;this._nodeTransformCache=new Map;this._supportedExtensions=["KHR_texture_basisu"];this._baseUri=M.splitURI(this.uri).dirPart;this._checkVersionSupported();this._checkRequiredExtensionsSupported();if(null==c.scenes)throw new f("gltf-loader-unsupported-feature","Scenes must be defined.");if(null==c.meshes)throw new f("gltf-loader-unsupported-feature","Meshes must be defined");if(null==c.nodes)throw new f("gltf-loader-unsupported-feature","Nodes must be defined.");
this._computeNodeParents()}e.load=async function(a,b,c){if(r.isDataProtocol(b)){var d=r.dataComponents(b);if(d&&"model/gltf-binary"!==d.mediaType)try{const l=JSON.parse(d.isBase64?atob(d.data):d.data);return new e(a,b,l)}catch{}d=r.dataToArrayBuffer(b);if(e._isGLBData(d))return this._fromGLBData(a,b,d)}if(b.endsWith(".gltf"))return c=await a.loadJSON(b,c),new e(a,b,c);d=await a.loadBinary(b,c);if(e._isGLBData(d))return this._fromGLBData(a,b,d);c=await a.loadJSON(b,c);return new e(a,b,c)};e._isGLBData=
function(a){if(null==a)return!1;a=new F.BinaryStreamReader(a);return 4<=a.remainingBytes()&&1179937895===a.readUint32()};e._fromGLBData=async function(a,b,c){c=await e._parseGLBData(c);return new e(a,b,c.json,c.binaryData)};e._parseGLBData=async function(a){const b=new F.BinaryStreamReader(a);if(12>b.remainingBytes())throw new f("gltf-loader-error","GLB binary data is insufficiently large.");var c=b.readUint32(),d=b.readUint32();const l=b.readUint32();if(1179937895!==c)throw new f("gltf-loader-error",
"Magic first 4 bytes do not fit to expected GLB value.");if(a.byteLength<l)throw new f("gltf-loader-error","GLB binary data is smaller than header specifies.");if(2!==d)throw new f("gltf-loader-unsupported-feature","An unsupported GLB container version was detected. Only version 2 is supported.");a=0;let m,n;for(;8<=b.remainingBytes();){c=b.readUint32();d=b.readUint32();if(0===a){if(1313821514!==d)throw new f("gltf-loader-error","First GLB chunk must be JSON.");if(0>c)throw new f("gltf-loader-error",
"No JSON data found.");m=await u.jsonFromBinaryData(b.readUint8Array(c))}else if(1===a){if(5130562!==d)throw new f("gltf-loader-unsupported-feature","Second GLB chunk expected to be BIN.");n=b.readUint8Array(c)}else I.getLogger("esri.views.3d.glTF").warn("[Unsupported Feature] More than 2 GLB chunks detected. Skipping.");a+=1}if(!m)throw new f("gltf-loader-error","No GLB JSON chunk detected.");return{json:m,binaryData:n}};var h=e.prototype;h.getBuffer=async function(a,b){const c=this.json.buffers[a];
if(null==c.uri){if(null==this._glbBuffer)throw new f("gltf-loader-error","GLB buffer not present");return this._glbBuffer}a=await this._getBufferLoader(a,b);if(a.byteLength!==c.byteLength)throw new f("gltf-loader-error","Buffer byte lengths should match.");return a};h._getBufferLoader=async function(a,b){const c=this._bufferLoaders.get(a);if(c)return c;b=this._context.loadBinary(this._resolveUri(this.json.buffers[a].uri),b).then(d=>new Uint8Array(d));this._bufferLoaders.set(a,b);return b};h.getAccessor=
async function(a,b){if(!this.json.accessors)throw new f("gltf-loader-unsupported-feature","Accessors missing.");a=this.json.accessors[a];if(null==a?.bufferView)throw new f("gltf-loader-unsupported-feature","Some accessor does not specify a bufferView.");if(a.type in[A.AttributeType.MAT2,A.AttributeType.MAT3,A.AttributeType.MAT4])throw new f("gltf-loader-unsupported-feature",`AttributeType ${a.type} is not supported`);const c=this.json.bufferViews[a.bufferView];b=await this.getBuffer(c.buffer,b);const d=
O[a.type],l=P[a.componentType],m=d*l,n=c.byteStride||m;return{raw:b.buffer,byteStride:n,byteOffset:b.byteOffset+(c.byteOffset||0)+(a.byteOffset||0),entryCount:a.count,isDenselyPacked:n===m,componentCount:d,componentByteSize:l,componentType:a.componentType,min:a.min,max:a.max,normalized:!!a.normalized}};h.getIndexData=async function(a,b){if(null!=a.indices)if(a=await this.getAccessor(a.indices,b),a.isDenselyPacked)switch(a.componentType){case g.DataType.UNSIGNED_BYTE:return new Uint8Array(a.raw,a.byteOffset,
a.entryCount);case g.DataType.UNSIGNED_SHORT:return new Uint16Array(a.raw,a.byteOffset,a.entryCount);case g.DataType.UNSIGNED_INT:return new Uint32Array(a.raw,a.byteOffset,a.entryCount)}else switch(a.componentType){case g.DataType.UNSIGNED_BYTE:return z.makeDense(this._wrapAccessor(k.BufferViewUint8,a));case g.DataType.UNSIGNED_SHORT:return z.makeDense(this._wrapAccessor(k.BufferViewUint16,a));case g.DataType.UNSIGNED_INT:return z.makeDense(this._wrapAccessor(k.BufferViewUint32,a))}};h.getPositionData=
async function(a,b){if(null==a.attributes.POSITION)throw new f("gltf-loader-unsupported-feature","No POSITION vertex data found.");a=await this.getAccessor(a.attributes.POSITION,b);if(a.componentType!==g.DataType.FLOAT)throw new f("gltf-loader-unsupported-feature","Expected type FLOAT for POSITION vertex attribute, but found "+g.DataType[a.componentType]);if(3!==a.componentCount)throw new f("gltf-loader-unsupported-feature","POSITION vertex attribute must have 3 components, but found "+a.componentCount.toFixed());
return this._wrapAccessor(k.BufferViewVec3f,a)};h.getNormalData=async function(a,b){if(null==a.attributes.NORMAL)throw new f("gltf-loader-error","No NORMAL vertex data found.");a=await this.getAccessor(a.attributes.NORMAL,b);if(a.componentType!==g.DataType.FLOAT)throw new f("gltf-loader-unsupported-feature","Expected type FLOAT for NORMAL vertex attribute, but found "+g.DataType[a.componentType]);if(3!==a.componentCount)throw new f("gltf-loader-unsupported-feature","NORMAL vertex attribute must have 3 components, but found "+
a.componentCount.toFixed());return this._wrapAccessor(k.BufferViewVec3f,a)};h.getTangentData=async function(a,b){if(null==a.attributes.TANGENT)throw new f("gltf-loader-error","No TANGENT vertex data found.");a=await this.getAccessor(a.attributes.TANGENT,b);if(a.componentType!==g.DataType.FLOAT)throw new f("gltf-loader-unsupported-feature","Expected type FLOAT for TANGENT vertex attribute, but found "+g.DataType[a.componentType]);if(4!==a.componentCount)throw new f("gltf-loader-unsupported-feature",
"TANGENT vertex attribute must have 4 components, but found "+a.componentCount.toFixed());return new k.BufferViewVec4f(a.raw,a.byteOffset,a.byteStride,a.byteOffset+a.byteStride*a.entryCount)};h.getTextureCoordinates=async function(a,b){if(null==a.attributes.TEXCOORD_0)throw new f("gltf-loader-error","No TEXCOORD_0 vertex data found.");a=await this.getAccessor(a.attributes.TEXCOORD_0,b);if(2!==a.componentCount)throw new f("gltf-loader-unsupported-feature","TEXCOORD_0 vertex attribute must have 2 components, but found "+
a.componentCount.toFixed());if(a.componentType===g.DataType.FLOAT)return this._wrapAccessor(k.BufferViewVec2f,a);if(!a.normalized)throw new f("gltf-loader-unsupported-feature","Integer component types are only supported for a normalized accessor for TEXCOORD_0.");return N(a)};h.getVertexColors=async function(a,b){if(null==a.attributes.COLOR_0)throw new f("gltf-loader-error","No COLOR_0 vertex data found.");a=await this.getAccessor(a.attributes.COLOR_0,b);if(4!==a.componentCount&&3!==a.componentCount)throw new f("gltf-loader-unsupported-feature",
"COLOR_0 attribute must have 3 or 4 components, but found "+a.componentCount.toFixed());if(4===a.componentCount){if(a.componentType===g.DataType.FLOAT)return this._wrapAccessor(k.BufferViewVec4f,a);if(a.componentType===g.DataType.UNSIGNED_BYTE)return this._wrapAccessor(k.BufferViewVec4u8,a);if(a.componentType===g.DataType.UNSIGNED_SHORT)return this._wrapAccessor(k.BufferViewVec4u16,a)}else if(3===a.componentCount){if(a.componentType===g.DataType.FLOAT)return this._wrapAccessor(k.BufferViewVec3f,a);
if(a.componentType===g.DataType.UNSIGNED_BYTE)return this._wrapAccessor(k.BufferViewVec3u8,a);if(a.componentType===g.DataType.UNSIGNED_SHORT)return this._wrapAccessor(k.BufferViewVec3u16,a)}throw new f("gltf-loader-unsupported-feature","Unsupported component type for COLOR_0 attribute: "+g.DataType[a.componentType]);};h.hasPositions=function(a){return void 0!==a.attributes.POSITION};h.hasNormals=function(a){return void 0!==a.attributes.NORMAL};h.hasVertexColors=function(a){return void 0!==a.attributes.COLOR_0};
h.hasTextureCoordinates=function(a){return void 0!==a.attributes.TEXCOORD_0};h.hasTangents=function(a){return void 0!==a.attributes.TANGENT};h.getMaterial=async function(a,b,c){var d=a.material?this._materialCache.get(a.material):void 0;if(!d){d=null!=a.material?B.material(this.json.materials[a.material]):B.material();const l=d.pbrMetallicRoughness,m=this.hasVertexColors(a),n=this.getTexture(l.baseColorTexture,b),v=this.getTexture(d.normalTexture,b),w=c?this.getTexture(d.occlusionTexture,b):void 0,
p=c?this.getTexture(d.emissiveTexture,b):void 0;b=c?this.getTexture(l.metallicRoughnessTexture,b):void 0;a=null!=a.material?a.material:-1;d={alphaMode:d.alphaMode,alphaCutoff:d.alphaCutoff,color:l.baseColorFactor,doubleSided:!!d.doubleSided,colorTexture:await n,normalTexture:await v,name:d.name,id:a,occlusionTexture:await w,emissiveTexture:await p,emissiveFactor:d.emissiveFactor,metallicFactor:l.metallicFactor,roughnessFactor:l.roughnessFactor,metallicRoughnessTexture:await b,hasVertexColors:m,ESRI_externalColorMixMode:d.extras.ESRI_externalColorMixMode,
colorTextureTransform:l?.baseColorTexture?.extensions?.KHR_texture_transform,normalTextureTransform:d.normalTexture?.extensions?.KHR_texture_transform,occlusionTextureTransform:d.occlusionTexture?.extensions?.KHR_texture_transform,emissiveTextureTransform:d.emissiveTexture?.extensions?.KHR_texture_transform,metallicRoughnessTextureTransform:l?.metallicRoughnessTexture?.extensions?.KHR_texture_transform}}return d};h.getTexture=async function(a,b){if(a){if(0!==(a.texCoord||0))throw new f("gltf-loader-unsupported-feature",
"Only TEXCOORD with index 0 is supported.");var c=a.index;a=this.json.textures[c];var d=B.textureSampler(null!=a.sampler?this.json.samplers[a.sampler]:{}),l=this._getTextureSourceId(a),m=this.json.images[l],n=await this._loadTextureImageData(c,a,b);return J.getOrCreateMapValue(this._textureCache,c,()=>{const v=p=>33071===p||33648===p||10497===p,w=p=>{throw new f("gltf-loader-error",`Unexpected TextureSampler WrapMode: ${p}`);};return{data:n,wrapS:v(d.wrapS)?d.wrapS:w(d.wrapS),wrapT:v(d.wrapT)?d.wrapT:
w(d.wrapT),minFilter:d.minFilter,name:m.name,id:c}})}};h.getNodeTransform=function(a){if(void 0===a)return G;var b=this._nodeTransformCache.get(a);if(!b){b=this.getNodeTransform(this._getNodeParent(a));const c=this.json.nodes[a];c.matrix?b=q.multiply(t.create(),b,c.matrix):c.translation||c.rotation||c.scale?(b=t.clone(b),c.translation&&q.translate(b,b,c.translation),c.rotation&&(x[3]=K.getAxisAngle(x,c.rotation),q.rotate(b,b,x[3],x)),c.scale&&q.scale(b,b,c.scale)):b=t.clone(b);this._nodeTransformCache.set(a,
b)}return b};h._wrapAccessor=function(a,b){return new a(b.raw,b.byteOffset,b.byteStride,b.byteOffset+b.byteStride*(b.entryCount-1)+b.componentByteSize*b.componentCount)};h._resolveUri=function(a){return r.makeAbsolute(a,this._baseUri)};h._getNodeParent=function(a){return this._nodeParentMap.get(a)};h._checkVersionSupported=function(){const a=D.Version.parse(this.json.asset.version,"glTF");Q.validate(a)};h._checkRequiredExtensionsSupported=function(){const a=this.json;if(a.extensionsRequired&&!a.extensionsRequired.every(b=>
this._supportedExtensions.includes(b)))throw new f("gltf-loader-unsupported-feature","gltf loader was not able to load unsupported feature. Required extensions: "+a.extensionsRequired.join(", "));};h._computeNodeParents=function(){this.json.nodes.forEach((a,b)=>{a.children&&a.children.forEach(c=>{this._nodeParentMap.set(c,b)})})};h._loadTextureImageData=async function(a,b,c){const d=this._textureLoaders.get(a);if(d)return d;b=this._createTextureLoader(b,c);this._textureLoaders.set(a,b);return b};
h._getTextureSourceId=function(a){if(void 0!==a.extensions&&null!==a.extensions.KHR_texture_basisu)return a.extensions.KHR_texture_basisu.source;if(null!==a.source)return a.source;throw new f("gltf-loader-unsupported-feature","Source is expected to be defined for a texture. It can also be omitted in favour of an KHR_texture_basisu extension tag.");};h._createTextureLoader=async function(a,b){a=this._getTextureSourceId(a);a=this.json.images[a];if(a.uri)return a.uri.endsWith(".ktx2")?(b=await this._context.loadBinary(this._resolveUri(a.uri),
b),new u.EncodedMeshTexture(new Uint8Array(b))):this._context.loadImage(this._resolveUri(a.uri),b);if(null==a.bufferView)throw new f("gltf-loader-unsupported-feature","Image bufferView must be defined.");if(null==a.mimeType)throw new f("gltf-loader-unsupported-feature","Image mimeType must be defined.");const c=this.json.bufferViews[a.bufferView];b=await this.getBuffer(c.buffer,b);if(null!=c.byteStride)throw new f("gltf-loader-unsupported-feature","byteStride not supported for image buffer");return u.imageFromBinaryData(new Uint8Array(b.buffer,
b.byteOffset+(c.byteOffset||0),c.byteLength),a.mimeType)};h.getLoadedBuffersSize=async function(){if(this._glbBuffer)return this._glbBuffer.byteLength;const a=await C.eachAlwaysValues(Array.from(this._bufferLoaders.values())),b=await C.eachAlwaysValues(Array.from(this._textureLoaders.values()));return a.reduce((c,d)=>c+(d?.byteLength??0),0)+b.reduce((c,d)=>c+(d?u.isEncodedMeshTexture(d)?d.data.byteLength:d.width*d.height*4:0),0)};return H._createClass(e)}();const G=q.fromXRotation(t.create(),Math.PI/
2),Q=new D.Version(2,0,"glTF"),x=L.create(),O={SCALAR:1,VEC2:2,VEC3:3,VEC4:4,MAT2:4,MAT3:9,MAT4:16},P={[g.DataType.BYTE]:1,[g.DataType.UNSIGNED_BYTE]:1,[g.DataType.SHORT]:2,[g.DataType.UNSIGNED_SHORT]:2,[g.DataType.FLOAT]:4,[g.DataType.INT]:4,[g.DataType.UNSIGNED_INT]:4};y.GLTFResource=E;y.TRANSFORM_GLTF_TO_ENGINE=G;Object.defineProperty(y,Symbol.toStringTag,{value:"Module"})});