// All material copyright ESRI, All Rights Reserved, unless otherwise specified.
// See https://js.arcgis.com/4.27/esri/copyright.txt for details.
//>>built
define("exports ../../../core/mathUtils ../../../chunks/vec4 ../../../geometry/support/aaBoundingBox ../../../geometry/support/aaBoundingRect ./ElevationData ./interfaces ./ITile ./PatchGeometry ./PatchGeometryLUT ./PatchRenderData ./terrainUtils ./Tile ./tileUtils ../webgl-engine/lib/Normals".split(" "),function(kb,T,Kc,Xb,Lc,ia,xb,Yb,ja,Mc,Zb,B,$b,yb,zb){function Nc(a){var e=a.tile;if(e.intersectsClippingArea){var t=a.geometryState,z=t.numVerticesPerSide,m=z-2;--z;var x=a.geometry,E=x.vertexAttributes,
g=E.position,J=E.uv0,{typedBuffer:G,typedBufferStride:Q}=E.normalCompressed,M=e.extent;E=M[0];var R=M[2],V=M[1];M=M[3];e=e.ellipsoid.radius;t=t.samplerData;var v=a.localOrigin;a=v[0];var r=v[1];v=v[2];var L=g.typedBuffer;g=g.typedBufferStride;var W=1/z;x=x.boundingBox;var N=0;if(1<=m){var k=V*(1-W)+M*W,d=qa.sinLatLUT[1],n=qa.cosLatLUT[1];for(var h=1;h<=m;h++){var l=h*W,f=qa.sinLonLUT[h],p=qa.cosLonLUT[h],A=e+ia.sampleElevation(E*(1-l)+R*l,k,t);p=-a+A*p*n;f=-r+A*f*n;A=-v+A*d;ja.minMaxBoundingBox(p,
f,A,x);var q=(h-1)*g;L[q]=p;L[q+1]=f;L[q+2]=A;ja.encodeUVInBuffer(J,h-1,l,W)}}for(k=1;k<=m;k++){d=k*W;d=V*(1-d)+M*d;n=qa.sinLatLUT[k];h=qa.cosLatLUT[k];f=k+1;l=f*W;p=V*(1-l)+M*l;A=qa.sinLatLUT[f];f=qa.cosLatLUT[f];var y=qa.sinLonLUT[0];q=qa.cosLonLUT[0];var u=e+ia.sampleElevation(E,d,t);q=q*h*u-a;y=y*h*u-r;u=n*u-v;var c=N*g;let pa=L[c],ra=L[c+1];c=L[c+2];for(let ma=1;ma<=m;ma++){var w=ma*W,K=E*(1-w)+R*w,O=qa.sinLonLUT[ma],aa=qa.cosLonLUT[ma],Y=0,ba=0,S=0;ma<m?(S=(N+1)*g,Y=L[S],ba=L[S+1],S=L[S+2]):
(ba=qa.sinLonLUT[z],Y=qa.cosLonLUT[z],S=e+ia.sampleElevation(R,d,t),Y=Y*h*S-a,ba=ba*h*S-r,S=n*S-v);var X=q,P=y,da=u;q=pa;y=ra;u=c;pa=Y;ra=ba;c=S;Y-=X;ba-=P;S-=da;X=P=da=0;if(1<k)X=(N-m)*g,da=L[X],P=L[X+1],X=L[X+2];else{X=qa.sinLatLUT[0];P=qa.cosLatLUT[0];var ea=e+ia.sampleElevation(K,V,t);da=aa*P*ea-a;P=O*P*ea-r;X=X*ea-v}ea=e+ia.sampleElevation(K,p,t);const xa=aa*f*ea-a;K=O*f*ea-r;ea=A*ea-v;if(k<m){const b=N+m,C=b*g;L[C]=xa;L[C+1]=K;L[C+2]=ea;ja.minMaxBoundingBox(xa,K,ea,x);ja.encodeUVInBuffer(J,
b,w,l)}w=da-xa;K=P-K;da=X-ea;aa*=h;O*=h;P=n;.999>P*P&&(aa=S*K-ba*da,O=Y*da-S*w,P=ba*w-Y*K);w=1/Math.sqrt(aa*aa+O*O+P*P);zb.compressNormal(G,N,aa*w,O*w,P*w,Q);++N}}}}function ac(a){a.tile.intersectsClippingArea&&(Ab(a),bc(a))}function bc(a,e=!1){var t=a.geometryState;const z=a.geometry,m=t.neighborData,x=a.tile,E=x.level,g=x.extent,J=x.ellipsoid.radius;var G=x.extentInRadians;const Q=G[0],M=G[2],R=G[1];G=G[3];const V=t.samplerData,v=g[0],r=g[2],L=g[1],W=g[3],N=Eb(a),k=z.boundingBox;t=a.localOrigin;
const d=t[0],n=t[1],h=t[2];t=z.vertexAttributes;var l=t.position;const f=l.typedBuffer,p=l.typedBufferStride,A=t.uv0;for(let u=0;4>u;++u){const c=1===u||3===u;t=m.edgeResolutions[u];B.internalAssert(T.isPowerOfTwo(t));const w=t+1;var q=Zb.neighborTileIfLoadedOrSelf(x,m.edgePeerNeighbors[u]);if(cc(x,q,u)){dc(a,u,q);continue}const K=null!=q;B.internalAssert(!K||q.level===x.level);B.internalAssert(!K||0>=yb.compareTilesByLij(x,q));l=q?.renderData?.geometryState;if(B.ENABLE_TERRAIN_INTERNAL_CHECKS){var y=
x.surface;if(!q&&y&&!y.updatingRootTiles){const D=B.neighborEdgeIndices[u],H=x.findNeighborTile(D,Z=>Z.isLoaded||Z.isLeaf||Z.level===x.level);H?H.intersectsClippingArea&&(B.internalAssert(!H.isLoaded),B.internalAssert(!H.isLeaf),B.internalAssert(H.level===E)):B.internalAssert(null==y?.rootTiles||!x.shouldHaveNeighbor(D))}}const O=1===u?g[2]:g[0],aa=(q=q?.extent)&&c?1===u?q[0]:q[2]:O,Y=0===u?g[3]:g[1],ba=1===u?1:0,S=0===u?1:0,X=1===u?M:Q,P=0===u?G:R,da=Math.sin(X),ea=Math.cos(X),pa=Math.sin(P),ra=
Math.cos(P),ma=l?.samplerData;l=(D,H,Z)=>ia.sampleElevation(D,H,V);y=(D,H,Z)=>.5*(ia.sampleElevation(D,H,V)+ia.sampleElevation(Z,H,ma));const xa=K?y:l,b=z.outerEdges[u],C=e&&3<w?w-3:1;l=null!=V&&V.some(D=>null!=D);y=null!=ma&&ma.some(D=>null!=D);const I=l||y,F=1/t,U=b.index0;B.internalAssert(!q||B.almostEquals(q[2]-q[0],g[2]-g[0]));(()=>{const D=1===u?-1:3===u?1:0,H=0===u?-1:2===u?1:0,Z=(g[2]-g[0])*F,ya=D*Z,la=H*Z,Ua=M-Q,za=c?D*Ua*F:0,Qa=c?0:H*F,Aa=S,sa=c?X+za:X,ta=c?Math.sin(sa):da,oa=c?Math.cos(sa):
ea,Ba=c?X-za:X,ua=c?Math.sin(Ba):da,Ia=c?Math.cos(Ba):ea,Ca=c?P:N(Aa+Qa),Ja=c?pa:Math.sin(Ca),Ka=c?ra:Math.cos(Ca),Da=c?P:N(Aa-Qa),Va=c?pa:Math.sin(Da),ha=c?ra:Math.cos(Da);let fa=0,na=0,Ea=0;const ka=0*F,Na=c?O:v*(1-ka)+r*ka,eb=c?aa:Na,fb=c?L*(1-ka)+W*ka:Y,Ya=c?X:Q*(1-ka)+M*ka,cb=c?da:Math.sin(Ya),Za=c?ea:Math.cos(Ya),$a=c?N(ka):P,ab=c?Math.sin($a):pa,db=c?Math.cos($a):ra,Wa=J+xa(Na,fb,eb);fa=Za*db*Wa;na=cb*db*Wa;Ea=ab*Wa;let Ra=0,La=0,Oa=0;const Ma=1*F,Fa=c?O:v*(1-Ma)+r*Ma,va=c?aa:Fa,Ga=c?L*(1-
Ma)+W*Ma:Y,wa=c?X:Q*(1-Ma)+M*Ma,Pa=c?da:Math.sin(wa),ca=c?ea:Math.cos(wa),Ha=c?N(Ma):P,Sa=c?Math.sin(Ha):pa,jb=c?Math.cos(Ha):ra,gb=J+xa(Fa,Ga,va);Ra=ca*jb*gb;La=Pa*jb*gb;Oa=Sa*gb;for(let Ta=1;Ta<w-1;Ta+=C){let lb=0,hb=0,bb=0;const Xa=(Ta+1)*F,ib=c?O:v*(1-Xa)+r*Xa,ob=c?aa:ib,tb=c?L*(1-Xa)+W*Xa:Y,mb=c?X:Q*(1-Xa)+M*Xa,Bb=c?da:Math.sin(mb),Oc=c?ea:Math.cos(mb),ec=c?N(Xa):P,Pc=c?Math.sin(ec):pa,fc=c?Math.cos(ec):ra,Fb=J+xa(ib,tb,ob);lb=Oc*fc*Fb;hb=Bb*fc*Fb;bb=Pc*Fb;const gc=lb,hc=hb,ic=bb,Gb=Ra,Hb=La,
Ib=Oa;Ra=gc;La=hc;Oa=ic;const jc=U+Ta,Jb=jc*p,kc=Gb-d,lc=Hb-n,mc=Ib-h;f[Jb]=kc;f[Jb+1]=lc;f[Jb+2]=mc;ja.minMaxBoundingBox(kc,lc,mc,k);const nc=Ta*F;ja.encodeUVInBuffer(A,jc,c?ba:nc,c?nc:S);const Qc=fa,Rc=na,Sc=Ea;fa=Gb;na=Hb;Ea=Ib;const ub=Gb,vb=Hb,pb=Ib,Cb=1/Math.sqrt(ub*ub+vb*vb+pb*pb),oc=pb*Cb;let qb=0,rb=0,sb=0;if(I&&.999>oc*oc){let Kb=0,Lb=0,Mb=0;const Nb=0===u?-1:1;Kb=Nb*(gc-Qc);Lb=Nb*(hc-Rc);Mb=Nb*(ic-Sc);const nb=Ta*F,pc=c?O:v*(1-nb)+r*nb,Tc=c?aa:pc,qc=c?L*(1-nb)+W*nb:Y,rc=c?X:Q*(1-nb)+M*
nb,sc=c?da:Math.sin(rc),tc=c?ea:Math.cos(rc),uc=c?N(nb):P,vc=c?Math.sin(uc):pa,wc=c?Math.cos(uc):ra;let Ob=ub,Pb=vb,Qb=pb;if(K){const Rb=J+ia.sampleElevation(Tc-ya,qc-la,ma),Uc=c?ua:sc,Vc=c?vc:Va,xc=c?wc:ha;Ob=(c?Ia:tc)*xc*Rb;Pb=Uc*xc*Rb;Qb=Vc*Rb}const Sb=J+ia.sampleElevation(pc+ya,qc+la,V),yc=c?wc:Ka,zc=(c?oa:tc)*yc*Sb,Ac=(c?ta:sc)*yc*Sb,Bc=(c?vc:Ja)*Sb;K||(Ob=2*ub-zc,Pb=2*vb-Ac,Qb=2*pb-Bc);const Tb=3===u?-1:1,Cc=Tb*(Ob-zc),Dc=Tb*(Pb-Ac),Ec=Tb*(Qb-Bc);qb=Mb*Dc-Lb*Ec;rb=Kb*Ec-Mb*Cc;sb=Lb*Cc-Kb*Dc;
const Ub=1/Math.sqrt(qb*qb+rb*rb+sb*sb);qb*=Ub;rb*=Ub;sb*=Ub}else qb=ub*Cb,rb=vb*Cb,sb=pb*Cb;b.setNormalFromValues(Ta,qb,rb,sb)}})()}}function Eb(a){a=a.tile;if(a.surface.isWebMercator){const t=a.extent,z=a.ellipsoid.radius;return m=>Math.PI/2-2*Math.atan(Math.exp(-(t[1]*(1-m)+t[3]*m)/z))}const e=a.extentInRadians;return t=>e[1]*(1-t)+e[3]*t}function Wc(a){const e=a.tile;if(e.intersectsClippingArea){var t=a.geometryState,z=t.samplerData,m=a.localOrigin,x=e.surface.isWebMercatorOnPlateeCarree,E=t.clippingArea,
g=null!=E?E:Vb,J=e.extent,G=J[0],Q=J[1],M=J[2],R=J[3],V=Math.max(G,g[0]),v=Math.min(M,g[2]),r=Math.max(Q,g[1]),L=Math.min(R,g[3]),W=e.ellipsoid.radius,N=e.horizontalScale,k=t.numVerticesPerSide,d=k-1,n=k-2,h=a.geometry,l=h.vertexAttributes,f=l.position,p=l.uv0,{typedBuffer:A,typedBufferStride:q}=l.normalCompressed,y=h.uvRange,u=y[0],c=y[1],w=y[2],K=y[3],O=h.boundingBox,aa=m[0],Y=m[1],ba=m[2],S=f.typedBuffer,X=f.typedBufferStride,P=0,da=T.clamp(Q,r,L),ea=x?(Math.PI/2-2*Math.atan(Math.exp(-da/W)))*
W:da*N,pa=1/d,ra=T.clamp(Q*(1-pa)+R*pa,r,L),ma=ea,xa=x?(Math.PI/2-2*Math.atan(Math.exp(-ra/W)))*W:ra*N;for(let b=1;b<=n;b++){const C=b/d,I=T.clamp(Q*(1-C)+R*C,r,L),F=T.clamp(C,c,K),U=xa,D=(b-1)/d,H=T.clamp(Q*(1-D)+R*D,r,L),Z=ma,ya=(b+1)/d,la=T.clamp(Q*(1-ya)+R*ya,r,L),Ua=x?(Math.PI/2-2*Math.atan(Math.exp(-la/W)))*W:la*N,za=T.clamp(ya,c,K);ma=xa;xa=Ua;const Qa=T.clamp(G,V,v);let Aa=Qa*N,sa=ia.sampleElevation(Qa,I,z);const ta=1/d,oa=T.clamp(ta,u,w),Ba=T.clamp(G*(1-oa)+M*oa,V,v);let ua=oa,Ia=Ba,Ca=Ba*
N,Ja=ia.sampleElevation(Ba,I,z);if(1===b){const Ka=Ca-aa,Da=ma-Y,Va=Ja-ba,ha=0*X;S[ha]=Ka;S[ha+1]=Da;S[ha+2]=Va;ja.minMaxBoundingBox(Ka,Da,Va,O);const fa=T.clamp(ta,u,w);ja.encodeUVInBuffer(p,P,fa,F)}for(let Ka=1;Ka<=n;Ka++){const Da=Ca,Va=Ja,ha=(Ka+1)/d,fa=T.clamp(ha,u,w),na=T.clamp(G*(1-ha)+M*ha,V,v),Ea=Ia;Ia=na;const ka=P+1,Na=ka*X;if(1===b||Ka===n){const Fa=ia.sampleElevation(na,I,z),va=na*N,Ga=U,wa=Fa;if(1===b&&Ka<n){const Pa=va-aa,ca=Ga-Y,Ha=wa-ba;S[Na]=Pa;S[Na+1]=ca;S[Na+2]=Ha;ja.minMaxBoundingBox(Pa,
ca,Ha,O);ja.encodeUVInBuffer(p,ka,fa,F)}Ca=va;Ja=wa}else Ca=S[Na]+aa,Ja=S[Na+2]+ba;const eb=Ca,fb=Ja,Ya=Aa,cb=sa;Aa=Da;sa=Va;const Za=(P-n)*X,$a=1===b?ia.sampleElevation(Ea,H,z):S[Za+2]+ba,ab=ia.sampleElevation(Ea,la,z);if(b<n){const Fa=P+n,va=Fa*X,Ga=Da-aa,wa=Ua-Y,Pa=ab-ba;S[va]=Ga;S[va+1]=wa;S[va+2]=Pa;ja.minMaxBoundingBox(Ga,wa,Pa,O);const ca=ua;ua=fa;ja.encodeUVInBuffer(p,Fa,ca,za)}const db=eb-Ya,Wa=Z-Ua,Ra=Wa*(fb-cb),La=db*($a-ab),Oa=-Wa*db,Ma=Ra*Ra+La*La+Oa*Oa;if(0===Ma)zb.compressNormal(A,
P,0,0,1,q);else{const Fa=1/Math.sqrt(Ma);zb.compressNormal(A,P,Ra*Fa,La*Fa,Oa*Fa,q)}++P}}}}function Fc(a,e){a.tile.intersectsClippingArea&&(Ab(a),Gc(a,!1))}function Gc(a,e){const t=a.geometryState,z=t.neighborData,m=a.tile,x=m.surface,E=m.extent,g=t.clippingArea,J=null!=g?g:Vb,G=E[0],Q=E[2],M=E[1],R=E[3],V=[R>J[3],Q>J[2],M<J[1],G<J[0]],v=a.geometry,r=m.horizontalScale,L=Hc(x.isWebMercatorOnPlateeCarree,m.ellipsoid.radius,r),W=v.boundingBox,N=v.uvRange[0],k=v.uvRange[1],d=v.uvRange[2],n=v.uvRange[3],
h=Math.max(G,J[0]),l=Math.min(Q,J[2]),f=Math.max(M,J[1]),p=Math.min(R,J[3]),A=a.localOrigin,q=A[0],y=A[1],u=A[2],c=t.samplerData;for(let w=0;4>w;++w){const K=1===w||3===w,O=z.edgeResolutions[w];B.internalAssert(T.isPowerOfTwo(O));const aa=O+1,Y=V[w],ba=Zb.neighborTileIfLoadedOrSelf(m,z.edgePeerNeighbors[w]);if(!Y&&cc(m,ba,w)){dc(a,w,ba);continue}const S=null!=ba&&!Y,X=ba?.renderData?.geometryState;if(B.ENABLE_TERRAIN_INTERNAL_CHECKS&&(B.internalAssert(!S||ba.level===m.level),B.internalAssert(!S||
0>=yb.compareTilesByLij(m,ba)),m&&!ba&&!x.updatingRootTiles)){const ha=B.neighborEdgeIndices[w],fa=m.findNeighborTile(ha,na=>na.isLoaded||na.isLeaf||na.level===m.level);x.updatingRootTiles||(fa?fa.intersectsClippingArea&&(B.internalAssert(!fa.isLoaded),B.internalAssert(!fa.isLeaf),B.internalAssert(fa.level===m.level)):B.internalAssert(null==x?.rootTiles||!m.shouldHaveNeighbor(ha)))}const P=T.clamp(1===w?Q:G,h,l),da=T.clamp(0===w?R:M,f,p),ea=X?.samplerData,pa=v.outerEdges[w],ra=e&&3<aa?aa-3:1,ma=T.clamp(1===
w?1:0,N,d),xa=T.clamp(0===w?1:0,k,n),b=(ha,fa)=>ia.sampleElevation(ha,fa,c),C=(ha,fa)=>.5*(ia.sampleElevation(ha,fa,ea)+ia.sampleElevation(ha,fa,c)),I=S?C:b,F=(Q-G)/O,U=K?1===w?F:-F:0,D=K?0:0===w?F:-F,H=-U,Z=-D;let ya=0,la=0,Ua=0;const za=0/O,Qa=K?P:T.clamp(G*(1-za)+Q*za,h,l),Aa=K?T.clamp(M*(1-za)+R*za,f,p):da,sa=I(Qa,Aa);ya=Qa*r;la=L(Aa);Ua=sa;let ta=0,oa=0,Ba=0;const ua=1/O,Ia=K?P:T.clamp(G*(1-ua)+Q*ua,h,l),Ca=K?T.clamp(M*(1-ua)+R*ua,f,p):da,Ja=I(Ia,Ca),Ka=Ia*r,Da=L(Ca),Va=Ja;ta=Ka;oa=Da;Ba=Va;
for(let ha=1;ha<aa-1;ha+=ra){const fa=ha/O,na=ta,Ea=oa,ka=Ba,Na=K?ma:T.clamp(fa,N,d),eb=K?T.clamp(fa,k,n):xa,fb=na-q,Ya=Ea-y,cb=ka-u;ja.minMaxBoundingBox(na,Ya,cb,W);pa.setVertexFromValuesRawPositionUV(ha,fb,Ya,cb,Na,eb);const Za=(ha+1)/O,$a=K?P:T.clamp(G*(1-Za)+Q*Za,h,l),ab=K?T.clamp(M*(1-Za)+R*Za,f,p):da,db=I($a,ab);ta=$a*r;oa=L(ab);Ba=db;const Wa=ta,Ra=oa,La=Ba,Oa=ya,Ma=la,Fa=Ua;ya=na;la=Ea;Ua=ka;let va=0,Ga=0,wa=0;if(K){const ca=Ra-Ea,Ha=La-ka,Sa=Ma-Ea,jb=Fa-ka,gb=T.clamp(M*(1-fa)+R*fa,f,p),Ta=
P+H,lb=Ta*r,hb=ia.sampleElevation(Ta,gb,c),bb=lb-na,Xa=hb-ka,ib=3===w?-1:1;va=ib*(-Sa+ca)*Xa;Ga=ib*bb*(-jb+Ha);wa=-ib*bb*(-Sa+ca);if(S){const ob=P+U,tb=ob*r,mb=ia.sampleElevation(ob,gb,ea),Bb=tb-na;va=(-Sa+ca)*(Xa-(mb-ka));Ga=(bb-Bb)*(-jb+Ha);wa=-(bb-Bb)*(-Sa+ca)}}else{const ca=Wa-na,Ha=La-ka,Sa=Oa-na,jb=Fa-ka,gb=T.clamp(G*(1-fa)+Q*fa,h,l),Ta=da+Z,lb=ia.sampleElevation(gb,Ta,c)-ka,hb=L(Ta)-Ea,bb=2===w?-1:1;va=bb*hb*(-jb+Ha);Ga=bb*(-Sa+ca)*lb;wa=-bb*hb*(-Sa+ca);if(S){const Xa=gb,ib=da+D,ob=L(ib),tb=
ia.sampleElevation(Xa,ib,ea)-ka,mb=ob-Ea;va=(-hb+mb)*(-jb+Ha);Ga=(-Sa+ca)*(-lb+tb);wa=-(-hb+mb)*(-Sa+ca)}}const Pa=1/Math.sqrt(va*va+Ga*Ga+wa*wa);pa.setNormalFromValues(ha,va*Pa,Ga*Pa,wa*Pa)}}}function Hc(a,e,t){return a?z=>(Math.PI/2-2*Math.atan(Math.exp(-z/e)))*e:z=>z*t}function Ic(a,e,t,z,m,x){const E=e-1,g=a.vertexAttributes.count,J=2*(Math.min(e-2,z[1])-Math.max(1,z[0]))*(Math.min(e-2,m[1])-Math.max(1,m[0])),G=B.neighborEdgeIndices.map((k,d)=>0===d&&m[1]<e-2||1===d&&z[1]<e-2||2===d&&1<m[0]||
3===d&&1<z[0]),Q=a.outerEdges.reduce((k,d,n)=>k+(G[n]?0:E-2+d.count-1),0),M=t.reduce((k,d)=>k+E*(2*(d.latitudeResolution-1)+1),0),R=x?2:1,V=3*(J+Q+M)*R,v=65536<=g?new Uint32Array(V):new Uint16Array(V);let r=0;const L=e-2,W=E-2;B.internalAssert(0<=W);const N=(k,d,n,h,l,f)=>{var p=k*l;k=f[p];const A=f[p+1];p=f[p+2];var q=d*l;d=f[q];const y=f[q+1];q=f[q+2];var u=n*l;n=f[u];const c=f[u+1];u=f[u+2];const w=h*l;h=f[w];l=f[w+1];f=f[w+2];return(d-h)*(d-h)+(y-l)*(y-l)+(q-f)*(q-f)>(k-n)*(k-n)+(A-c)*(A-c)+(p-
u)*(p-u)};if(x){const k=(d,n,h)=>{v[r++]=d;v[r++]=n;v[r++]=n;v[r++]=h;v[r++]=h;v[r++]=d;B.ENABLE_TERRAIN_INTERNAL_CHECKS&&(B.internalAssert(d<g),B.internalAssert(n<g),B.internalAssert(h<g),B.internalAssert(r<=V))};(()=>{for(let d=Math.max(m[0],1)-1;d<Math.min(m[1],e-2)-1;++d){const n=d*L;for(let h=Math.max(z[0],1)-1;h<Math.min(z[1],e-2)-1;++h){const l=d*L+h,f=l+1,p=f+L,A=p-1,q=n+h,y=q+1,u=y+L;N(q,y,u,u-1,a.vertexAttributes.position.typedBufferStride,a.vertexAttributes.position.typedBuffer)?(k(l,f,
p),k(p,A,l)):(k(l,f,A),k(A,p,f))}}})();B.internalAssert(r===3*J*R);(()=>{for(let n=0;4>n;++n){const h=r;if(G[n])continue;const l=a.outerEdges[n],f=a.innerEdges[n];let p=0,A=0;const q=l.count,y=f.count;B.internalAssert(y===E-1);let u=0;const c=1===n||2===n?(w,K,O)=>k(w,K,O):(w,K,O)=>k(w,O,K);for(;p<q-1||A<y-1;){const w=f.getVertexIndex(A),K=l.getVertexIndex(p);var d=p<q-1;const O=A<y-1,aa=d?E*(p+.5)/(q-1):0,Y=O?1+W*(A+.5)/(y-1):0;d&&(!O||aa<=Y)?(++p,B.ENABLE_TERRAIN_INTERNAL_CHECKS&&B.internalAssert(p<
q),d=l.getVertexIndex(p),c(w,K,d)):(++A,B.ENABLE_TERRAIN_INTERNAL_CHECKS&&B.internalAssert(A<y),d=f.getVertexIndex(A),c(w,K,d));u++}B.ENABLE_TERRAIN_INTERNAL_CHECKS&&(B.internalAssert(p===q-1),B.internalAssert(A===y-1),B.internalAssert(u===q+y-2),B.internalAssert(u===E-2+l.count-1),B.internalAssert(r===h+3*u*R))}})();B.internalAssert(r===3*(J+Q)*R);t.forEach(d=>{var n=a.outerEdges[d.connectedOuterEdgeOffset];let h=n.getVertexIndex(0);n=n.stride;for(let l=0;l<d.latitudeResolution;++l){const f=0===
l?d.rowOffset:h+e;for(let p=0;p<E;p++)k(h,h+1,f+p),l<d.latitudeResolution-1&&k(h+1,f+p+1,f+p),h+=n;h=f;n=1}})}else(()=>{var k=Math.max(m[0],1)-1;const d=Math.min(m[1],e-2)-1,n=Math.max(z[0],1)-1,h=Math.min(z[1],e-2)-1;for(;k<d;++k){const l=k*L;for(let f=n;f<h;++f){const p=l+f,A=p+1,q=A+L,y=q-1;N(p,A,q,y,a.vertexAttributes.position.typedBufferStride,a.vertexAttributes.position.typedBuffer)?(v[r]=p,v[r+1]=A,v[r+2]=q,v[r+3]=q,v[r+4]=y,v[r+5]=p):(v[r]=p,v[r+1]=A,v[r+2]=y,v[r+3]=y,v[r+4]=A,v[r+5]=q);r+=
6}}})(),B.internalAssert(r===3*J*R),(()=>{for(let l=0;4>l;++l){if(G[l])continue;var k=a.outerEdges[l],d=a.innerEdges[l];let f=0,p=0;const A=k.count,q=d.count;B.internalAssert(q===E-1);var n=1===l||2===l;const y=n?1:2;n=n?2:1;const u=k.index0;k=k.stride;const c=d.index0;for(d=d.stride;f<A-1||p<q-1;){const w=c+p*d,K=u+f*k;var h=f<A-1;const O=p<q-1,aa=h?E*(f+.5)/(A-1):0,Y=O?1+W*(p+.5)/(q-1):0;(h=h&&(!O||aa<=Y))?++f:++p;h=h?K+k:w+d;v[r]=w;v[r+y]=K;v[r+n]=h;r+=3}}})(),B.internalAssert(r===3*(J+Q)*R),t.forEach(k=>
{var d=a.outerEdges[k.connectedOuterEdgeOffset];let n=d.getVertexIndex(0);d=d.stride;for(let h=0;h<k.latitudeResolution;++h){const l=0===h?k.rowOffset:n+e;for(let f=0;f<E;f++){const p=l+f;v[r]=n;v[r+1]=n+1;v[r+2]=p;h<k.latitudeResolution-1?(v[r+3]=n+1,v[r+4]=p+1,v[r+5]=p,r+=6):r+=3;n+=d}n=l;d=1}});B.internalAssert(r===V);a.indices=v;a.indexCount=V}function Jc(a,e){const t=a.localOrigin,z=a.geometry;a=a.geometryState.neighborData.edgeResolutions;const m=z.numVerticesPerSide-2,x=z.vertexAttributes;
for(let g=0;4>g;++g){var E=0===g||2===g;z.innerEdges[g]=new ja.EdgeDescriptor(x,t,(0===g?m-1:0)*m+(1===g?m-1:0),(E?0:1)*m+(E?1:0),m);E=a[g]+1;z.outerEdges[g]=new ja.EdgeDescriptor(x,t,e,1,E);e+=E}}function dc(a,e,t){var z=(e+2)%4,m=a.tile,x=m.level-t.level;const E=1===e||3===e,g=a.geometryState.neighborData.edgeResolutions[e];B.internalAssert(T.isPowerOfTwo(g));const J=g+1;var G=a.geometry;const Q=G.boundingBox;var M=G.outerEdges[e];const R=G.uvRange[0],V=G.uvRange[1],v=G.uvRange[2];G=G.uvRange[3];
const r=T.clamp(1===e?1:0,R,v),L=T.clamp(0===e?1:0,V,G);var W=t.renderData,N=W.geometryState,k=W.geometry.outerEdges[z];e=m.getNeighborEdgeStartVertexIndex(e,t)*g;x=g*2**x;B.internalAssert(N.neighborData.edgeResolutions[z]===x);B.internalAssert(k.count-1===x);z=W.localOrigin[0]-a.localOrigin[0];x=W.localOrigin[1]-a.localOrigin[1];a=W.localOrigin[2]-a.localOrigin[2];var d=M.attributes;W=M.index0;M=M.stride;N=d.position.typedBuffer;t=d.position.typedBufferStride;m=d.normalCompressed.typedBuffer;const n=
d.normalCompressed.typedBufferStride;d=d.uv0;var h=k.attributes;const l=k.index0;k=k.stride;const f=h.position.typedBuffer,p=h.position.typedBufferStride,A=h.normalCompressed.typedBuffer;h=h.normalCompressed.typedBufferStride;for(let c=1;c<J-1;++c){const w=W+M*c;var q=l+k*(e+c),y=w*t,u=q*p;const K=f[u]+z,O=f[u+1]+x;u=f[u+2]+a;N[y]=K;N[y+1]=O;N[y+2]=u;ja.minMaxBoundingBox(K,O,u,Q);y=w*n;q*=h;m[y]=A[q];m[y+1]=A[q+1];y=c/g;q=E?r:T.clamp(y,R,v);y=E?T.clamp(y,V,G):L;ja.encodeUVInBuffer(d,w,q,y)}}function Ab(a){const e=
a.geometryState,t=a.localOrigin,z=e.neighborData.cornerNeighborData,m=a.geometry,x=m.outerEdges,E=m.boundingBox,g=a.tile,J="local"===a.tile.surface.view?.viewingMode,G=g.ellipsoid.radius,Q=g.extentInRadians,M=g.horizontalScale;let R=0,V=0,v=0;const r=()=>{const b=a.geometryState.clippingArea,C=g.extent,I=null!=b&&(C[3]>b[3]||C[2]>b[2]||C[1]<b[1]||C[0]<b[0]),F=Hc(g.surface.isWebMercatorOnPlateeCarree,g.ellipsoid.radius,M);return(U,D,H)=>{U=0===U?u[0]:u[2];D=0===D?u[1]:u[3];U=I?T.clamp(U,b[0],b[2]):
U;D=I?T.clamp(D,b[1],b[3]):D;R=U*M;V=F(D);v=H}},L=(b,C,I)=>{var F=Q[0===C?1:3];b=Q[0===b?0:2];C=Math.cos(F);F=Math.sin(F);const U=Math.sin(b);I=G+I;R=Math.cos(b)*C*I;V=U*C*I;v=F*I},W=J?r():L;let N=0,k=0,d=0,n=0,h=0,l=0,f=0,p=0,A=0;const q=J&&a.tile.surface.isWebMercatorOnPlateeCarree,y=(b,C,I,F,U)=>{var D=0,H=0;let Z=0;J?(I=q?(Math.PI/2-2*Math.atan(Math.exp(-I/G)))*G:I*M,D=C*M-R,H=I-V,Z=F-v):(D=Eb(b),b=b.tile,H=b.extent,b=b.extentInRadians,C=(C-H[0])/(H[2]-H[0]),C=b[0]*(1-C)+b[2]*C,D=D((I-H[1])/(H[3]-
H[1])),I=Math.cos(D),b=Math.sin(D),H=Math.sin(C),F=G+F,D=Math.cos(C)*I*F-R,H=H*I*F-V,Z=b*F-v);switch(U){case 0:f+=D;p+=H;A+=Z;break;case 1:n-=D;h-=H;l-=Z;break;case 2:f-=D;p-=H;A-=Z;break;case 3:n+=D,h+=H,l+=Z}},u=g.extent,c=e.clippingArea,w=null!=c?c:Vb,K=u[0],O=u[2],aa=u[1],Y=u[3],ba=[Y>w[3],O>w[2],aa<w[1],K<w[0]],S=Math.max(K,w[0]),X=Math.min(O,w[2]),P=Math.max(aa,w[1]),da=Math.min(Y,w[3]),ea=m.uvRange[0],pa=m.uvRange[1],ra=m.uvRange[2],ma=m.uvRange[3],xa=b=>{b=z[b].cornerTiles;k=N=0;d=1;A=p=f=
l=h=n=0;var C=Infinity;for(var I=0;4>I;++I)C=Math.min(C,b[I]?.level??Infinity);for(I=0;4>I;++I){var F=b[I];wb[I]=F?.level===C?F:null}b=1;C=0;for(I=0;4>I;++I)if(F=wb[I])b=Math.max(b,F?.renderData.geometryState.numVerticesPerSide),C=F.extent[2]-F.extent[0];B.internalAssert(1<b);b=C/b;for(C=0;4>C;++C){var U=wb[(C+3)%4],D=wb[C%4];if(U||D){F=0===C?1:1===C?2:2===C?3:0;var H=0===C?2:1===C?3:2===C?0:1;if(U&&D){var Z=Wb[C][0]*b,ya=Wb[C][1]*b,la=U.extent;I=la[0===F||1===F?2:0]+Z;F=la[0===F||3===F?3:1]+ya;la=
D.extent;Z=la[0===H||1===H?2:0]+Z;H=la[0===H||3===H?3:1]+ya;U=U.renderData;ya=D.renderData;D=ia.sampleElevation(I,F,U.geometryState.samplerData);H=ia.sampleElevation(Z,H,ya.geometryState.samplerData);y(U,I,F,.5*(D+H),C)}else I=U??D,U=U?F:H,D=I.extent,H=Wb[C],F=D[0===U||1===U?2:0]+H[0]*b,U=D[0===U||3===U?3:1]+H[1]*b,I=I.renderData,D=ia.sampleElevation(F,U,I.geometryState.samplerData),y(I,F,U,D,C)}}J||(b=Math.sqrt(R*R+V*V+v*v),N=R/b,k=V/b,d=v/b);if(J||.999>d*d)b=Math.sqrt(n*n+h*h+l*l),n/=b,h/=b,l/=
b,b=Math.sqrt(f*f+p*p+A*A),f/=b,p/=b,A/=b,N=l*p-h*A,k=n*A-l*f,d=h*f-n*p,b=1/Math.sqrt(N*N+k*k+d*d),N*=b,k*=b,d*=b};for(let b=0;4>b;++b){const C=b,I=(b+1)%4,F=0===b||1===b?1:0,U=0===b||3===b?1:0,D=T.clamp(F,ea,ra),H=T.clamp(U,pa,ma),Z=x[C],ya=0===b||3===b?Z.count-1:0,la=x[I],Ua=0===b||1===b?la.count-1:0,za=z[b].cornerTiles;let Qa=-1;for(let ta=0;4>ta;++ta){const oa=za[ta];oa&&(-1===Qa||0<yb.compareTilesByLij(za[Qa],oa))&&(Qa=ta)}const Aa=Qa,sa=za[Aa];if(sa!==g){const ta=g.level-sa.level,oa=2**ta,Ba=
[sa.lij[0]+ta,sa.lij[1]*oa,sa.lij[2]*oa],ua=[Ba[1]+oa===g.lij[1],0===b&&(1===Aa||0===Aa&&sa!==za[3])||1===b&&(0===Aa||1===Aa&&sa!==za[2]),Ba[1]===g.lij[1]+1,2===b&&(3===Aa||2===Aa&&sa!==za[1])||3===b&&(2===Aa||3===Aa&&sa!==za[0])],Ia=ua.reduce((ca,Ha)=>ca+(Ha?1:0),0);B.internalAssert(1===Ia||2===Ia);let Ca=-1,Ja=-1;const Ka=sa.renderData;if(1===Ia){const ca=ua.findIndex(Sa=>Sa);B.internalAssert(0<=ca&&3>=ca);Ca=(ca+2)%4;const Ha=a.geometryState.neighborData.edgeResolutions[ca];Ja=g.getNeighborEdgeStartVertexIndex(ca,
sa)*Ha+Ha*(0===ca&&0===b||1===ca&&0===b||2===ca&&1===b||3===ca&&3===b?1:0)}else{B.internalAssert(ua[1]||ua[3]);Ca=ua[1]?3:1;const ca=Ka.geometryState.neighborData.edgeResolutions[Ca];Ja=0===b||3===b?0:ca}const Da=Ka.geometry.outerEdges[Ca],Va=Z.index0+ya*Z.stride,ha=la.index0+Ua*la.stride,fa=Da.index0+Ja*Da.stride,na=Da.attributes.position,Ea=na.typedBuffer,ka=fa*na.typedBufferStride,Na=a.localOrigin,eb=Da.localOrigin,fb=Ea[ka]+eb[0]-Na[0],Ya=Ea[ka+1]+eb[1]-Na[1],cb=Ea[ka+2]+eb[2]-Na[2];ja.minMaxBoundingBox(fb,
Ya,cb,E);const Za=Z.attributes.position,$a=Za.typedBuffer,ab=Va*Za.typedBufferStride;$a[ab]=fb;$a[ab+1]=Ya;$a[ab+2]=cb;const db=la.attributes.position,Wa=db.typedBuffer,Ra=ha*db.typedBufferStride;Wa[Ra]=fb;Wa[Ra+1]=Ya;Wa[Ra+2]=cb;ja.encodeUVInBuffer(Z.attributes.uv0,Va,D,H);ja.encodeUVInBuffer(la.attributes.uv0,ha,D,H);const La=Da.attributes.normalCompressed.typedBuffer,Oa=fa*Da.attributes.normalCompressed.typedBufferStride,Ma=Z.attributes.normalCompressed,Fa=Ma.typedBuffer,va=Va*Ma.typedBufferStride;
Fa[va]=La[Oa];Fa[va+1]=La[Oa+1];const Ga=la.attributes.normalCompressed,wa=Ga.typedBuffer,Pa=ha*Ga.typedBufferStride;wa[Pa]=La[Oa];wa[Pa+1]=La[Oa+1]}else{const ta=ba[I];let oa=void 0;if(ba[C]||ta){const Ca=T.clamp(K*(1-F)+O*F,S,X),Ja=T.clamp(aa*(1-U)+Y*U,P,da);oa=ia.sampleElevation(Ca,Ja,e.samplerData)}else oa=Xc(za);W(F,U,oa);xa(b);const Ba=R-t[0],ua=V-t[1],Ia=v-t[2];ja.minMaxBoundingBox(Ba,ua,Ia,E);Z.setVertexFromValuesRawPositionUVNormal(ya,Ba,ua,Ia,D,H,N,k,d);la.setVertexFromValuesRawPositionUVNormal(Ua,
Ba,ua,Ia,D,H,N,k,d)}}for(let b=0;4>b;++b)wb[b]=null}function Xc(a){const e=a.reduce((x,E)=>Math.min(x,E?.level??Infinity),Infinity);B.ENABLE_TERRAIN_INTERNAL_CHECKS&&(B.internalAssert(!a[0]||!a[2]||$b.isCornerNeighbor(a[0],a[2],Yb.NeighborIndex.SOUTH_WEST)),B.internalAssert(!a[1]||!a[3]||$b.isCornerNeighbor(a[1],a[3],Yb.NeighborIndex.NORTH_WEST)));let t=0,z=0;for(let x=0;4>x;++x){var m=a[x];if(m&&m.level===e){const E=m.extent;m=ia.sampleElevation(E[0===x||1===x?0:2],E[0===x||3===x?1:3],m.renderData?.geometryState?.samplerData);
z+=m;t++}}a=t?z/t:0;B.internalAssert(null!=a);return a}function Db(a){const e=a.geometry.vertexAttributes.position.typedBuffer;a.vao.vertexBuffers.geometry.setSubData(e,0,0,e.length)}function cc(a,e,t){if(!e)return!1;a=yb.compareTilesByLij(a,e);return 0<a||0===a&&2<=t}const Wb=[[0,1],[1,0],[0,-1],[-1,0]],qa=new Mc.PatchGeometryLUT,Vb=Lc.fromValues(-Infinity,-Infinity,Infinity,Infinity),wb=[null,null,null,null];kb.createPlanarGlobePatch=function(a,e){var t=a.tile.extent;e=a.geometryState;var z=t[0],
m=t[1],x=t[2]-z,E=t[3]-m,g=e.clippingArea;t=null!=g?Math.max(0,(g[0]-z)/x):0;const J=null!=g?Math.max(0,(g[1]-m)/E):0;z=null!=g?Math.min(1,(g[2]-z)/x):1;m=null!=g?Math.min(1,(g[3]-m)/E):1;x=e.numVerticesPerSide;E=(x-2)**2;g=e.neighborData.edgeResolutions.reduce((Q,M)=>Q+M+1,0);g=ja.acquireTerrainAttributes(E+g);const G=a.geometry;Xb.empty(G.boundingBox);G.numVerticesPerSide=e.numVerticesPerSide;G.vertexAttributes=g;Kc.set(G.uvRange,t,J,z,m);Wc(a);Jc(a,E);Fc(a);Ic(G,e.numVerticesPerSide,[],[0,x-1],
[0,x-1],e.wireframe);a.intersectionData=null};kb.createSphericalGlobePatch=function(a,e){const t=a.tile,{extent:z,extentInRadians:m,surface:x}=t,E=a.localOrigin,g=a.geometryState;var J=x.isWebMercator;const G=g.numVerticesPerSide,Q=G-1,M=(G-2)**2,R=J&&(e===xb.PatchType.HAS_SOUTH_POLE||e===xb.PatchType.HAS_BOTH_POLES),V=J&&(e===xb.PatchType.HAS_NORTH_POLE||e===xb.PatchType.HAS_BOTH_POLES);J=6*((R?1:0)+(V?1:0))*(Q+1);e=g.neighborData;const v=e.edgeResolutions.reduce((k,d)=>k+d+1,0),r=ja.acquireTerrainAttributes(M+
J+v);J=a.geometry;J.numVerticesPerSide=g.numVerticesPerSide;J.vertexAttributes=r;const L=J.boundingBox;Xb.empty(L);const W=Eb(a);qa.update(Q,m,W);Nc(a);Jc(a,M);ac(a);const N=[];(()=>{let k=M+v;const d=E[0],n=E[1],h=E[2],l=t.ellipsoid.radius,f=z[1],p=z[3],A=(q,y)=>{y*=G;ja.minMaxBoundingBox(-d,-n,-h+q*l,L);N.push({connectedRowOffset:y,connectedOuterEdgeOffset:1===q?0:2,rowOffset:k,latitudeResolution:6});y=Math.PI/2-2*Math.atan(Math.exp(-(-1===q?f:p)/l));const u=q*Math.PI/2-y;q=.99*(1===q?1:-1);const c=
l+0,w=r.position,K=r.uv0,{typedBuffer:O,typedBufferStride:aa}=r.normalCompressed;for(let ba=1;6>=ba;++ba){var Y=y+ba/6*u;const S=Math.cos(Y);Y=Math.sin(Y);for(let X=0;X<=Q;X++){const P=X/Q,da=qa.cosLonLUT[X]*S,ea=qa.sinLonLUT[X]*S,pa=Y,ra=da*c-d,ma=ea*c-n,xa=pa*c-h;ja.minMaxBoundingBox(ra,ma,xa,L);w.setValues(k,ra,ma,xa);ja.encodeUVInBuffer(K,k,P,q);zb.compressNormal(O,k,da,ea,pa,aa);++k}}};R&&A(-1,0);V&&A(1,Q)})();Ic(J,g.numVerticesPerSide,N,[0,G-1],[0,G-1],g.wireframe);a.intersectionData=null;if(B.ENABLE_TERRAIN_INTERNAL_CHECKS)for(a=
0;4>a;++a)B.internalAssert(J.outerEdges[a].count===e.edgeResolutions[a]+1)};kb.updateCornerSpherical=function(a){a.tile.intersectsClippingArea&&(Ab(a),bc(a,!0),Db(a))};kb.updateCornersPlanar=function(a,e){a.tile.intersectsClippingArea&&(Ab(a),Gc(a,!0),Db(a))};kb.updateEdgesAndCornersPlanar=function(a,e){a.tile.intersectsClippingArea&&(Fc(a),Db(a))};kb.updateEdgesAndCornersSpherical=function(a){a.tile.intersectsClippingArea&&(ac(a),Db(a))};Object.defineProperty(kb,Symbol.toStringTag,{value:"Module"})});