// All material copyright ESRI, All Rights Reserved, unless otherwise specified.
// See https://js.arcgis.com/4.27/esri/copyright.txt for details.
//>>built
define("exports ../../../chunks/_rollupPluginBabelHelpers ../../../core/arrayUtils ../../../core/mathUtils ../../../chunks/vec3 ../../../chunks/vec3f64 ../../../geometry/support/aaBoundingBox ../../../geometry/support/aaBoundingRect ../../../geometry/support/Ellipsoid ../support/buffer/glUtil ./GeometryState ./ITile ./LayerClass ./PatchGeometry ./terrainUtils ./TextureFader ./Tile ./TileOverlayData ./tileUtils ../webgl-engine/lib/VertexArrayObject ../webgl-engine/shaders/TerrainTechnique ../../webgl/BufferObject".split(" "),
function(R,fa,ha,W,r,u,ia,ja,X,ka,la,S,U,Y,b,V,ma,na,oa,pa,qa,Z){function K(O,q){return q?.isLoaded||q===O?q:null}let ra=function(){function O(){this.geometry=new Y.PatchGeometry;this.geometryState=this.intersectionData=null;this._textureRef=new V.TextureFader(()=>this.tile.surface.textureFadeDuration);this.overlay=new na;this._geometryStateChangedSinceLastUpdate=!0;this._wireframeChanged=this._clippingAreaChanged=this._samplerDataChanged=this._numVerticesPerSideChanged=this._hasGeometry=!1;this._dirtyCorners=
this._dirtyEdges=this._dirtyEdgeResolutions=15}var q=O.prototype;q.init=function(a){this.clear();this._tile=a;a=this.geometry;a.indices=null;a.vertexAttributes=null;ia.empty(a.boundingBox);a.indexCount=0;a.numVerticesPerSide=0;this.intersectionData=null;this.geometryState=new la.GeometryState;this.localOrigin=null;this.overlay.clear()};q.clear=function(){this.releaseGeometry();this.releaseTexture();this._textureRef.clear();this.geometryState=this.intersectionData=this._tile=null};q.updateGeometryIfNeeded=
function(a){if(!this._vao||this._geometryStateChangedSinceLastUpdate||this._wireframeChanged||this._clippingAreaChanged||this._samplerDataChanged||this._numVerticesPerSideChanged||this._dirtyCorners||this._dirtyEdgeResolutions||this._dirtyEdges)this._updateGeometry(a),this._geometryStateChangedSinceLastUpdate=!1;if(b.ENABLE_TERRAIN_INTERNAL_CHECKS&&this.tile.intersectsClippingArea)for(a=0;4>a;++a)b.internalAssert(this.geometry.outerEdges[a].count===this.geometryState.neighborData.edgeResolutions[a]+
1)};q._calculateEdgeResolution=function(a,e){const h=this.tile,n=this.geometryState.numVerticesPerSide-1;if(!h.surface.isGlobal){var k=h.surface.extent;if(null!=k&&(0===a&&h.extent[3]>k[3]||1===a&&h.extent[2]>k[2]||2===a&&h.extent[1]<k[1]||3===a&&h.extent[0]<k[0]))return n}const d=h.level;k=b.neighborEdgeIndices[a];if(!e)return b.internalAssert(null==h.surface?.rootTiles||h.surface.updatingRootTiles||!h.shouldHaveNeighbor(k)),n;if(e.isLoaded)return k=e.renderData.geometryState,e=d-e.level,b.internalAssert(0<=
e),0===e?Math.max(k.numVerticesPerSide-1,n):Math.max(1,k.neighborData.edgeResolutions[(a+2)%4]/2**e);b.internalAssert(!e.isLeaf);let f=n;e.forAllSubtreeOnSide(b.oppositeEdge(k),c=>{if(c===h)return!0;if(c.isLoaded)return f=Math.max(f,2**(c.level-d)),!0;b.internalAssert(!c.isLeaf);return!1});return f};q.updateNeighborData=function(){const a=this.tile;if(a.intersectsClippingArea){var e=a.renderData.geometryState.neighborData,h=x=>(x.isLoaded||x.level===a.level)&&x?.intersectsClippingArea,n=e.edgePeerNeighbors,
k=e.edgePeerNeighborSamplerVersions;for(var d=0;4>d;++d){var f=a.findNeighborTile(b.neighborEdgeIndices[d],h),c=K(a,f),g=c?.renderData?.geometryState.samplerDataVersion??-1,l=K(a,n[d]);c=c!==l;l=k[d]!==g;n[d]=f;if(c||l)k[d]=g,this._markEdgeDirty(d);g=e.edgeResolutions[d];f=this._calculateEdgeResolution(d,f);b.internalAssert(W.isPowerOfTwo(f));b.internalAssert(1<=f);e.edgeResolutions[d]=f;g!==f&&this._markEdgeResolutionDirty(d)}k=e.cornerPeerNeighbors;for(d=0;4>d;++d){c=a.findNeighborTile(b.neighborCornerIndices[d],
h);k[d]=c;f=K(a,n[d]);g=K(a,n[(d+1)%4]);c=K(a,c);y[d]=c;y[(d+1)%4]=g;y[(d+2)%4]=a;y[(d+3)%4]=f;b.internalAssert(y.some(m=>m?.isLoaded||m===a));const x=y.reduce((m,z)=>Math.min(m,z?.level??Infinity),Infinity);y.forEach((m,z)=>{m&&m?.level>x&&(y[z]=null)});b.internalAssert(y.some(m=>m?.isLoaded||m===a));f=e.cornerNeighborData[d].cornerTiles;g=e.cornerNeighborData[d].cornerTileSamplerVersions;for(c=0;4>c;++c){l=y[c];const m=l?.renderData.geometryState.samplerDataVersion??-1,z=f[c]!==l,p=!z&&g[c]!==m;
if(z||p)f[c]=l,g[c]=m,this._markCornerDirty(d)}b.internalAssert(f.some(m=>m?.isLoaded||m===a))}b.ENABLE_TERRAIN_INTERNAL_CHECKS&&b.internalAssert(this.geometryState.neighborData.edgeResolutions.every(x=>0<x));for(e=0;4>e;++e)y[e]=null}};q._updateGeometry=function(a){if(this.tile.intersectsClippingArea){b.ENABLE_TERRAIN_INTERNAL_CHECKS&&b.internalAssert(!this.tile.intersectsClippingArea||this.geometryState.neighborData.edgeResolutions.every(d=>0<d));this.intersectionData=null;var e=this.tile,h=this.geometry.vertexAttributes;
h=!this._vao||!h||this._wireframeChanged||this._numVerticesPerSideChanged||this._samplerDataChanged||this._clippingAreaChanged||this._dirtyEdgeResolutions;var n=!h&&(0!==this._dirtyEdges||0!==this._dirtyEdgeResolutions),k=!n&&0!==this._dirtyCorners;h?(this.releaseGeometry(),this._createGeometry(a)):n||k?e.updateEdgeElevations():k?e.updateCornerElevations():console.warn("Update for no reason?");this._samplerDataChanged=this._numVerticesPerSideChanged=!1;this._dirtyCorners=this._dirtyEdges=this._dirtyEdgeResolutions=
0;this._wireframeChanged=this._clippingAreaChanged=!1}};q.releaseGeometry=function(){this._hasGeometry=!1;this.intersectionData=null;if(!this._vao)return!1;this._vao.dispose();this._vao=null;Y.releaseGeometry(this.geometry);return!0};q.ensureTexture=function(a,e){null!=this._texture&&this._texture.descriptor.width!==a&&this.releaseTexture();null==this._texture&&(this._texture=e(),this.tile.setMemoryDirty());return this._texture};q.releaseTexture=function(){null!=this._texture&&(this._texture.release(),
this._texture=null,this.tile.setMemoryDirty())};q._markCornerDirty=function(a){this._dirtyCorners|=1<<a};q._markEdgeDirty=function(a){this._dirtyEdges|=1<<a;this._markCornerDirty((a+0)%4);this._markCornerDirty((a+3)%4)};q._markEdgeResolutionDirty=function(a){this._dirtyEdgeResolutions|=1<<a;this._markEdgeDirty(a)};q._markAllEdgesAndCornersDirty=function(){this._dirtyEdgeResolutions=this._dirtyEdges=this._dirtyCorners=15};q.updateGeometryState=function(){var a=this._getElevationInfo();const e=this.tile;
var h=a.samplerData?e.getElevationVerticesPerSide(a.maxTileLevel):e.getDefaultVerticesPerSide();const n=Math.max(h,5);let k=e.clippingArea;if(!e.intersectsClippingArea||e.isWithinClippingArea)k=null;h=this.geometryState;let d=!1;h.numVerticesPerSide!==n&&(this._numVerticesPerSideChanged=!0,h.numVerticesPerSide=n,h.samplerDataVersion++,d=!0);a.changed&&(this._samplerDataChanged=!0,h.samplerData=a.samplerData,h.samplerDataVersion++,d=!0);ha.equals(h.clippingArea,k)||(this._clippingAreaChanged=!0,h.clippingArea=
k,d=!0);a=e.surface.wireframe;h.wireframe!==a&&(this._wireframeChanged=!0,h.wireframe=a,d=!0);this._geometryStateChangedSinceLastUpdate||(this._geometryStateChangedSinceLastUpdate=d);d&&this._markAllEdgesAndCornersDirty();this._hasGeometry=!0;return this._geometryStateChangedSinceLastUpdate};q._createGeometry=function(a){this.tile.createGeometry();const e=this.geometry.vertexAttributes,h=this.geometry.indices,n=a.gl;this._vao=new pa.VertexArrayObject(a,qa.terrainVertexAttributeLocations,{geometry:ka.glLayout(e.layout)},
{geometry:Z.BufferObject.createVertex(a,n.STATIC_DRAW,e.buffer)},Z.BufferObject.createIndex(a,n.STATIC_DRAW,h));this._hasGeometry=!0};q.setTextureReference=function(a,e=V.ActivationTime.Immediate){null!=a&&a.texture!==this._texture&&this.releaseTexture();this._textureRef.push(a,e)};q._getElevationInfo=function(){var a=this.geometryState.samplerData;const e=this.tile.layerInfo[U.LayerClass.ELEVATION],h=e.length,n=Array(h);let k=0;var d=0;let f=!1;for(let l=0;l<h;l++){var c=e[l];if(null!=c.upsampleInfo){c=
c.upsampleInfo.tile;var g=c.layerInfo[U.LayerClass.ELEVATION][l].data;g=g&&g.samplerData;a&&a[k]===g||(f=!0);n[k++]=g;d=Math.max(d,c.lij[0])}else c.data&&(g=this.tile.surface.layerViewByIndex(l,U.LayerClass.ELEVATION),oa.fallsWithinLayer(this.tile,g.layer,!1)&&(d=c.data,a&&a[k]===d.samplerData||(f=!0),n[k++]=d.samplerData,d=this.tile.level))}null!=a&&a.length!==k&&(f=!0);if(a=0<k)n.length=k;return{changed:f,samplerData:a?n:null,maxTileLevel:d}};q.checkGeometryWaterproofness=function(){if(b.ENABLE_TERRAIN_INTERNAL_CHECKS){var a=
this.tile;if(a.isLoaded&&a.intersectsClippingArea&&0!==a.level){var e=a.surface.extent;if(null==e||a.intersectsExtent(e)){var h=b.neighborEdgeIndices.map((f,c)=>null!=e?0>(2>c?-1:1)*(a.extent[3-c]-e[3-c]):!1),n=a.level;b.internalAssert(0===this._dirtyCorners);b.internalAssert(0===this._dirtyEdges);b.internalAssert(0===this._dirtyEdgeResolutions);b.internalAssert(!this._numVerticesPerSideChanged);b.internalAssert(!this._samplerDataChanged);b.internalAssert(!this._clippingAreaChanged);b.internalAssert(!this._wireframeChanged);
var k=b.neighborCornerIndices.map(f=>a.findNeighborCornerTileExact(f,c=>!c.intersectsClippingArea||c.isLoaded||c.level===a.level)??null).map(f=>f?.intersectsClippingArea?f:null),d=this.geometryState.neighborData;for(let f=0;4>f;++f){const c=d.cornerPeerNeighbors[f],g=k[f];b.internalAssert(g===c,`Tile[${a.lij}].corner[${f}] out of date: cur=[${c?.lij}] exp=[${g?.lij}]`)}b.neighborEdgeIndices.forEach((f,c)=>{if(!h[c]){var g=a.findNeighborTile(f,L=>(L.level===n||L?.isLoaded)&&L?.intersectsClippingArea);
if(g){b.internalAssert(g.isLoaded||g.level===a.level);b.internalAssert(g===this.geometryState.neighborData.edgePeerNeighbors[c]);var l=n-g.level;if(g.isLoaded){var x=g.renderData;b.internalAssert(ma.isEdgeNeighbor(a,g,f));b.internalAssert(0<=l);var m=2**l;if(0>l)b.internalAssert(!1);else{var z=a.renderData,p=z.geometry,v=p.outerEdges[c],w=p.numVerticesPerSide-1,t=x.geometry;if(t){p=this.geometryState.neighborData.edgePeerNeighbors[c];if(p?.isLoaded){var F=p.renderData;b.internalAssert(p===p);b.internalAssert(z.geometryState.neighborData.edgePeerNeighborSamplerVersions[c]===
F.geometryState.samplerDataVersion);b.internalAssert(this.geometryState.neighborData.edgePeerNeighborSamplerVersions[c]===F.geometryState.samplerDataVersion)}var P=(c+2)%4,C=t.outerEdges[P];p=v.count-1;F=C.count-1;b.internalAssert(p*m===F,`Tile[${a.lij}]:e${c},res=${p} edgeRes mismatch with`+` Neighbor[${g.lij}]:e${P},res=${F} (expected:${p*m})`);p=a.extent;F=f===S.NeighborIndex.NORTH||f===S.NeighborIndex.SOUTH;var D=C.count-1,G=D/2**l,E=v.count-1;if(1>G)b.internalAssert(1===E);else{b.internalAssert(G===
E);b.internalAssert(W.isPowerOfTwo(G));t=t.numVerticesPerSide-1;b.internalAssert(0<l||G===Math.max(t,w));l=a.getNeighborEdgeStartVertexIndex(c,g);b.internalAssert(0<=l&&l<m);m=l*G;b.internalAssert(0<=m&&m<=D-G);var H=0,I=m;v.getVertexPos(A,0);v.getVertexPos(B,v.count-1);m=r.distance(A,B);m=Math.max(1,1E-4*m);for(l=0;l<=G;++l){v.getVertexPos(A,H);C.getVertexPos(B,I);t=l/G;w=F?p[0]+t*(p[2]-p[0]):f===S.NeighborIndex.WEST?p[0]:p[2];const L=F?f===S.NeighborIndex.SOUTH?p[1]:p[3]:p[1]+t*(p[3]-p[1]),T=a.surface.extent;
if(null==T||ja.containsXY(T,w,L)){t=r.dist(A,B);D=r.len(A)-X.earth.radius;E=r.len(B)-X.earth.radius;const aa=t<m;aa||(console.warn("Tile edge vertex position mismatch: between"+` [${a.lij}].edge${c}[${H}/${v.count}] and`+` [${g.lij}].edge${P}[${I}/${C.count}]`),null!=T&&console.warn("  surface extent\x3d ",T," x,y\x3d",w,",",L),w=u.create(),r.subtract(w,z.localOrigin,x.localOrigin),0<r.len(w)&&console.warn(`   localOrigins: ${z.localOrigin} vs ${x.localOrigin}`+` d=${r.len(w)} [${w}]`),(()=>{const Q=
u.clone(A),ba=u.clone(B);a.updateEdgeElevations();g.updateEdgeElevations();v.getVertexPos(A,H);C.getVertexPos(B,I);const J=u.create();r.sub(J,A,Q);0<r.len(J)&&console.warn(`  XXX Tile[${a.lij}] edge out of date: ${Q} vs ${A} d=${r.len(J)} [${J}]`);r.sub(J,B,ba);0<r.len(J)&&console.warn(`  XXX Neighbor[${g.lij}] edge out of date: ${ba} vs ${B} d=${r.len(J)} [${J}]`)})(),b.internalAssert(aa,"Mismatch in tile"+` [${a.lij}].edge[${c}][${H}/${v.count}] vs neighbor`+` [${g.lij}].edge[${P}][${I}/${C.count}]`+
` ${b.v32s(A)} vs ${b.v32s(B)}  dist=${t} h(t|n|d)=${D}|${E}|${E-D}`));v.getNormal(M,H);C.getNormal(N,I);r.normalize(ca,M);r.normalize(da,N);const ea=r.dot(ca,da);w=.01>1-ea||a===g;if(!w){const Q=u.create();r.sub(Q,M,N);t=()=>`Mismatch in tile edge normal ${b.lij2s(a.lij)} (${H}/${v.count-1}) edge ${c} vs neighbor ${b.lij2s(g.lij)}  (${I}/${C.count-1}) nedge ${P} :`+`${b.v32s(M)} vs ${b.v32s(N)}  dot = ${ea} : ${b.v32s(Q)}`;console.warn("Mismatch in tile edge normal: ",t());a.updateEdgeElevations();
g.updateEdgeElevations();D=u.create();E=u.create();v.getNormal(D,H);C.getNormal(E,I);r.equals(M,D)||console.warn("Missing update in tile normal: ",b.v32s(M)," \x3d\x3e ",b.v32s(D));r.equals(N,E)||console.warn("Missing update in neighbor normal: ",b.v32s(N)," \x3d\x3e ",b.v32s(E));b.internalAssert(w,t())}}H+=1;I+=1}}}else b.internalAssert(!1)}}else b.internalAssert(!g.isLeaf),b.internalAssert(0===l)}else f=!a.surface.updatingRootTiles&&null!=a.surface.rootTiles&&0<a.surface.rootTiles.length&&a.shouldHaveNeighbor(f),
b.internalAssert(!f)}})}}else b.internalAssert(a?.isLoaded)}};fa._createClass(O,[{key:"tile",get:function(){return this._tile}},{key:"hasGeometry",get:function(){return this._hasGeometry}},{key:"vao",get:function(){return this._vao}},{key:"textureReference",get:function(){return this._textureRef.current}},{key:"nextTextureReference",get:function(){return this._textureRef.next}},{key:"textureFadeFactor",get:function(){return this._textureRef.fadeFactor}},{key:"textureIsFading",get:function(){return this._textureRef.isFading}},
{key:"estimatedGeometryMemoryUsage",get:function(){return(this.geometry.indices?.byteLength??0)+(this.geometry.vertexAttributes?.byteLength??0)+(this.intersectionData?.estimatedMemoryUsage??0)}},{key:"texture",get:function(){return this._texture}},{key:"test",get:function(){return{hasTexture:null!=this._texture}}}]);return O}();const A=u.create(),B=u.create(),M=u.create(),N=u.create(),ca=u.create(),da=u.create(),y=[null,null,null,null];Object.defineProperty(R,"ActivationTime",{enumerable:!0,get:()=>
V.ActivationTime});R.PatchRenderData=ra;R.neighborTileIfLoadedOrSelf=K;Object.defineProperty(R,Symbol.toStringTag,{value:"Module"})});