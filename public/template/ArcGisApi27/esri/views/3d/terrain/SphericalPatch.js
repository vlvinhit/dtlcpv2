// All material copyright ESRI, All Rights Reserved, unless otherwise specified.
// See https://js.arcgis.com/4.27/esri/copyright.txt for details.
//>>built
define("exports ../../../chunks/_rollupPluginBabelHelpers ../../../core/mathUtils ../../../chunks/vec3 ../../../chunks/vec3f64 ../../../geometry/projection ../../../geometry/support/DoubleArray ../../../geometry/support/frustum ../../../chunks/sphere ./interfaces ./ITile ./PatchGeometryFactory ./terrainUtils ./Tile ./tileUtils".split(" "),function(fa,U,ha,g,m,ra,sa,da,ta,V,Y,ea,B,Q,ua){function ia(J,C,p,b,a,d){J=b-J;C=a-C;p=d-p;return J*J+C*C+p*p}let xa=function(J){function C(b,a,d){var e=J.call(this)||
this;e._convexHull=Array(24);e._boundingSphere=ta.create();void 0!==b&&e.init(b,a,d);return e}U._inherits(C,J);var p=C.prototype;p.init=function(b,a,d){U._get(U._getPrototypeOf(C.prototype),"init",this).call(this,b,a,d);a=this.ellipsoid.radius;d=this.extentInRadians[0];const e=this.extentInRadians[1],c=this.extentInRadians[2],f=this.extentInRadians[3];b=b[0];const y=ha.lerp(e,f,.5),l=ha.lerp(d,c,.5);this._edgeLen=(c-d)*Math.cos(0===b?0:Math.min(Math.abs(e),Math.abs(f)))*a;this._edgeLen2=this._edgeLen*
this._edgeLen;this._curvatureHeight=a-Math.sqrt(a*a-this._edgeLen2/4);ra.lonLatToSphericalPCPF(this.centerAtSeaLevel,l,y,this.ellipsoid.radius);g.normalize(this.up,this.centerAtSeaLevel);this.updateRadiusAndCenter()};p.updateRadiusAndCenter=function(){this._updateBoundingVolumes();const b=this._center;if(0===this.lij[0])g.set(b[Q.CenterPosition.MIDDLE],0,0,0),g.set(b[Q.CenterPosition.TOP],0,0,0),g.set(b[Q.CenterPosition.BOTTOM],0,0,0),b[Q.CenterPosition.MIDDLE][3]=this.ellipsoid.radius+this.elevationBounds[1];
else{this._updateCenter();const f=b[Q.CenterPosition.MIDDLE],y=this.convexHull;var a=0;for(let l=0;8>l;++l){var d=Math,e=d.max;var c=3*l;c=ia(f[0],f[1],f[2],y[c],y[c+1],y[c+2]);a=e.call(d,a,c)}b[Q.CenterPosition.MIDDLE][3]=Math.sqrt(a)}};p._calculateFrustumVisibilityStatus=function(b){if(!da.intersectsSphere(b,this._boundingSphere))return Y.TileFrustumVisibility.OUTSIDE;if(10>this.lij[0])return Y.TileFrustumVisibility.INTERSECTS;const a=this.convexHull,d=this.surface.view.state.camera.near;let e=
!0;for(let f=0;f<da.NumPlanes;f++){var c=b[f];const y=c[0],l=c[1],E=c[2];c=c[3]-(f===da.PlaneIndex.NEAR?d:0);let G=!1;for(let K=0;8>K;++K){const z=3*K;if(0>y*a[z]+l*a[z+1]+E*a[z+2]+c){if(G=!0,!e)break}else e=!1}if(!G)return Y.TileFrustumVisibility.OUTSIDE}return e?Y.TileFrustumVisibility.INSIDE:Y.TileFrustumVisibility.INTERSECTS};p.computeElevationBounds=function(){U._get(U._getPrototypeOf(C.prototype),"computeElevationBounds",this).call(this);this._updateBoundingVolumes()};p.createGeometry=function(){ea.createSphericalGlobePatch(this.renderData,
this._getPatchType());this._updateBoundingVolumes();this.setMemoryDirty()};p._updateBoundingVolumes=function(){this._updateConvexHull();this._updateBoundingSphere();B.ENABLE_TERRAIN_INTERNAL_CHECKS&&this._checkBVs()};p._updateBoundingSphere=function(){const b=this._boundingSphere;var a=this.elevationBounds,d=this.ellipsoid.radius,e=a[1];if(0===this.level)g.set(b,0,0,0),b[3]=d+e;else{e=this.extentInRadians;var c=.5*(e[0]+e[2]),f=e[3];M(ja,c,e[1],d);M(ka,c,f,d);g.add(b,ja,ka);g.scale(b,b,(d+.5*(a[0]+
a[1]))/g.len(b));a=this.convexHull;d=0;for(e=0;8>e;++e){c=b[0]-a[3*e];f=b[1]-a[3*e+1];const y=b[2]-a[3*e+2];d=Math.max(d,Math.sqrt(c*c+f*f+y*y))}b[3]=d+2}};p._updateConvexHull=function(){var b=this.extentInRadians,a=this.ellipsoid.radius;if(0!==this.level){var d=this.elevationBounds,e=this._getPatchType(),c=this.surface.isWebMercator,f=c&&e===V.PatchType.HAS_NORTH_POLE,y=(e=c&&e===V.PatchType.HAS_SOUTH_POLE)||f;c=Math.PI/2;var l=b[0],E=b[2];e=e?-c:b[1];var G=f?c:b[3],K=.5*(l+E);b=d[0];var z=a+(y?
Math.min(0,b-1):b);b=m.create();f=m.create();c=m.create();var L=m.create();M(b,l,e,z);M(f,l,G,z);M(c,E,G,z);M(L,E,e,z);l=(F,w)=>{for(let H=0;3>H;++H)this._convexHull[3*w+H]=F[H]};l(b,0);l(f,1);l(c,2);l(L,3);d=d[1];var aa=a+(y?Math.max(0,d+1):d),h=m.create();a=m.create();d=m.create();M(a,K,G,z);M(d,K,e,z);g.add(h,a,d);g.normalize(h,h);var x=m.create(),D=m.create();e=(F,w)=>{g.sub(D,F,w);g.normalize(D,D);w=-g.dot(F,x)/g.dot(D,x);B.internalAssert(0<=w);g.scale(D,D,w);g.add(F,F,D)};2**this.lij[0]>2*this.lij[1]?
(a=m.create(),g.cross(a,la,d),g.normalize(a,a),g.cross(x,d,a),g.normalize(x,x),B.internalAssert(B.almostEquals(g.dot(x,d)/g.len(d),0)),e(b,f),e(L,c),l(b,0),l(L,3)):2**this.lij[0]!==2*this.lij[1]&&(d=m.create(),g.cross(d,la,a),g.normalize(d,d),g.cross(x,d,a),g.normalize(x,x),e(f,b),e(c,L),l(f,1),l(c,2));a=(F,w)=>{const H=aa/g.dot(w,h);for(let N=0;3>N;++N)this._convexHull[3*F+N]=w[N]*H};a(4,b);a(5,f);a(6,c);a(7,L)}};p._getPatchType=function(){const b=this.lij[1],a=b===(1<<this.level)-1;return 0===b?
a?V.PatchType.HAS_BOTH_POLES:V.PatchType.HAS_NORTH_POLE:a?V.PatchType.HAS_SOUTH_POLE:V.PatchType.REGULAR};p.intersectsRay=function(b,a,d,e){var c=this._boundingSphere;d=c[3]+d;var f=c[0]-b[0];e=c[1]-b[1];b=c[2]-b[2];c=(f*a[0]+e*a[1]+b*a[2])/(a[0]*a[0]+a[1]*a[1]+a[2]*a[2]);f=a[0]*c-f;e=a[1]*c-e;a=a[2]*c-b;return f*f+e*e+a*a<d*d};p.getDefaultVerticesPerSide=function(){return this.level<ma.length?ma[this.level]+1:2};p.updateCornerElevations=function(){ea.updateCornerSpherical(this.renderData);this._updateBoundingVolumes()};
p.updateEdgeElevations=function(){ea.updateEdgesAndCornersSpherical(this.renderData);this._updateBoundingVolumes()};p._checkBVs=function(){if(B.ENABLE_TERRAIN_INTERNAL_CHECKS&&!(2>=this.level)){var b=this._boundingSphere,a=b[3],d=m.create(),e=this.ellipsoid.radius,c=this.elevationBounds;c[1]-c[0];var f=e+c[0],y=this._center[Q.CenterPosition.MIDDLE][3],l=this.convexHull,E=(k,r)=>{for(let n=0;3>n;++n)k[n]=l[3*r+n]},G=m.create(),K=m.create(),z=m.create(),L=m.create(),aa=m.create(),h=(k,r,n,I)=>{E(K,
k);E(z,r);E(L,n);g.sub(K,K,z);g.sub(L,L,z);g.cross(G,K,L);g.normalize(G,G);var W=g.dot(G,z);E(aa,I);const ba=g.dot(G,aa);W=Math.abs(ba-W);B.internalAssert(B.almostEquals(W,0),`Non coplanar ${k},${r},${n},${I} diff = ${W}`)};h(0,1,2,3);h(4,5,6,7);h(0,1,4,5);h(1,2,5,6);h(2,3,6,7);h(3,0,7,4);var x=sa.newDoubleArray(24),D=m.create(),F=m.create(),w=m.create(),H=m.create();h=(k,r,n,I)=>{E(D,r);E(F,n);E(w,I);g.sub(D,D,F);g.normalize(D,D);g.sub(w,w,F);g.normalize(w,w);g.cross(H,D,w);g.normalize(H,H);r=g.dot(H,
F);k*=4;for(n=0;3>n;++n)x[k+n]=H[n];x[k+3]=r};h(0,0,1,2);h(1,1,0,4);h(2,1,5,2);h(3,3,2,6);h(4,4,0,3);h(5,4,6,5);var N=(k,r,n,I)=>{k*=4;return x[k]*r+x[k+1]*n+x[k+2]*I-x[k+3]},A=(k,r,n,I)=>-1<=N(k,r,n,I),O=2**this.lij[0]>2*this.lij[1];h=(k,r,n)=>Math.sqrt(ia(k,r,n,b[0],b[1],b[2]))<a;var q=this.extentInRadians,u=.5*(q[0]+q[2]),R=q[1],t=q[3];q=m.create();var v=m.create();M(q,u,t,f);M(v,u,R,f);f=O?"Upper":"Lower";O=!0;for(u=0;6>u;++u){for(R=0;8>R;++R)t=3*R,t=-1<=N(u,l[t],l[t+1],l[t+2]),O&&(O=t),B.internalAssert(t,
`Tile[${this.lij}] Convex hull point ${R} outside of plane ${u}`);B.internalAssert(A(u,v[0],v[1],v[2]),`Tile[${this.lij}] (${f}) bottom mid outside of plane ${u}`);B.internalAssert(A(u,q[0],q[1],q[2]),`Tile[${this.lij}] (${f}) top mid outside of plane ${u}`)}B.internalAssert(O,"Not all convex hull points are inside  convex hull polyhedron");B.internalAssert(h(v[0],v[1],v[2]),`Tile[${this.lij}] (${f}) bottom mid outside of bounding sphere`);B.internalAssert(h(q[0],q[1],q[2]),`Tile[${this.lij}] (${f}) top mid outside of bounding sphere`);
for(A=0;8>A;++A)q=3*A,q=h(l[q],l[q+1],l[q+2]),B.internalAssert(q,`Tile[${this.lij}] Convex hull point ${A} outside of bounding sphere`);for(h=0;6>h;++h)for(A=0;8>A;++A)q=3*A,-1<=N(h,l[q],l[q+1],l[q+2])||console.error(`Tile[${this.lij}] Convex hull point ${A} outside of plane ${h}`);h=this.extentInRadians;h=Math.round(Math.max(h[2]-h[0],h[3]-h[1])*e);if(u=this.renderData){var {geometry:na,localOrigin:va}=u;if(A=na.vertexAttributes?.position){q=A.count;v=m.create();f=na.numVerticesPerSide-2;O=f*f;u=
u.geometryState.neighborData;R=u.edgeResolutions.reduce((k,r)=>k+r+1,0);for(let k=0;k<q;++k){const r=k<O,n=!r&&k<O+R;let I=!1;t=-1;if(n){var S=O;for(var T=0;4>T;++T){var Z=u.edgeResolutions[T];if(k===S||k===S+Z-1){I=!0;break}S+=Z;if(k<S){t=T;break}}}t=n?u.edgePeerNeighbors[t]:null;const W=n&&t&&0<ua.compareTilesByLij(this,t);A.getVec(k,d);g.add(v,d,va);t=g.len(v)-e;S=0;T=!1;Z=c[0]-t;const ba=t-c[1],oa=1<Z,pa=1<ba;var P=oa||pa;const qa=()=>{const ca=n&&!I;return`Tile[${this.lij}].vertex[${k}]:${r?
"internal":ca?"edge":I?"corner":"pole"}`+(oa?"(below)":pa?"(above)":"")+(W?"(Neighbor)":"")};var X=g.dist(v,b);X>=a+0&&(X-=a,P||(console.error(`${qa()} is out of the bounding sphere by ${X.toFixed(0)} / ${a.toFixed(0)}`+"[tol\x3d0]"+` h=${t.toFixed(0)} / [${c[0].toFixed(0)}..${c[1].toFixed(0)}] (${(X/a).toFixed(0)})`),T=!0));for(P=0;6>P;++P)if(!(-1<=N(P,v[0],v[1],v[2]))){X=N(P,v[0],v[1],v[2]);const ca=k%f,wa=(k-ca)/f;0===P&&Z||5===P&&ba||(console.error(`${qa()} (${ca},${wa})|${f}] is out of the bounding trapezoid plane ${P}`+
` h=${Math.round(t)} / [${Math.round(c[0])}..${Math.round(c[1])}] dist=${Math.round(X)}`+` radii = ${Math.round(a)}/${Math.round(y)}} : maxL = ${h}`),++S)}if(T||0<S)break}}}}};U._createClass(C,[{key:"convexHull",get:function(){return this._convexHull}}]);return C}(Q.Tile);const ma=[128,64,64,32,16,8,8,4],M=(J,C,p,b)=>{const a=Math.sin(C),d=Math.cos(p);p=Math.sin(p);J[0]=b*d*Math.cos(C);J[1]=b*d*a;J[2]=b*p},la=[0,0,1],ja=m.create(),ka=m.create();fa.SphericalPatch=xa;Object.defineProperty(fa,Symbol.toStringTag,
{value:"Module"})});