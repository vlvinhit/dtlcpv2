// All material copyright ESRI, All Rights Reserved, unless otherwise specified.
// See https://js.arcgis.com/4.27/esri/copyright.txt for details.
//>>built
define("exports ../../../chunks/_rollupPluginBabelHelpers ../../../Camera ../../../Viewpoint ../../../core/Error ../../../core/promiseUtils ../../../core/reactiveUtils ../camera/constraintUtils ../camera/constraintUtils/surfaceCollision ./controllers/CameraController ./controllers/PointToPointAnimationController ./controllers/SurfaceCollisionCorrectionController ../support/cameraUtils ../support/viewpointUtils".split(" "),function(m,r,t,u,k,n,v,w,p,g,l,x,y,z){let A=function(){function q(a,b,c){this.target=
a;this.options=b;this.view=c;this.state="pending";this._animationController=null;this._promise=new Promise((f,h)=>{this._resolveCallback=f;this._rejectCallback=h;f=new AbortController;if(null!=this.options.signal)n.onAbort(this.options.signal,()=>{this.abort()});this._abortController=f;this.waitForReady()})}var e=q.prototype;e.then=function(a,b){return this._promise.then(a,b)};e.catch=function(a){return this._promise.catch(a)};e.resolve=function(a){if("finished"!==this.state)return this.state="finished",
this._resolveCallback(a)};e.reject=function(a){if("finished"!==this.state)return this.state="finished",this._rejectCallback(a)};e.abort=function(a=!1){this._abortController.abort();switch(this.state){case "wait-for-animation-finish":!a&&null!=this._animationController&&this.view.state.cameraController===this._animationController&&this._animationController.active&&this._animationController.stopController()}this.reject(n.createAbortError())};e.waitForReady=async function(){this.state="wait-for-ready";
if(!this.view.ready)try{await v.whenOnce(()=>this.view.ready,this._abortController.signal)}catch(a){return this.reject(a)}this.createViewPoint()};e.createViewPoint=function(){"finished"!==this.state&&(this.state="wait-for-viewpoint",this._animationController=this.options.animate?this._getAnimationController():null,z.create(this.view,this.target,this._abortController.signal).then(a=>{"finished"!==this.state&&(a=a?this._getCameraFromViewpoint(a):null,null!=a&&(this.options.animate?null!=this._animationController&&
this.startAnimation(a,this._animationController):(this.view.stateManager.setStateCamera(a.camera,{applyConstraints:!a.isFullySpecified,positionAndOrientationOnly:!0,doNotCancelGoToOperation:!0}),this.resolve())))},a=>{this.reject(a)}))};e._getCameraFromViewpoint=function(a){const b=!!(this.target instanceof u&&this.target.camera||this.target instanceof t);var c=a.camera;if(null==c)return null;if(!this.view.stateManager.isCompatible(c))return a=(a=c.position)&&a.spatialReference,this.reject(new k("GotoAnimation:incompatible-spatialreference",
`Resulting camera has an incompatible spatial reference (camera: ${a?a.wkid:"none"}, view: ${this.view.spatialReference?.wkid})`,{camera:c})),null;c=y.externalToInternal(this.view,c);return null==c?(this.reject(new k("GotoAnimation:invalid-camera","Resulting camera is invalid")),null):{viewpoint:a,camera:c,isFullySpecified:b}};e.startAnimation=function(a,b){this.state="wait-for-animation-finish";const c=b.viewAnimation;if(null==c)this.reject(new k("GotoAnimation:missing-animation","Unreachable code in view.stateManager"));
else{c.update(a.viewpoint,"running");if(!b.active||null==b.viewAnimation||b.viewAnimation.target!==a.viewpoint||this.view.state.cameraController!==b)return this.abort();if(a.isFullySpecified){var f=new x.SurfaceCollisionCorrectionController({view:this.view,desiredCamera:a.camera});p.applySurfaceCollisionConstraint(this.view,a.camera,p.Mode.EYE_AND_CENTER)}else w.applyAll(this.view,a.camera);b.begin(a.camera,this.options);var h=d=>{if(null!=this.view.state)switch(b.state){case g.State.Finished:switch(this.state){case "pending":case "wait-for-ready":case "wait-for-viewpoint":case "wait-for-animation-finish":this.resolve()}break;
case g.State.Ready:case g.State.Rejected:case g.State.Running:case g.State.Stopped:switch(this.state){case "pending":case "wait-for-ready":case "wait-for-viewpoint":case "wait-for-animation-finish":this.reject(d)}}};c.when(()=>{const d=this.view.state.cameraController;f&&(d&&d.active?d instanceof l.PointToPointAnimationController&&null!=d.viewAnimation&&d.viewAnimation.target===a.viewpoint&&(this.view.state.cameraController=f):null!=b.viewAnimation&&b.viewAnimation.target===a.viewpoint&&"finished"===
b.state&&(this.view.state.cameraController=f))},d=>h(d));b.asyncResult={resolve:()=>h(),reject:d=>h(d)}}};e._getAnimationController=function(){let a=null;var b=null;b=this.view.state.cameraController;b instanceof l.PointToPointAnimationController&&(b.updateStateFromViewAnimation(),b.active&&(a=b,b=a.viewAnimation));return null!=a||(a=new l.PointToPointAnimationController({view:this.view,mode:"animation"}),b=a.viewAnimation,this.view.state.switchCameraController(a))?a:(null!=b&&b.stop(),this.reject(new k("GotoAnimation:goto-cannot-interrupt",
"Cannot start an animation while interacting")),null)};return r._createClass(q)}();m.GoToOperation=A;Object.defineProperty(m,Symbol.toStringTag,{value:"Module"})});