// All material copyright ESRI, All Rights Reserved, unless otherwise specified.
// See https://js.arcgis.com/4.27/esri/copyright.txt for details.
//>>built
define(["exports","../../../../chunks/_rollupPluginBabelHelpers","../../../../chunks/vec2","../../../../chunks/vec2f64"],function(u,r,q,z){let w=function(){function n(){}n.prototype.rebuildConnectingProfileGeometry=function(h,l,a){for(let b=0;b<l.vertices.length;++b)a(h.frame,l.vertices[b],l.normals[b],0,0)};return r._createClass(n)}(),B=function(n){function h(){var a=n.call(this)||this;a.numVertices=0;a.numIndices=0;return a}r._inherits(h,n);var l=h.prototype;l.rebuildCapGeometry=function(){};l.buildTopology=
function(){};return r._createClass(h)}(w),C=function(n){function h(a,b=0,c=!1){var e=n.call(this)||this;e.profile=a;e.profilePlaneOffset=b;e.flip=c;return e}r._inherits(h,n);var l=h.prototype;l.rebuildConnectingProfileGeometry=function(a,b,c){const e=this.profilePlaneOffset;for(let d=0;d<b.vertices.length;++d)c(a.frame,b.vertices[d],b.normals[d],e,0)};l.rebuildCapGeometry=function(a,b){const c=this.profile,e=this.flip?1:-1,d=this.profilePlaneOffset,g=A;q.set(g,0,0);for(let f=0;f<c.vertices.length;++f)b(a.frame,
c.vertices[f],g,d,e)};l.buildTopology=function(a,b){a=this.profile;const c=this.vertexBufferStart+a.indices[0];for(let e=1;e<a.numSegments;++e){const d=this.vertexBufferStart+a.indices[2*e],g=this.vertexBufferStart+a.indices[2*e+1];this.flip?b(g,d,c):b(c,d,g)}};r._createClass(h,[{key:"numVertices",get:function(){return this.profile.vertices.length}},{key:"numIndices",get:function(){return 3*this.profile.numSegments}}]);return h}(w),E=function(n){function h(a){var b=n.call(this)||this;b.flip=!1;b.sign=
0;b.breakNormals=!1;b.numSegments=3;b.profile=a.profile;b.flip=a.flip;b.sign=b.flip?1:-1;b.breakNormals=a.breakNormals;b.numSegments=a.subdivisions;return b}r._inherits(h,n);var l=h.prototype;l.rebuildCapGeometry=function(a,b){const c=this.profile;a=a.frame;const e=.5*this.sign,d=D,g=A;q.set(g,0,0);for(var f of c.poles)f.normal?b(a,f.position,f.normal,e,0):b(a,f.position,g,e,this.sign);if(this.breakNormals)for(f=0;f<c.vertices.length;++f)b(a,c.vertices[f],c.normals[f],0,0);for(f=0;f<this.numSegments-
1;++f){var m=(1-(f+1)/this.numSegments)*Math.PI*.5;const t=Math.sin(m);m=Math.cos(m);for(let p=0;p<c.vertices.length;++p){const k=c.poles[c.poleIndices[p]];q.subtract(d,c.vertices[p],k.position);q.scale(d,d,t);k.normal?(q.add(d,d,k.position),b(a,d,k.normal,e*m,0)):(q.normalize(g,d),q.scale(g,g,t),q.add(d,d,k.position),b(a,d,g,e*m,this.sign*m))}}};l.buildTopology=function(a,b){a=this.profile;const c=this.breakNormals?this.vertexBufferStart+a.poles.length:this.firstProfileVertexIndex,e=this.breakNormals?
this.vertexBufferStart+a.poles.length+a.vertices.length:this.vertexBufferStart+a.poles.length;for(let d=0;d<a.numSegments;++d){const g=a.indices[2*d],f=a.indices[2*d+1],m=this.vertexBufferStart+a.poleIndices[g],t=this.vertexBufferStart+a.poleIndices[f];let p=c+g,k=c+f;for(let x=0;x<this.numSegments-1;++x){const v=e+x*a.vertices.length+g,y=e+x*a.vertices.length+f;this.flip?(b(v,k,p),b(k,v,y)):(b(p,k,v),b(y,v,k));p=v;k=y}this.flip?(b(m,k,p),m!==t&&b(m,t,k)):(b(p,k,m),m!==t&&b(k,t,m))}};r._createClass(h,
[{key:"numVertices",get:function(){let a=this.profile.vertices.length*(this.numSegments-1)+this.profile.poles.length;this.breakNormals&&(a+=this.profile.vertices.length);return a}},{key:"numIndices",get:function(){let a;const b=this.profile;a=2*b.numSegments*(this.numSegments-1);for(let c=0;c<b.numSegments;++c)a=b.poleIndices[b.indices[2*c]]===b.poleIndices[b.indices[2*c+1]]?a+1:a+2;return 3*a}}]);return h}(w);const D=z.create(),A=z.create();u.NoCapBuilder=B;u.PathCapBuilder=w;u.RoundCapBuilder=E;
u.TriangulationCapBuilder=C;Object.defineProperty(u,Symbol.toStringTag,{value:"Module"})});