// All material copyright ESRI, All Rights Reserved, unless otherwise specified.
// See https://js.arcgis.com/4.27/esri/copyright.txt for details.
//>>built
define("../../../../chunks/_rollupPluginBabelHelpers ../../../../core/asyncUtils ../../../../core/has ../../../../core/lang ../../../../core/promiseUtils ../../../../core/urlUtils ./enums ./I3SBinaryReader ./I3SMaterialUtil".split(" "),function(B,r,C,D,x,y,v,z,w){return function(){function t(a,b,f,c,d,e){this._streamDataController=b;this._logger=f;this._defaultGeometrySchema=c;this._requiredAttributes=d;this._options=e;this._logLayer=a;this._layerUrl=a.parsedUrl.path;this._geometryDefinitions=a.geometryDefinitions;
if(a.materialDefinitions){const g=a.textureSetDefinitions;this._materialAndTextures=a.materialDefinitions.map(h=>w.getMaterialAndTextures(g,h))}}var k=t.prototype;k._load=function(a,b,f){return this._streamDataController.request(a,b,f)};k._loadAttribute=function(a,b,f){return this._load(`${this._layerUrl}/nodes/${a.resources.attributes}/attributes/${b.key}/0`,"binary",f).then(c=>z.readBinaryAttribute(b,c))};k.loadAttributes=function(a,b,f){return x.eachAlways(b.map(c=>this._loadAttribute(a,c.attributeStorageInfo,
f))).then(c=>{const d={};for(let e=0;e<b.length;++e){const g=c[e].value;if(g)d[b[e].name]=g;else{if(x.isAbortError(c[e].error))throw c[e].error;this._logger.error("#loadAttributes",this._logLayer,`Failed to load attributeData for '${b[e].name}' on node '${a.id}'`,c[e].error)}}return d})};k.loadNodeData=async function(a,b){var f=null!=this._requiredAttributes&&a.resources.attributes?r.result(this.loadAttributes(a,this._requiredAttributes,b)):null;var c=this._geometryDefinitions;var d={bufferDefinition:null,
bufferIndex:0};var e=a.resources.geometryDefinition;if(!(null==c||null==e||0>e)&&(c=0<=e?c[e].geometryBuffers:null,null!=c))for(e=0;e<c.length;e++){var g=c[e];if(null!=g.compressedAttributes){if("draco"===g.compressedAttributes.encoding&&!C("disable-feature:i3s-draco")){d.bufferIndex=e;d.bufferDefinition=g;break}}else d.bufferIndex=e,d.bufferDefinition=c[e]}const {bufferDefinition:h,bufferIndex:n}=d;e=(g=!!a.resources.geometry)?r.result(this._loadGeometry(a.resources.geometry,n,b)):null;c=a.resources.hasSharedResource?
await this._loadShared(a,b):null;d=a.resources.materialDefinition;d=this._materialAndTextures&&null!=d&&0<=d?this._materialAndTextures[d]:null!=c?w.getMaterialAndTexturesFromShared(c):null;var p=d?.material;d=d?.textures??[];const u=`${a.id}`,A=!g&&this._options.loadFeatureData;g=A?await this._loadFeatureData(u,b):null;if(A)a:{if(g)for(l of g.featureData)if(p=l.geometries,null!=p)for(var q of p){var l={featureIds:[l.id],featureDataPosition:l.position,geometries:[q]};break a}l=null}else l={featureIds:[],
geometries:[{type:"ArrayBufferView",params:{material:p}}],featureDataPosition:[0,0,0]};if(null==l)if(g){q=[];for(m of g.featureData)null!=m.position&&q.push({featureIds:[m.id],featureDataPosition:m.position,geometries:[]});var m=q}else m=null;else m=null;q=0<d.length?r.result(this.loadTextures(a,d,b)):null;b=a=null;e&&(a=r.assertResult(await e),(b=this._defaultGeometrySchema)&&c&&c.materialDefinitions&&(e=Object.keys(c.materialDefinitions)[0],!c.materialDefinitions[e].params.vertexRegions&&b.vertexAttributes.region&&
(b=D.clone(b),delete b.vertexAttributes.region)),b=z.createGeometryDescriptor(h,b));c=q?r.assertResult(await q):null;f=(f=f?r.assertResult(await f):{})?{attributeData:f,loadedAttributes:this._requiredAttributes}:null;if(null!=l)return{geometryData:l,attributeDataInfo:f,geometryBuffer:a,geometryDescriptor:b,requiredTextures:d,textureData:c};if(null!=m)return{pointData:m,attributeDataInfo:f,geometryBuffer:a,geometryDescriptor:b,requiredTextures:d,textureData:c};throw Error();};t._addAbsoluteHrefTexture=
function(a,b){a=a.textureDefinitions;if(null!=a)for(const f of Object.keys(a))for(const c of a[f].images)Array.isArray(c.href)?c.hrefConcat=c.href.map(d=>y.makeAbsolute(d,b)):c.hrefConcat=y.makeAbsolute(c.href,b)};t._fixTextureEncodings=function(a){a=a.textureDefinitions;if(null!=a)for(const f in a){const c=a[f];if(Array.isArray(c.encoding))for(var b=0;b<c.encoding.length;b++){const d=c.encoding[b];"data:"===d.substring(0,5)&&(c.encoding[b]=d.substring(5))}else b=c.encoding,"data:"===b.substring(0,
5)&&(c.encoding=b.substring(5))}};k._loadShared=function(a,b){const f=`${this._layerUrl}/nodes/${a.resources.geometry}/shared`;return this._load(f,"json",b).then(c=>{t._fixTextureEncodings(c);t._addAbsoluteHrefTexture(c,f);return c})};k._loadTexture=function(a,b,f,c,d,e){let g=!1;return d===v.TextureEncoding.DDS_S3TC||d===v.TextureEncoding.KTX2||d===v.TextureEncoding.Basis?this._load(a,"binary",e).then(h=>({id:b,usage:f,data:h,encoding:d,downsampled:g})):this._load(a,"image",e).then(h=>{var n=h;if(c&&
4096<=h.width*h.height){n=Math.ceil(h.width/2);const p=Math.ceil(h.height/2),u=document.createElement("canvas");u.width=n;u.height=p;u.getContext("2d").drawImage(h,0,0,n,p);n=u;g=!0}return{id:b,usage:f,data:n,encoding:d,downsampled:g}})};k.loadTextures=function(a,b,f){const c=!!this._options.uncompressedTextureDownsamplingEnabled,d=this._options.textureUsageMask;return Promise.all(b.map(e=>{if(0===(e.usage&d))return null;const g=w.selectEncoding(e.encodings,this._options.textureEncodings);return null==
g?(this._logger.error("#loadTextures",this._logLayer,`No known encoding for texture found on node ${a.id}`),Promise.reject()):this._loadTexture(`${this._layerUrl}/nodes/${a.resources.texture||a.id}/textures/${g.name}`,e.id,e.usage,c,g.encoding,f)}))};k._loadFeatureData=function(a,b){return this._load(`${this._layerUrl}/nodes/${a}/features/0`,"json",b)};k._loadGeometry=function(a,b,f){return this._load(`${this._layerUrl}/nodes/${a}/geometries/${b}`,"binary",f)};return B._createClass(t)}()});