// All material copyright ESRI, All Rights Reserved, unless otherwise specified.
// See https://js.arcgis.com/4.27/esri/copyright.txt for details.
//>>built
define("exports ../../../../chunks/_rollupPluginBabelHelpers ../../../../core/Error ../../../../core/maybe ../../../../core/MemCache ../../../../core/promiseUtils ../../../../core/uuid ../../../../chunks/mat3 ../../../../chunks/mat3f64 ../../../../chunks/vec3 ../../../../chunks/vec3f64 ../../../../geometry/projection ../../../../chunks/sphere ../../../ViewingMode ./I3SClientMaterialUtil".split(" "),function(E,O,C,J,P,Q,R,S,T,U,V,W,X,Y,Z){function K(g,h){var {spatialReference:a}=g;const b=[1,-1],d=
[.5*g.width,.5*g.height,g.hasZ?.5*(g.zmax-g.zmin):0];a=a.isGeographic?a.metersPerUnit:1;const f=g.center;let e=0;if(g.hasZ)for(g=0;2>g;++g)for(var c=0;2>c;++c)for(var k=0;2>k;++k){var p=(f.x+b[g]*d[0]-h.x)*a;const x=(f.y+b[c]*d[1]-h.y)*a,n=f.z+b[k]*d[2]-h.z;e=Math.max(p*p+x*x+n*n,e)}else for(g=0;2>g;++g)for(c=0;2>c;++c)k=(f.x+b[g]*d[0]-h.x)*a,p=(f.y+b[c]*d[1]-h.y)*a,e=Math.max(k*k+p*p,e);return X.fromCenterAndRadius([h.x,h.y,h.z],Math.sqrt(e))}async function L(g,h,a,b){const {transform:d,vertexAttributes:f}=
h.loadedMesh;g="source"===g.shading?f.normal:null;if(null==g||null==d||0===d.rotationAngle&&U.exactEquals(d.scale,V.ONES))return{transformed:g,original:f.normal};if(!h.normalsTransformPromise){J.assertIsSome(a,"SceneLayerWorker is needed to transform mesh normals");const e=T.create();S.normalFromMat4(e,d.localMatrix);h.normalsTransformPromise=a.transformNormals({normalMatrix:e,normals:g},b)}return h.normalsTransformPromise}function y(g,h,a){g[h]=255&a;g[h+1]=255&a>>8;g[h+2]=255&a>>16;g[h+3]=255&a>>
24}let ia=function(){function g(a,b,d,f,e,c){this._uid=a;this._indexSR=b;this._renderSR=d;this._viewingMode=f;this._worker=c;this._id2Meta=new Map;this._oid2Meta=new Map;this._memCache=e.newCache(`sl-client-mesh-data-${this._uid}`)}var h=g.prototype;h.createMeshNodeInfo=function(a,b){const d=`mesh${b}`;var f=a.extent,e=f.spatialReference,c=this._indexSR;f=K(f,a.origin);W.projectBoundingSphere(f,e,f,c);c=a.metadata.displaySource?.source;if(null==c||!Array.isArray(c)||!c.length||c[0]instanceof File)var k=
R.generateUUID();else{e="";for(k of c)e+=k.makeHash();k=JSON.stringify(null!=a.transform?a.transform.toJSON():"");c=a.vertexSpace.isRelative?JSON.stringify(a.vertexSpace.origin):"";k=e+k+c}return{type:"mesh",id:d,version:k,oid:b,mbs:f,componentNodeIds:[],unloadedMesh:a,nodeIndex:null,loadMeshPromise:null}};h.addMeshNode=function(a,b){if(null!=this.getMeshNodeIndex(b.oid))throw new C(`I3SClientNodeLoader: client side mesh for feature oid=${b.oid} already exists`);b.nodeIndex=a;this._id2Meta.set(b.id,
b);this._oid2Meta.set(b.oid,b)};h.getMeshNodeIndex=function(a){a=this._oid2Meta.get(a);return null==a||"mesh"!==a.type?null:a.nodeIndex};h.removeNode=function(a){if(null!=a){var b=this._id2Meta.get(a);null!=b&&(this._id2Meta.delete(a),"mesh"===b.type&&this._oid2Meta.delete(b.oid))}};h.loadNodeJSON=async function(a){const b=this._id2Meta.get(a);if(null==b)throw new C(`I3SClientNodeLoader::loadNodeJSON unable to find node ${a}`);switch(b.type){case "mesh":return this._loadMeshNodeJSON(b);case "mesh-component":return this._loadMeshComponentNodeJSON(b);
default:throw new C(`I3SClientNodeLoader::loadNodeJSON unable to handle node ${a}`);}};h._loadMeshNodeJSON=async function(a){const b=a.id;var d=(await this._getMeshData(a)).loadedMesh;if(null==d.components||0===d.components.length)return{id:b,version:null,mbs:a.mbs,obb:null,sharedResource:null,geometryData:null,attributeData:null,featureData:null,children:null};const f=[];d=d.components;for(let e=0;e<d.length;++e){const c=`${b}-component${e}`,k={type:"mesh-component",id:c,mbs:a.mbs,componentIndex:e,
meshNodeInfo:a,textureData:new Map};this._id2Meta.set(k.id,k);a.componentNodeIds.push(c);f.push({id:k.id,href:null,mbs:k.mbs,obb:null})}return{id:b,version:null,mbs:a.mbs,obb:null,sharedResource:null,geometryData:null,attributeData:null,featureData:null,children:f}};h.updateNodeIndex=function(a,b,d){null!=a&&(a=this._id2Meta.get(a))&&"mesh"===a.type&&(a.nodeIndex=d)};h._loadMeshComponentNodeJSON=async function(a){return{id:a.id,version:a.meshNodeInfo.version,mbs:a.mbs,obb:null,sharedResource:null,
geometryData:null,attributeData:null,featureData:null,children:null,isEmpty:!1}};h.loadNodeData=async function(a,b){var d=this._id2Meta.get(a.id);if(null==d||"mesh-component"!==d.type)throw new C(`Failed to load client node data for node ${a.id} (unexpected node info)`);var f=d.meshNodeInfo,e=await this._getMeshData(f),c=e.loadedMesh;f=f.oid;if(null==c.components)throw new C(`Failed to load client node data for node ${a.id} (unexpected null reference)`);a=c.components[d.componentIndex];const {material:k,
requiredTextures:p,textureData:x}=await Z.convertMeshMaterialToPBRMaterial(a.material);if(null!=x)for(var n of x)null!=n&&d.textureData.set(n.id,n);d={params:{material:k},type:"ArrayBufferView"};const {vertexSpace:aa,origin:F,transform:ba}=c;n=[F.x,F.y,F.z??0];d={featureDataPosition:n,featureIds:[],geometries:[d]};e.projectionPromise||(J.assertIsSome(this._worker,"SceneLayerWorker is needed to project mesh"),e.projectionPromise=this._worker.project({positions:c.vertexAttributes.position,localMatrix:ba?.localMatrix,
vertexSpace:aa.toJSON(),origin:n,inSpatialReference:c.spatialReference.toJSON(),outSpatialReference:this._indexSR.toJSON(),local:this._viewingMode===Y.ViewingMode.Local},b));const {projected:G,original:ca}=await e.projectionPromise;c.vertexAttributes.position=ca;const {transformed:D,original:da}=await L(a,e,this._worker,b);c.vertexAttributes.normal=da;Q.throwIfAborted(b);b=a.faces;e=c.vertexAttributes.uv;c=c.vertexAttributes.color;a=b.length/3;var q=3*a,l,r=0;n=!1;var v=0;let M=!1;var z=0;let N=!1;
var u=0;let H=0,I=0;r=l=8;l+=12*q;null!=D&&(n=!0,v=l,l+=12*q);null!=e&&(M=!0,z=l,l+=8*q);null!=c&&(N=!0,u=l,l+=4*q);H=l;I=l+=8;l=new ArrayBuffer(l+8);const A=new Uint8Array(l);y(A,0,q);y(A,4,1);q=new Float32Array(l,r);v=null!=D?new Float32Array(l,v):null;z=null!=e?new Float32Array(l,z):null;u=null!=c?new Uint8Array(l,u):null;for(r=0;r<a;++r){const ea=3*r;for(let B=0;3>B;++B){var w=b[ea+B],m=3*w,t=9*r+3*B;q[t]=G[m];q[t+1]=G[m+1];q[t+2]=G[m+2];null!=v&&(v[t]=D[m],v[t+1]=D[m+1],v[t+2]=D[m+2]);null!=
z&&(m=2*w,t=6*r+2*B,z[t]=e[m],z[t+1]=e[m+1]);null!=u&&(w*=4,m=12*r+4*B,u[m]=c[w],u[m+1]=c[w+1],u[m+2]=c[w+2],u[m+3]=c[w+3])}}y(A,H,f);y(A,H+4,f/2**32);y(A,I,0);y(A,I+4,a-1);const {geometryBuffer:fa,geometryDescriptor:ha}={geometryBuffer:l,geometryDescriptor:{isDraco:!1,isLegacy:!0,color:N,normal:n,uv0:M,uvRegion:!1,featureIndex:!0}};return{geometryData:d,attributeDataInfo:{attributeData:{},loadedAttributes:[]},geometryBuffer:fa,geometryDescriptor:ha,requiredTextures:p,textureData:x}};h.loadAttributes=
async function(a,b,d){a=a.numFeatures;d={};for(const {field:{name:f}}of b)d[f]=Array(a);return d};h.loadTextures=async function(a,b,d){d=this._id2Meta.get(a.id);if(null==d||"mesh-component"!==d.type)throw Error(`Failed to load textures for node ${a.id} (unexpected node info)`);a=[];for(const f of b)a.push(d.textureData.get(f.id)||null);return a};h._getMeshData=async function(a){const b=a.version,d=this._memCache.get(b);if(null==d){if(null!=a.loadMeshPromise)return a.loadMeshPromise;const f=async(e,
c)=>{var k=a.unloadedMesh.clone();try{await k.load()}catch(p){c(p)}c=k.memoryUsage;k={loadedMesh:k,projectionPromise:null,normalsTransformPromise:null,usedMemoryInBytes:c};this._memCache.put(b,k,c,P.MIN_PRIORITY);a.loadMeshPromise=null;e(k)};a.loadMeshPromise=new Promise((e,c)=>f(e,c));return a.loadMeshPromise}return d};O._createClass(g,[{key:"indexSR",get:function(){return this._indexSR}},{key:"renderSR",get:function(){return this._renderSR}}]);return g}();E.I3SClientNodeLoader=ia;E.createSphereFromExtent=
K;E.transformNormals=L;Object.defineProperty(E,Symbol.toStringTag,{value:"Module"})});