// All material copyright ESRI, All Rights Reserved, unless otherwise specified.
// See https://js.arcgis.com/4.27/esri/copyright.txt for details.
//>>built
define("exports ../../../../core/arrayUtils ../../../../core/Error ../../../../core/has ../../../../core/Logger ../../../../core/screenUtils ../../../../core/sql ../../../../core/accessorSupport/diffUtils ../../../../layers/support/labelingInfo ../../engine/webgl/enums ../../engine/webgl/Utils ../../engine/webgl/techniques/utils ../../engine/webgl/util/vvFlagUtils ./createSymbolSchema ./support/pixelBuffering ./support/rendererUtils ../support/clusterUtils ../support/util".split(" "),function(t,U,
m,V,W,I,X,Y,J,p,Z,aa,K,n,ba,D,L,M){function B(a,b){let c=0,d=0,e=p.WGLSymbologyType.DEFAULT;if(null!=a){d=ba.getPtMaxVVSize(a,b);"visualVariables"in a&&(c=K.getVVFlags(a.visualVariables||[]),"dot-density"===a.type&&(e=p.WGLSymbologyType.DOT_DENSITY));"heatmap"===a.type&&(e=p.WGLSymbologyType.HEATMAP);if("dictionary"===a.type)return{maxVVSize:d,vvFlags:c,symbologyType:p.WGLSymbologyType.DEFAULT};if("pie-chart"===a.type)return{maxVVSize:d,vvFlags:c,symbologyType:p.WGLSymbologyType.PIE_CHART};if(e!==
p.WGLSymbologyType.DOT_DENSITY&&e!==p.WGLSymbologyType.HEATMAP){var f=a.getSymbols();"backgroundFillSymbol"in a&&a.backgroundFillSymbol&&f.push(a.backgroundFillSymbol);b=a=!0;for(const h of f){if("cim"===h.type||"web-style"===h.type)b=!1;if("simple-fill"===h.type||"picture-fill"===h.type){f=(f=h.outline)&&"none"!==f.style&&"solid"!==f.style;var g="simple-fill"===h.type&&"none"!==h.style&&"solid"!==h.style;g="picture-fill"===h.type||g||f;f&&(a=!1);g&&(b=!1)}}a?e=b?p.WGLSymbologyType.OUTLINE_FILL_SIMPLE:
p.WGLSymbologyType.OUTLINE_FILL:b&&(e=p.WGLSymbologyType.SIMPLE)}}return{vvFlags:c,maxVVSize:d,symbologyType:e}}function N(a,b=!1){try{const d=ca(a,b);var c="heatmap"===a.renderer?.type&&"raster"===D.getSupportedHeatmapRenderer()?{type:"heatmap"}:{type:"symbol"};const e={};d.map(f=>da(e,a,f));return{source:{definitionExpression:X.sqlAnd(a.definitionExpression,null!=a.subtypeCode?`${a.subtypeField} = ${a.subtypeCode}`:null),fields:a.fields.map(f=>f.toJSON()),gdbVersion:a.gdbVersion,historicMoment:a.historicMoment?.getTime(),
outFields:a.availableFields,pixelBuffer:a.pixelBuffer,spatialReference:a.spatialReference.toJSON(),timeExtent:a.timeExtent?.toJSON(),customParameters:a.customParameters},attributes:{fields:{},indexCount:0},processors:d,tileRenderer:c,targets:e}}catch(d){if("ValidationError"===d.fieldName)return u.error(d),null;throw d;}}function da(a,b,c){switch(c.target){case "feature":E(a,F(b),c);break;case "aggregate":if("featureReduction"in b){var d=b.featureReduction;switch(d?.type){case "selection":throw new m("ValidationError",
"Mapview does not support `selection` reduction type",d);case "binning":E(a,F(b),c);ea(a,d,b.fields.map(e=>e.toJSON()),c);break;case "cluster":E(a,F(b),c),fa(a,d,b.fields.map(e=>e.toJSON()),c)}}}}function G(a,b){for(const d in b){const e=b[d];if(e.target===a.name){var c=a.attributes[d];c?.context?(c=c.context,c.mesh=c.mesh||e.context?.mesh,c.storage=c.storage||e.context?.storage):a.attributes[d]=e}}return a}function F(a){return[a.filter?.toJSON()??null,a.featureEffect?.filter?.toJSON()??null]}function E(a,
b,c){a.feature||(a.feature={name:"feature",input:"source",filters:b,attributes:{}});G(a.feature,c.attributes.fields);return a}function O(a,b){const {onStatisticExpression:c,onStatisticField:d,statisticType:e}=a;switch(e){case "min":case "max":case "avg":case "avg_angle":case "sum":case "count":return"esriFieldTypeDouble";case "mode":if(c)return{returnType:b}=c,b?"string"===b?"esriFieldTypeString":"esriFieldTypeDouble":(u.error(new m("ValidationError","Unable to infer type of aggregateField with onStatisticExpression. ReturnType is not defined",
a)),"esriFieldTypeString");b=b.find(f=>f.name===d);return b?b.type:(u.error(new m("ValidationError","Unable to infer type of aggregateField with onStatisticExpression. ReturnType is not defined",a)),"esriFieldTypeString")}}function ea(a,b,c,d){a.aggregate||(a.aggregate={name:"aggregate",type:"bin",filters:null,input:"feature",params:{fixedBinLevel:b.fixedBinLevel,fields:(b.fields??[]).map(e=>({...e.toJSON(),type:O(e,c)}))},attributes:{}});G(a.aggregate,d.attributes.fields);return a}function fa(a,
b,c,d){const e=d.aggregateFields??[],f=new Set;for(const g of e)f.add(g.name);for(const g of b?.fields??[])f.has(g.name)||e.push(g);a.aggregate||(a.aggregate={name:"aggregate",type:"cluster",input:"feature",filters:null,attributes:{},params:{clusterRadius:I.pt2px(b.clusterRadius/2),clusterPixelBuffer:64*Math.ceil(I.pt2px(b.clusterMaxSize)/64),fields:e.map(g=>({...g.toJSON(),type:O(g,c)}))}});G(a.aggregate,d.attributes.fields);return a}function q(a,b){return b.field?v(a,{...b,type:"field",field:b.field}):
b.valueExpression?v(a,{...b,type:"expression",valueExpression:b.valueExpression}):{field:void 0,fieldIndex:void 0}}function v(a,b){switch(b.type){case "expression":var c=b.valueExpression;if(!a.fields[c]){var d=a.indexCount++;a.fields[c]={...b,name:c,fieldIndex:d}}return{fieldIndex:a.fields[c].fieldIndex};case "label-expression":return c=JSON.stringify(b.label),a.fields[c]||(d=a.indexCount++,a.fields[c]={...b,name:c,fieldIndex:d}),{fieldIndex:a.fields[c].fieldIndex};case "field":c=b.field;if("aggregate"===
b.target&&a.fields[c])return{field:c};a.fields[c]={...b,name:c};return{field:c};case "statistic":return a.fields[b.name]={...b},{field:b.name}}}function ca(a,b=!1){const c=[];let d=0;c.push(ha(a,d++,b));return c}function H(a,b,c,d,e,f=!1){a=v(a,{type:"label-expression",target:c,context:{mesh:!0},resultType:"string",label:{labelExpression:b.labelExpression,labelExpressionInfo:b.labelExpressionInfo?{expression:b.labelExpressionInfo.expression}:null,symbol:!!b.symbol,where:b.where}});({fieldIndex:a}=
a);return{...n.createSymbolSchema(b,e,f),fieldIndex:a,target:c,index:d}}function ia(a,b,c){const d="featureReduction"in b&&b.featureReduction;if(!d)return{fields:[],labels:[],matcher:void 0,rendererOverride:void 0};const e=[];let f=null,g=M.toJSONGeometryType(b.geometryType),h=[];var k=null;if(d)switch(d.type){case "selection":return u.error(new m("ValidationError","Mapview does not support `selection` reduction type",d)),{fields:[],labels:[],matcher:void 0,rendererOverride:void 0};case "cluster":case "binning":e.push(...(d.fields??
[])),"cluster"===d.type?g="esriGeometryPoint":"binning"===d.type&&(g="esriGeometryPolygon"),d.renderer&&!d.renderer.authoringInfo?.isAutoGenerated?("cluster"===d.type?{renderer:k}=L.injectDynamicLevelDependentSizeVisualVariable(d.renderer,d,null):k=d.renderer,b=B(d.renderer,d),f=C(a,"aggregate",d.renderer,b,c),h=d&&d.labelsVisible&&d.labelingInfo||[]):"cluster"===d.type&&(k=L.createClusterRenderer(e,b.renderer,d,null,!0),d.symbol&&(b=B(k,d),f={type:"simple",symbol:n.createSymbolSchema(d.symbol,b,
c),symbologyType:b.symbologyType}),h=d&&d.labelsVisible&&d.labelingInfo||[])}P(a,e);return{labels:J.validateLabelingInfo(h,"binning"===d.type?"esriGeometryPolygon":g),matcher:f,fields:e,rendererOverride:k}}function ha(a,b,c=!1){const d={indexCount:0,fields:{}};var e="featureReduction"in a?a.featureReduction??void 0:void 0;b=e?"aggregate":"feature";if("sublayers"in a){var f={type:"subtype",subtypeField:a.subtypeField,renderers:{},symbologyType:p.WGLSymbologyType.DEFAULT},g={type:"subtype",mapping:{},
target:"feature",subtypeField:a.subtypeField},h={type:"subtype",classes:{}},k={type:"symbol",target:"feature",aggregateFields:[],attributes:d,storage:g,mesh:{matcher:f,aggregateMatcher:null,labels:h,sortKey:null}};e=new Set;let w=0;for(const {renderer:r,subtypeCode:x,labelingInfo:ja,labelsVisible:ka}of a.sublayers){a=0;"visualVariables"in r&&r.visualVariables&&(r.visualVariables.some(z=>"rotation"!==z.type)&&u.warnOnce("SubtypeGroupLayer currently only supports rotation visualVariables. All other visualVariable types will be ignored."),
a=K.getVVFlags(r.visualVariables.filter(z=>"size"!==z.type)));const Q={symbologyType:p.WGLSymbologyType.DEFAULT,vvFlags:a,maxVVSize:0};a=C(d,b,r,Q,c);const A=R(d,b,r),S=ka&&ja;if("dictionary"===a.type)throw new m("ValidationError","Dictionary renderer is not supported in subtype layers");if("subtype"===a.type)throw new m("ValidationError","Nested subtype renderers is not supported");if(null!=A&&"subtype"===A.type)throw new m("ValidationError","Nested subtype storage is not supported");if(null!=A&&
null!=A.attributeMapping)throw new m("ValidationError","Non-visual-variable attributes are not supported in subtype layers");if("heatmap"===a.type)throw new m("ValidationError","Heatmaps are not supported in subtype layers");if("pie-chart"===a.type)throw new m("ValidationError","Pie-charts are not supported in subtype layers");if(e.has(x))throw new m("ValidationError","Subtype codes for sublayers must be unique");e.add(x);f.renderers[x]=a;g.mapping[x]=A;S&&(h.classes[x]=S.map(z=>H(d,z,"feature",w++,
Q,c)))}return k}if("heatmap"===a.renderer?.type&&"raster"===D.getSupportedHeatmapRenderer()){const {radius:w,fieldOffset:r,field:x}=a.renderer;return{type:"heatmap",aggregateFields:[],attributes:d,target:b,storage:null,mesh:{radius:w,fieldOffset:r,field:q(d,{target:b,field:x,resultType:"numeric"}).field}}}f=ia(d,a,c);h=M.toJSONGeometryType(a.geometryType);k=f.rendererOverride??a.renderer;const l=B(k,e);g=C(d,b,k,l,c);k=R(d,b,k);e=la(d,a.orderBy,a.renderer,e);let y=0;a=[...J.validateLabelingInfo(a.labelsVisible&&
a.labelingInfo||[],h).map(w=>H(d,w,"feature",y++,l,c)),...f.labels.map(w=>H(d,w,"aggregate",y++,l,c))];return{type:"symbol",target:b,attributes:d,aggregateFields:f.fields,storage:k,mesh:{matcher:g,labels:{type:"simple",classes:a},aggregateMatcher:f.matcher,sortKey:e}}}function la(a,b,c,d){if(null!=d)return null;if(null!=b&&b.length){1<b.length&&u.warn(`Layer rendering currently only supports ordering by 1 orderByInfo, but found ${b.length}. All but the first will be discarded`);b=b[0];c="ascending"===
b.order?"asc":"desc";if(b.field)return{field:b.field,order:c};if(b.valueExpression)return{fieldIndex:v(a,{type:"expression",target:"feature",valueExpression:b.valueExpression,resultType:"numeric"}).fieldIndex,order:c};u.error(new m("ValidationError","Expected to find a field or valueExpression for OrderByInfo",b));return null}return null!=c&&"unique-value"===c.type&&c.orderByClassesEnabled?{byRenderer:!0,order:"asc"}:null}function P(a,b){const c={mesh:!0,storage:!0};for(const d of b){const {name:e,
onStatisticField:f,onStatisticExpression:g,statisticType:h}=d;let k=b=void 0;g?k=v(a,{type:"expression",target:"feature",valueExpression:g.expression,resultType:"numeric"}).fieldIndex:b=v(a,{type:"field",target:"feature",field:f,resultType:"numeric"}).field;v(a,{type:"statistic",target:"aggregate",name:e,context:c,inField:b,inFieldIndex:k,statisticType:h})}}function R(a,b,c){let d;switch(c.type){case "simple":case "class-breaks":case "unique-value":case "dictionary":d={visualVariables:!0,attributes:null};
break;default:d=aa.getTechniqueFromRenderer(c).getStorageSpec(c)}return ma(a,b,d,c)}function ma(a,b,c,d){if(null==c)return null;const {visualVariables:e,attributes:f}=c;c=null;e&&"visualVariables"in d&&(c=na(a,b,d.visualVariables));const g=null!=c?4:0;d=null;null!=f&&(d=f.map((h,k)=>{const {field:l,fieldIndex:y}=q(a,{valueExpression:h.valueExpression,field:h.field,resultType:"numeric",target:b});return{binding:k+g,field:l,fieldIndex:y}}));return{type:"simple",target:b,attributeMapping:d,vvMapping:c}}
function na(a,b,c){if(!c||!c.length)return[];const d={storage:!0};return D.simplifyVisualVariables(c).map(e=>{const f=Z.getVVType(e.type),{field:g,fieldIndex:h}=q(a,{target:b,valueExpression:e.valueExpression,field:e.field,context:d,resultType:"numeric"});switch(e.type){case "size":return"$view.scale"===e.valueExpression?null:{type:"size",binding:f,field:g,fieldIndex:h,normalizationField:q(a,{target:b,field:e.normalizationField,context:d,resultType:"numeric"}).field,valueRepresentation:e.valueRepresentation??
null};case "color":return{type:"color",binding:f,field:g,fieldIndex:h,normalizationField:q(a,{target:b,field:e.normalizationField,context:d,resultType:"numeric"}).field};case "opacity":return{type:"opacity",binding:f,field:g,fieldIndex:h,normalizationField:q(a,{target:b,field:e.normalizationField,context:d,resultType:"numeric"}).field};case "rotation":return{type:"rotation",binding:f,field:g,fieldIndex:h}}}).filter(U.isSome)}function C(a,b,c,d,e=!1){a=a??{indexCount:0,fields:{}};switch(c.type){case "simple":case "dot-density":return oa(a,
c,d,e);case "class-breaks":return pa(a,b,c,d,e);case "unique-value":return qa(a,b,c,d,e);case "dictionary":return{type:"dictionary",config:c.config,fieldMap:c.fieldMap,scaleExpression:c.scaleExpression,url:c.url,symbolOptions:d,symbologyType:d.symbologyType};case "heatmap":return ra(a,c,d,e);case "pie-chart":return sa(a,c,d,e)}}function oa(a,b,c,d=!1){a=b.getSymbols();return{type:"simple",symbol:n.createSymbolSchema(a.length?a[0]:null,c,d),symbologyType:c.symbologyType}}function sa(a,b,c,d=!1){a=
b.getSymbols();b=1<a.length?a[1]:null;return{type:"pie-chart",markerSymbol:n.createSymbolSchema(a[0],c,d),fillSymbol:n.createSymbolSchema(b,c,d),symbologyType:c.symbologyType}}function pa(a,b,c,d,e=!1){const f=c.backgroundFillSymbol,{field:g,fieldIndex:h}=q(a,{target:b,field:c.field,valueExpression:c.valueExpression,resultType:"numeric",context:{mesh:!0,use:"renderer.field"}});b=c.normalizationType;b="log"===b?"esriNormalizeByLog":"percent-of-total"===b?"esriNormalizeByPercentOfTotal":"field"===b?
"esriNormalizeByField":null;const k=c.classBreakInfos.map(l=>({symbol:n.createSymbolSchema(l.symbol,d,e),min:l.minValue,max:l.maxValue})).sort((l,y)=>l.min-y.min);return{type:"interval",attributes:a.fields,field:g,fieldIndex:h,backgroundFillSymbol:n.createSymbolSchema(f,d,e),defaultSymbol:n.createSymbolSchema(c.defaultSymbol,d,e),intervals:k,normalizationField:c.normalizationField,normalizationTotal:c.normalizationTotal,normalizationType:b,isMaxInclusive:c.isMaxInclusive,symbologyType:d.symbologyType}}
function qa(a,b,c,d,e=!1){const f=[],g=c.backgroundFillSymbol;b={target:b,context:{mesh:!0},resultType:"string"};if(c.field&&"string"!==typeof c.field)throw new m("ValidationError","Expected renderer.field to be a string",c);const {field:h,fieldIndex:k}=q(a,{...b,field:c.field,valueExpression:c.valueExpression});for(const l of c.uniqueValueInfos??[])f.push({value:""+l.value,symbol:n.createSymbolSchema(l.symbol,d,e)});return{type:"map",attributes:a.fields,field:h,fieldIndex:k,field2:q(a,{...b,field:c.field2}).field,
field3:q(a,{...b,field:c.field3}).field,fieldDelimiter:c.fieldDelimiter??void 0,backgroundFillSymbol:n.createSymbolSchema(g,d),defaultSymbol:n.createSymbolSchema(c.defaultSymbol,d),map:f,symbologyType:d.symbologyType}}function ra(a,b,c,d=!1){a=b.getSymbols();return{type:"heatmap",symbol:n.createSymbolSchema(a.length?a[0]:null,c,d),symbologyType:c.symbologyType}}const u=W.getLogger("esri.views.2d.layers.features.schemaUtils");let T=null;t.createSymbolSchema=n.createSymbolSchema;t.addAggregateFields=
P;t.createMatcherSchema=C;t.createRendererAttributeSchema=q;t.createSchema=function(a){if(V("esri-2d-update-debug")){const b=N(a,!0);console.debug("Created new schema",b);console.debug("Schema diff",Y.diff(T,b));T=b}return N(a)};t.createSymbolSchemaOptions=B;Object.defineProperty(t,Symbol.toStringTag,{value:"Module"})});