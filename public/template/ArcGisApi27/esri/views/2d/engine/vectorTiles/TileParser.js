// All material copyright ESRI, All Rights Reserved, unless otherwise specified.
// See https://js.arcgis.com/4.27/esri/copyright.txt for details.
//>>built
define("../../../../chunks/_rollupPluginBabelHelpers ../../../../core/pbf ../../../../core/promiseUtils ../../../../geometry/libtess ../../../../geometry/support/TileClipper ./Feature ./IndexMemoryBuffer ./SourceLayerData ./VertexMemoryBuffer ./buckets/CircleBucket ./buckets/FillBucket ./buckets/LineBucket ./buckets/SymbolBucket ./style/StyleDefinition ../../tiling/enums".split(" "),function(z,A,B,C,x,D,u,E,v,F,G,H,I,w,J){return function(){function y(a,c,b,d,g){this._pbfTiles={};this._tileClippers=
{};this._client=b;this._tile=c;if(g){this._styleLayerUIDs=new Set;for(const f of g)this._styleLayerUIDs.add(f)}this._styleRepository=d;this._layers=this._styleRepository?.layers??[];const [h,m,q]=c.tileKey.split("/").map(parseFloat);this._level=h;c=8+Math.max(5*(this._level-14),0);for(const f of Object.keys(a))b=a[f],this._pbfTiles[f]=new A(new Uint8Array(b.protobuff),new DataView(b.protobuff)),b.refKey&&([b]=b.refKey.split("/").map(parseFloat),b=h-b,0<b&&(d=(1<<b)-1,this._tileClippers[f]=new x.TileClipper(b,
m&d,q&d,8,c))),this._tileClippers[f]||(this._tileClippers[f]=new x.SimpleBuilder)}var l=y.prototype;l._canParseStyleLayer=function(a){return!this._styleLayerUIDs||this._styleLayerUIDs.has(a)};l.parse=async function(a){const c=C.loadLibtess(),b=this._initialize(a),{returnedBuckets:d}=b;this._processLayers(b);this._linkReferences(b);this._filterFeatures(b);const g=[],h=new Set,m=(f,r)=>{h.has(f)||(g.push({name:f,repeat:r}),h.add(f))},q={};for(const f of d)f.getResources(f.tileClipper,m,q);if(this._tile.status===
J.TileStatus.INVALID)return[];a=this._fetchResources(g,q,a);return Promise.all([...a,c]).then(()=>this._processFeatures(b.returnedBuckets))};l._initialize=function(a){a=a&&a.signal;const c=this._parseTileData(this._pbfTiles),b=this._layers,d=this._level,g=this._tileClippers,h=new Map;return{signal:a,sourceNameToTileData:c,layers:b,zoom:d,sourceNameToTileClipper:g,sourceNameToUniqueSourceLayerBuckets:{},sourceNameToUniqueSourceLayers:{},returnedBuckets:[],layerIdToBucket:{},referencerUIDToReferencedId:h}};
l._processLayers=function(a){const {sourceNameToTileData:c,layers:b,zoom:d,sourceNameToTileClipper:g,sourceNameToUniqueSourceLayerBuckets:h,sourceNameToUniqueSourceLayers:m,returnedBuckets:q,layerIdToBucket:f,referencerUIDToReferencedId:r}=a;for(a=b.length-1;0<=a;a--){const e=b[a];if(!this._canParseStyleLayer(e.uid)||e.minzoom&&d<Math.floor(e.minzoom)||e.maxzoom&&d>=e.maxzoom||e.type===w.StyleLayerType.BACKGROUND)continue;if(!c[e.source]||!g[e.source])continue;var n=g[e.source];const t=e.sourceLayer;
var p=c[e.source][t];if(p){var k=m[e.source];k||(k=m[e.source]=new Set);k.add(e.sourceLayer);if(e.refLayerId)r.set(e.uid,e.refLayerId);else if(k=this._createBucket(e))k.layerUIDs=[e.uid],k.layerExtent=p.extent,k.tileClipper=n,(n=h[e.source])||(n=h[e.source]={}),(p=n[t])||(p=n[t]=[]),p.push(k),q.push(k),f[e.id]=k}}};l._linkReferences=function(a){const {layerIdToBucket:c,referencerUIDToReferencedId:b}=a;b.forEach((d,g)=>{c[d]&&c[d].layerUIDs.push(g)})};l._filterFeatures=function(a){const {signal:c,
sourceNameToTileData:b,sourceNameToUniqueSourceLayerBuckets:d,sourceNameToUniqueSourceLayers:g}=a;a=10*this._level;const h=10*(this._level+1),m=[],q=[];for(const p of Object.keys(g))g[p].forEach(k=>{m.push(k);q.push(p)});for(let p=0;p<m.length;p++){var f=q[p],r=m[p];if(!b[f]||!d[f])continue;const k=b[f][r];if((f=d[f][r])&&0!==f.length){if(B.isAborted(c))break;for(r=k.getData();r.nextTag(2);){var n=r.getMessage();const e=new D(n,k);n.release();if(n=e.values){const t=n._minzoom;if(t&&t>=h)continue;
if((n=n._maxzoom)&&n<=a)continue}for(const t of f)t.pushFeature(e)}}}};l._fetchResources=function(a,c,b){const d=[],g=this._tile.getWorkerTileHandler();0<a.length&&(a=g.fetchSprites(a,this._client,b),d.push(a));for(const h in c)a=c[h],0<a.size&&(a=g.fetchGlyphs(this._tile.tileKey,h,a,this._client,b),d.push(a));return d};l._processFeatures=function(a){a=a.filter(c=>c.hasFeatures()||this._canParseStyleLayer(c.layer.uid));for(const c of a)c.processFeatures(c.tileClipper);return a};l._parseTileData=function(a){const c=
{};for(const b of Object.keys(a)){const d=a[b],g={};for(;d.next();)switch(d.tag()){case 3:const h=d.getMessage(),m=new E(h);h.release();g[m.name]=m;break;default:d.skip()}c[b]=g}return c};l._createBucket=function(a){switch(a.type){case w.StyleLayerType.BACKGROUND:return null;case w.StyleLayerType.FILL:return this._createFillBucket(a);case w.StyleLayerType.LINE:return this._createLineBucket(a);case w.StyleLayerType.CIRCLE:return this._createCircleBucket(a);case w.StyleLayerType.SYMBOL:return this._createSymbolBucket(a)}};
l._createFillBucket=function(a){return new G(a,this._level,this._tile.getWorkerTileHandler().getSpriteItems(),new v.FillVertexBuffer(a.fillMaterial.getStride()),new u.TriangleIndexBuffer,new v.OutlineVertexBuffer(a.outlineMaterial.getStride()),new u.TriangleIndexBuffer)};l._createLineBucket=function(a){return new H(a,this._level,this._tile.getWorkerTileHandler().getSpriteItems(),new v.LineVertexBuffer(a.lineMaterial.getStride()),new u.TriangleIndexBuffer)};l._createCircleBucket=function(a){return new F(a,
this._level,this._tile.getWorkerTileHandler().getSpriteItems(),new v.CircleVertexBuffer(a.circleMaterial.getStride()),new u.TriangleIndexBuffer)};l._createSymbolBucket=function(a){const c=this._tile;return new I(a,this._level,new v.SymbolVertexBuffer(a.iconMaterial.getStride()),new u.TriangleIndexBuffer,new v.SymbolVertexBuffer(a.textMaterial.getStride()),new u.TriangleIndexBuffer,c.placementEngine,c.getWorkerTileHandler())};return z._createClass(y)}()});