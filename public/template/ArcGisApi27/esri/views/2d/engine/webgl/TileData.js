// All material copyright ESRI, All Rights Reserved, unless otherwise specified.
// See https://js.arcgis.com/4.27/esri/copyright.txt for details.
//>>built
define("exports ../../../../chunks/_rollupPluginBabelHelpers ../../../../core/arrayUtils ./enums ./MemoryRequirements ./TileBufferData ./TileDisplayData ./Utils ./WGLDisplayRecord ./cpuMapped/DisplayRecordReader ./mesh/VertexBuffer ./mesh/VertexVector ./util/Writer".split(" "),function(y,C,z,D,u,x,A,v,B,E,F,G,H){const w=new u,n=new u;u=function(){function l(){this.tileBufferData=this.tileDisplayData=null}var t=l.prototype;t.reshuffle=function(){w.reset();if(this.tileDisplayData){var b=[[],[],[],[],
[]],d=this.tileDisplayData.displayObjects;for(var a of d)for(var e of a.displayRecords)b[e.geometryType].push(e);for(var g of b)for(var f of g)f&&w.needMore(f.geometryType,f.meshData?f.meshData.vertexCount:f.vertexCount,f.meshData?f.meshData.indexData.length:f.indexCount);d=b.length;a=new x;for(e=0;e<d;++e)if(a.geometries[e].indexBuffer=new Uint32Array(Math.round(z.ReallocGrowthFactor*w.indicesFor(e))),f=[],g=this.tileBufferData?.geometries[e].vertexBuffer){for(var c in g)f.push(g[c].stride);f=l._computeVertexAlignment(f);
var h=Math.round(z.ReallocGrowthFactor*w.verticesFor(e));f=l._align(h,f);for(var m in g)h=g[m].stride,a.geometries[e].vertexBuffer[m]={stride:h,data:v.allocateTypedArrayBuffer(f,h)}}n.reset();this.tileDisplayData.displayList?.clear();for(c=0;c<d;++c){m=b[c];for(const k of m){if(k.meshData)k.writeMeshDataToBuffers(n.verticesFor(c),a.geometries[c].vertexBuffer,n.indicesFor(c),a.geometries[c].indexBuffer),k.meshData=null;else if(e=this.tileBufferData?.geometries[c]){m=e.vertexBuffer;e=e.indexBuffer;
g=a.geometries[c].vertexBuffer;f=a.geometries[c].indexBuffer;h=n.verticesFor(c);const p=n.indicesFor(c);v.copyMeshData(h,p,g,f,k,m,e);k.vertexFrom=h;k.indexFrom=p}n.needMore(c,k.vertexCount,k.indexCount)}}var {displayList:q,displayObjects:r}=this.tileDisplayData;if(q)for(const k of r)q.addToList(k.displayRecords);this.tileBufferData=a}};t.getStrides=function(){const b=[],d=this.tileBufferData?.geometries;if(!d)return b;for(let a=0;a<d.length;++a){const e=d[a];b[a]={};for(const g in e.vertexBuffer)b[a][g]=
e.vertexBuffer[g].stride}return b};t.clone=function(){const b=new l;b.tileBufferData=this.tileBufferData?.clone()??null;b.tileDisplayData=this.tileDisplayData?.clone()??null;return b};t._guessSize=function(){const b=this.tileDisplayData?.displayObjects??[],d=Math.min(b.length,4);let a=0;for(let e=0;e<d;e++)a=Math.max(a,b[e].displayRecords.length);return 2*(12*b.length+b.length*a*40)};t.serialize=function(){const b=this.tileBufferData.serialize(),d=this.tileBufferData.getBuffers(),a=this.tileDisplayData.serialize(new H(Int32Array,
this._guessSize())).buffer();d.push(a);return{result:{displayData:a,bufferData:b},transferList:d}};l.fromVertexData=function(b,d){const a={},e=new Map;for(const g of d)e.set(g.id,g);v.forEachGeometryType(g=>{const f=b.data[g];if(null!=f){const h=E.DisplayRecordReader.from(f.records).getCursor();for(;h.next();){var c=h.id;const m=h.materialKey,q=h.indexFrom,r=h.indexCount,k=h.vertexFrom,p=h.vertexCount,I=e.get(c);c=new B(c,g,m);c.indexFrom=q;c.indexCount=r;c.vertexFrom=k;c.vertexCount=p;I.displayRecords.push(c)}a[g]=
F.VertexBuffers.fromVertexData(f,g)}else a[g]=(new G.VertexVectors(g,0,D.WGLSymbologyType.DEFAULT)).intoBuffers()});return l.fromMeshData({displayObjects:d,vertexBuffersMap:a})};l.fromMeshData=function(b){const d=new l,a=new A,e=new x;a.displayObjects=b.displayObjects;for(const g in b.vertexBuffersMap){const f=g,c=b.vertexBuffersMap[f];e.geometries[f].indexBuffer=c.indexBuffer;e.geometries[f].vertexBuffer=c.namedBuffers}d.tileDisplayData=a;d.tileBufferData=e;return d};l.bind=function(b,d){const a=
new l;a.tileDisplayData=b;a.tileBufferData=d;return a};l.create=function(b,d){const a=new l;a.tileDisplayData=new A;a.tileDisplayData.displayObjects=b;const e=[0,0,0,0,0],g=[0,0,0,0,0],f=[[],[],[],[],[]];for(var c of b)for(var h of c.displayRecords)f[h.geometryType].push(h),e[h.geometryType]+=h.meshData.vertexCount,g[h.geometryType]+=h.meshData.indexData.length;b=new x;d=[d.fill||{},d.line||{},d.icon||{},d.text||{},d.label||{}];for(c=0;5>c;c++){h=new Uint32Array(g[c]);var m=d[c],q=e[c];const r={};
for(const k in m){const p={data:v.allocateTypedArrayBuffer(q,m[k]),stride:m[k]};r[k]=p}m=r;B.writeAllMeshDataToBuffers(f[c],m,h);b.geometries[c]={indexBuffer:h,vertexBuffer:m}}a.tileBufferData=b;return a};l._align=function(b,d){const a=b%d;return 0===a?b:b+(d-a)};l._computeVertexAlignment=function(b){let d=!1,a=!1;for(const e of b)2===e%4?d=!0:0!==e%4&&(a=!0);return a?4:d?2:1};return C._createClass(l)}();y.TileData=u;Object.defineProperty(y,Symbol.toStringTag,{value:"Module"})});