// All material copyright ESRI, All Rights Reserved, unless otherwise specified.
// See https://js.arcgis.com/4.27/esri/copyright.txt for details.
//>>built
define("exports ../../chunks/_rollupPluginBabelHelpers ../../core/floatRGBA ../../core/has ../../core/maybe ../../chunks/vec3f64 ./BufferObject ./doublePrecisionUtils ./enums ./FramebufferObject ./TextureDescriptor ./VertexArrayObject ./VertexElementDescriptor ./WebGLDriverTestModule".split(" "),function(p,h,w,x,y,q,z,r,c,A,B,C,D,m){function t(k,g){return k.programCache.acquire(`\n\n  precision highp float;\n\n  attribute vec2 position;\n\n  uniform vec3 u_highA;\n  uniform vec3 u_lowA;\n  uniform vec3 u_highB;\n  uniform vec3 u_lowB;\n\n  varying vec4 v_color;\n\n  ${g?
"#define DOUBLE_PRECISION_REQUIRES_OBFUSCATION":""}\n\n  #ifdef DOUBLE_PRECISION_REQUIRES_OBFUSCATION\n\n  vec3 dpPlusFrc(vec3 a, vec3 b) {\n    return mix(a, a + b, vec3(notEqual(b, vec3(0))));\n  }\n\n  vec3 dpMinusFrc(vec3 a, vec3 b) {\n    return mix(vec3(0), a - b, vec3(notEqual(a, b)));\n  }\n\n  vec3 dpAdd(vec3 hiA, vec3 loA, vec3 hiB, vec3 loB) {\n    vec3 t1 = dpPlusFrc(hiA, hiB);\n    vec3 e = dpMinusFrc(t1, hiA);\n    vec3 t2 = dpMinusFrc(hiB, e) + dpMinusFrc(hiA, dpMinusFrc(t1, e)) + loA + loB;\n    return t1 + t2;\n  }\n\n  #else\n\n  vec3 dpAdd(vec3 hiA, vec3 loA, vec3 hiB, vec3 loB) {\n    vec3 t1 = hiA + hiB;\n    vec3 e = t1 - hiA;\n    vec3 t2 = ((hiB - e) + (hiA - (t1 - e))) + loA + loB;\n    return t1 + t2;\n  }\n\n  #endif\n\n  const float MAX_RGBA_FLOAT =\n    255.0 / 256.0 +\n    255.0 / 256.0 / 256.0 +\n    255.0 / 256.0 / 256.0 / 256.0 +\n    255.0 / 256.0 / 256.0 / 256.0 / 256.0;\n\n  const vec4 FIXED_POINT_FACTORS = vec4(1.0, 256.0, 256.0 * 256.0, 256.0 * 256.0 * 256.0);\n\n  vec4 float2rgba(const float value) {\n    // Make sure value is in the domain we can represent\n    float valueInValidDomain = clamp(value, 0.0, MAX_RGBA_FLOAT);\n\n    // Decompose value in 32bit fixed point parts represented as\n    // uint8 rgba components. Decomposition uses the fractional part after multiplying\n    // by a power of 256 (this removes the bits that are represented in the previous\n    // component) and then converts the fractional part to 8bits.\n    vec4 fixedPointU8 = floor(fract(valueInValidDomain * FIXED_POINT_FACTORS) * 256.0);\n\n    // Convert uint8 values (from 0 to 255) to floating point representation for\n    // the shader\n    const float toU8AsFloat = 1.0 / 255.0;\n\n    return fixedPointU8 * toU8AsFloat;\n  }\n\n  void main() {\n    vec3 val = dpAdd(u_highA, u_lowA, -u_highB, -u_lowB);\n\n    v_color = float2rgba(val.z / 25.0);\n\n    gl_Position = vec4(position * 2.0 - 1.0, 0.0, 1.0);\n  }\n  `,
"\n  precision highp float;\n\n  varying vec4 v_color;\n\n  void main() {\n    gl_FragColor \x3d v_color;\n  }\n  ",new Map([["position",0]]))}m=function(k){function g(b){var a=k.call(this)||this;a._rctx=b;a._program=t(a._rctx,!1);a._obfuscated=t(a._rctx,!0);return a}h._inherits(g,k);var n=g.prototype;n.dispose=function(){h._get(h._getPrototypeOf(g.prototype),"dispose",this).call(this);this._obfuscated=y.disposeMaybe(this._obfuscated)};n._test=function(b){if(x("force-double-precision-obfuscation"))return!0;
if(null==this._obfuscated)return!1;b=this._runProgram(b);const a=this._runProgram(this._obfuscated);return 0!==b&&(0===a||5<b/a)};n._runProgram=function(b){var a=this._rctx;a.resetState();var d=new B.TextureDescriptor(1);d.wrapMode=c.TextureWrapMode.CLAMP_TO_EDGE;d.samplingMode=c.TextureSamplingMode.NEAREST;d=new A.FramebufferObject(a,d);var l=z.BufferObject.createVertex(a,c.Usage.STATIC_DRAW,new Uint16Array([0,0,1,0,0,1,1,1]));l=new C.VertexArrayObject(a,new Map([["position",0]]),{geometry:[new D.VertexElementDescriptor("position",
2,c.DataType.UNSIGNED_SHORT,0,4)]},{geometry:l});const u=q.fromValues(5633261.287538229,2626832.878767164,1434988.0495278358),v=q.fromValues(5633271.46742708,2626873.6381334523,1434963.231608387),e=new Float32Array(6);r.encodeDoubleArray(u,e,3);const f=new Float32Array(6);r.encodeDoubleArray(v,f,3);a.useProgram(b);b.setUniform3f("u_highA",e[0],e[2],e[4]);b.setUniform3f("u_lowA",e[1],e[3],e[5]);b.setUniform3f("u_highB",f[0],f[2],f[4]);b.setUniform3f("u_lowB",f[1],f[3],f[5]);a.bindFramebuffer(d);a.setViewport(0,
0,1,1);a.bindVAO(l);a.drawArrays(c.PrimitiveType.TRIANGLE_STRIP,0,4);b=new Uint8Array(4);d.readPixels(0,0,1,1,c.PixelFormat.RGBA,c.PixelType.UNSIGNED_BYTE,b);l.dispose();d.dispose();a=(u[2]-v[2])/25;b=w.unpackFloatRGBA(b);return Math.abs(a-b)};return h._createClass(g)}(m.WebGLDriverTestModule);p.DoublePrecisionRequiresObfuscation=m;Object.defineProperty(p,Symbol.toStringTag,{value:"Module"})});