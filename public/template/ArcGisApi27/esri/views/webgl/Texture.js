// All material copyright ESRI, All Rights Reserved, unless otherwise specified.
// See https://js.arcgis.com/4.27/esri/copyright.txt for details.
//>>built
define("exports ../../chunks/_rollupPluginBabelHelpers ../../core/Error ../../core/has ../../core/mathUtils ./checkWebGLError ./contextUtils ./enums ./GLObjectType ./TextureDescriptor ./ValidatedTextureDescriptor".split(" "),function(B,L,q,C,H,y,z,g,M,N,O){function D(e,b){(null!=b.width&&0>b.width||null!=b.height&&0>b.height||null!=b.depth&&0>b.depth)&&console.error("Negative dimension parameters are not allowed!");(e=e.type===z.ContextType.WEBGL2)||!b.isImmutable&&!w(b.target)||console.error("Immutable and 3D-like textures are not supported in WebGL1!");
e||null!=b.width&&H.isPowerOfTwo(b.width)&&null!=b.height&&H.isPowerOfTwo(b.height)||("number"===typeof b.wrapMode?b.wrapMode!==g.TextureWrapMode.CLAMP_TO_EDGE&&console.error("Non-power-of-two textures must have a wrap mode of CLAMP_TO_EDGE!"):(b.wrapMode.s!==g.TextureWrapMode.CLAMP_TO_EDGE||b.wrapMode.t!==g.TextureWrapMode.CLAMP_TO_EDGE)&&console.error("Non-power-of-two textures must have a wrap mode of CLAMP_TO_EDGE!"),b.hasMipmap&&console.error("Mipmapping requires power-of-two textures!"))}function I(e,
b){let a=b.samplingMode,d=b.samplingMode;if(a===g.TextureSamplingMode.LINEAR_MIPMAP_NEAREST||a===g.TextureSamplingMode.LINEAR_MIPMAP_LINEAR)a=g.TextureSamplingMode.LINEAR,b.hasMipmap||(d=g.TextureSamplingMode.LINEAR);else if(a===g.TextureSamplingMode.NEAREST_MIPMAP_NEAREST||a===g.TextureSamplingMode.NEAREST_MIPMAP_LINEAR)a=g.TextureSamplingMode.NEAREST,b.hasMipmap||(d=g.TextureSamplingMode.NEAREST);e.texParameteri(b.target,e.TEXTURE_MAG_FILTER,a);e.texParameteri(b.target,e.TEXTURE_MIN_FILTER,d)}function J(e,
b){"number"===typeof b.wrapMode?(e.texParameteri(b.target,e.TEXTURE_WRAP_S,b.wrapMode),e.texParameteri(b.target,e.TEXTURE_WRAP_T,b.wrapMode)):(e.texParameteri(b.target,e.TEXTURE_WRAP_S,b.wrapMode.s),e.texParameteri(b.target,e.TEXTURE_WRAP_T,b.wrapMode.t))}function P(e,b){const a=e.capabilities.textureFilterAnisotropic;a&&e.gl.texParameterf(b.target,a.TEXTURE_MAX_ANISOTROPY,b.maxAnisotropy??1)}function A(e){return null!=e&&"type"in e&&"compressed"===e.type}function E(e){return null!=e&&!A(e)&&!(null!=
e&&"byteLength"in e)}function w(e){return e===g.TextureType.TEXTURE_3D||e===g.TextureType.TEXTURE_2D_ARRAY}function K(e,b,a,d=1){b=Math.max(b,a);e===g.TextureType.TEXTURE_3D&&(b=Math.max(b,d));return Math.round(Math.log(b)/Math.LN2)+1}C=function(){function e(a,d=null,f=null){this.type=M.GLObjectType.Texture;this._glName=null;this._wasImmutablyAllocated=this._wrapModeDirty=this._samplingModeDirty=!1;if("context"in a)this._descriptor=a,f=d;else{a=O.ValidatedTextureDescriptor.validate(a,d);if(!a)throw new q("Texture descriptor invalid");
this._descriptor=a}this._descriptor.context.instanceCounter.increment(g.ResourceType.Texture,this);if(this._descriptor.context.type!==z.ContextType.WEBGL2&&(this._descriptor.isImmutable&&(this._descriptor.isImmutable=!1),w(this._descriptor.target)))throw new q("3D and array textures are not supported in WebGL1");this._descriptor.target===g.TextureType.TEXTURE_CUBE_MAP?this._setDataCubeMap(f):this.setData(f)}var b=e.prototype;b.dispose=function(){this._descriptor.context.gl&&this._glName&&(this._descriptor.context.unbindTexture(this),
this._descriptor.context.gl.deleteTexture(this._glName),this._glName=null,this._descriptor.context.instanceCounter.decrement(g.ResourceType.Texture,this))};b.release=function(){this.dispose()};b.resize=function(a,d){const f=this._descriptor;if(f.width!==a||f.height!==d){if(this._wasImmutablyAllocated)throw new q("Immutable textures can't be resized!");f.width=a;f.height=d;this._descriptor.target===g.TextureType.TEXTURE_CUBE_MAP?this._setDataCubeMap(null):this.setData(null)}};b._setDataCubeMap=function(a=
null){for(let d=g.TextureType.TEXTURE_CUBE_MAP_POSITIVE_X;d<=g.TextureType.TEXTURE_CUBE_MAP_NEGATIVE_Z;d++)this._setData(a,d)};b.setData=function(a){this._setData(a)};b._setData=function(a,d){if(this._descriptor.context&&this._descriptor.context.gl){var f=this._descriptor.context.gl;y.checkWebGLError(f);this._glName||(this._glName=f.createTexture());void 0===a&&(a=null);var c=this._descriptor,h=d??c.target,k=w(h);null===a&&(c.width=c.width||4,c.height=c.height||4,k&&(c.depth=c.depth??1));d=this._descriptor.context.bindTexture(this,
e.TEXTURE_UNIT_FOR_UPDATES);this._descriptor.context.setActiveTexture(e.TEXTURE_UNIT_FOR_UPDATES);D(this._descriptor.context,c);this._configurePixelStorage();y.checkWebGLError(f);var l=this._deriveInternalFormat();if(E(a)){let m=a.width,n=a.height;a instanceof HTMLVideoElement&&(m=a.videoWidth,n=a.videoHeight);c.isImmutable&&!this._wasImmutablyAllocated&&this._texStorage(h,l,c.hasMipmap,m,n,1);this._texImage(h,0,l,m,n,1,a);y.checkWebGLError(f);c.hasMipmap&&this.generateMipmap();c.width||(c.width=
m);c.height||(c.height=n);k&&!c.depth&&(c.depth=1)}else{const {width:m,height:n,depth:p}=c;if(null==m||null==n)throw new q("Width and height must be specified!");if(k&&null==p)throw new q("Depth must be specified!");c.isImmutable&&!this._wasImmutablyAllocated&&this._texStorage(h,l,c.hasMipmap,m,n,p);if(A(a)){const r=a.levels;a=K(h,m,n,p);k=Math.min(a-1,r.length-1);null!=this._descriptor.context.gl2?f.texParameteri(c.target,this._descriptor.context.gl2.TEXTURE_MAX_LEVEL,k):c.hasMipmap=c.hasMipmap&&
a===r.length;if(!(l in g.CompressedTextureFormat))throw new q("Attempting to use compressed data with an uncompressed format!");this._forEachMipmapLevel((t,v,u,x)=>{this._compressedTexImage(h,t,l,v,u,x,r[Math.min(t,r.length-1)])},k)}else this._texImage(h,0,l,m,n,p,a),y.checkWebGLError(f),c.hasMipmap&&this.generateMipmap()}I(f,this._descriptor);J(f,this._descriptor);P(this._descriptor.context,this._descriptor);y.checkWebGLError(f);this._descriptor.context.bindTexture(d,e.TEXTURE_UNIT_FOR_UPDATES)}};
b.updateData=function(a,d,f,c,h,k,l=0){k||console.error("An attempt to use uninitialized data!");this._glName||console.error("An attempt to update uninitialized texture!");const m=this._descriptor.context.gl,n=this._descriptor.context.gl2,p=this._descriptor,r=this._deriveInternalFormat(),{pixelFormat:t,dataType:v,target:u,isImmutable:x}=p;if(x&&!this._wasImmutablyAllocated)throw new q("Cannot update immutable texture before allocation!");const F=this._descriptor.context.bindTexture(this,e.TEXTURE_UNIT_FOR_UPDATES,
!0);(0>d||0>f||c>p.width||h>p.height||d+c>p.width||f+h>p.height)&&console.error("An attempt to update out of bounds of the texture!");this._configurePixelStorage();if(l){if(!n){console.error("Webgl2 must be enabled to use dataRowOffset!");return}m.pixelStorei(n.UNPACK_SKIP_ROWS,l)}E(k)?n?n.texSubImage2D(u,a,d,f,c,h,t,v,k):m.texSubImage2D(u,a,d,f,t,v,k):A(k)?m.compressedTexSubImage2D(u,a,d,f,c,h,r,k.levels[a]):m.texSubImage2D(u,a,d,f,c,h,t,v,k);if(l){if(!n){console.error("Webgl2 must be enabled to use dataRowOffset!");
return}m.pixelStorei(n.UNPACK_SKIP_ROWS,0)}this._descriptor.context.bindTexture(F,e.TEXTURE_UNIT_FOR_UPDATES)};b.updateData3D=function(a,d,f,c,h,k,l,m){m||console.error("An attempt to use uninitialized data!");this._glName||console.error("An attempt to update uninitialized texture!");const n=this._descriptor.context.gl2;if(null==n)throw new q("3D textures are not supported in WebGL1");const p=this._descriptor,r=this._deriveInternalFormat(),{pixelFormat:t,dataType:v,isImmutable:u,target:x}=p;if(u&&
!this._wasImmutablyAllocated)throw new q("Cannot update immutable texture before allocation!");w(x)||console.warn("Attempting to set 3D texture data on a non-3D texture");const F=this._descriptor.context.bindTexture(this,e.TEXTURE_UNIT_FOR_UPDATES);this._descriptor.context.setActiveTexture(e.TEXTURE_UNIT_FOR_UPDATES);(0>d||0>f||0>c||h>p.width||k>p.height||l>p.depth||d+h>p.width||f+k>p.height||c+l>p.depth)&&console.error("An attempt to update out of bounds of the texture!");this._configurePixelStorage();
A(m)?(m=m.levels[a],n.compressedTexSubImage3D(x,a,d,f,c,h,k,l,r,m)):n.texSubImage3D(x,a,d,f,c,h,k,l,t,v,m);this._descriptor.context.bindTexture(F,e.TEXTURE_UNIT_FOR_UPDATES)};b.generateMipmap=function(){const a=this._descriptor;if(!a.hasMipmap){if(this._wasImmutablyAllocated)throw new q("Cannot add mipmaps to immutable texture after allocation");this._samplingModeDirty=a.hasMipmap=!0;D(this._descriptor.context,a)}a.samplingMode===g.TextureSamplingMode.LINEAR?(this._samplingModeDirty=!0,a.samplingMode=
g.TextureSamplingMode.LINEAR_MIPMAP_NEAREST):a.samplingMode===g.TextureSamplingMode.NEAREST&&(this._samplingModeDirty=!0,a.samplingMode=g.TextureSamplingMode.NEAREST_MIPMAP_NEAREST);const d=this._descriptor.context.bindTexture(this,e.TEXTURE_UNIT_FOR_UPDATES);this._descriptor.context.setActiveTexture(e.TEXTURE_UNIT_FOR_UPDATES);this._descriptor.context.gl.generateMipmap(a.target);this._descriptor.context.bindTexture(d,e.TEXTURE_UNIT_FOR_UPDATES)};b.setSamplingMode=function(a){a!==this._descriptor.samplingMode&&
(this._descriptor.samplingMode=a,this._samplingModeDirty=!0)};b.setWrapMode=function(a){a!==this._descriptor.wrapMode&&(this._descriptor.wrapMode=a,D(this._descriptor.context,this._descriptor),this._wrapModeDirty=!0)};b.applyChanges=function(){const a=this._descriptor.context.gl,d=this._descriptor;this._samplingModeDirty&&(I(a,d),this._samplingModeDirty=!1);this._wrapModeDirty&&(J(a,d),this._wrapModeDirty=!1)};b._deriveInternalFormat=function(){if(this._descriptor.context.type===z.ContextType.WEBGL1)return this._descriptor.internalFormat=
this._descriptor.pixelFormat;if(null!=this._descriptor.internalFormat)return this._descriptor.internalFormat===g.PixelFormat.DEPTH_STENCIL&&(this._descriptor.internalFormat=g.PixelFormat.DEPTH24_STENCIL8),this._descriptor.internalFormat;switch(this._descriptor.dataType){case g.PixelType.FLOAT:switch(this._descriptor.pixelFormat){case g.PixelFormat.RGBA:return this._descriptor.internalFormat=g.SizedPixelFormat.RGBA32F;case g.PixelFormat.RGB:return this._descriptor.internalFormat=g.SizedPixelFormat.RGB32F;
default:throw new q("Unable to derive format");}case g.PixelType.UNSIGNED_BYTE:switch(this._descriptor.pixelFormat){case g.PixelFormat.RGBA:return this._descriptor.internalFormat=g.SizedPixelFormat.RGBA8;case g.PixelFormat.RGB:return this._descriptor.internalFormat=g.SizedPixelFormat.RGB8}}return this._descriptor.internalFormat=this._descriptor.pixelFormat===g.PixelFormat.DEPTH_STENCIL?g.PixelFormat.DEPTH24_STENCIL8:this._descriptor.pixelFormat};b._configurePixelStorage=function(){const a=this._descriptor.context.gl,
{unpackAlignment:d,flipped:f,preMultiplyAlpha:c}=this._descriptor;a.pixelStorei(a.UNPACK_ALIGNMENT,d);a.pixelStorei(a.UNPACK_FLIP_Y_WEBGL,f?1:0);a.pixelStorei(a.UNPACK_PREMULTIPLY_ALPHA_WEBGL,c?1:0)};b._texStorage=function(a,d,f,c,h,k){const l=this._descriptor.context.gl2;if(null==l)throw new q("Immutable textures are not supported in WebGL1");if(!(d in g.SizedPixelFormat))throw new q("Immutable textures must have a sized internal format");if(this._descriptor.isImmutable){f=f?K(a,c,h,k):1;if(w(a)){if(null==
k)throw new q("Missing depth dimension for 3D texture upload");l.texStorage3D(a,f,d,c,h,k)}else l.texStorage2D(a,f,d,c,h);this._wasImmutablyAllocated=!0}};b._texImage=function(a,d,f,c,h,k,l){const m=this._descriptor.context.gl,n=w(a),{isImmutable:p,pixelFormat:r,dataType:t}=this._descriptor,v=this._descriptor.context.type===z.ContextType.WEBGL2,u=v?m:null;if(!v&&E(l))m.texImage2D(a,0,f,r,t,l);else if(p){if(null!=l)if(n){if(null==k)throw new q("Missing depth dimension for 3D texture upload");u.texSubImage3D(a,
d,0,0,0,c,h,k,r,t,l)}else m.texSubImage2D(a,d,0,0,c,h,r,t,l)}else if(n){if(null==k)throw new q("Missing depth dimension for 3D texture upload");u.texImage3D(a,d,f,c,h,k,0,r,t,l)}else m.texImage2D(a,d,f,c,h,0,r,t,l)};b._compressedTexImage=function(a,d,f,c,h,k,l){const m=this._descriptor.context.gl;let n=null;const p=w(a),r=this._descriptor.isImmutable;if(p){if(this._descriptor.context.type!==z.ContextType.WEBGL2)throw new q("3D textures are not supported in WebGL1");n=m}if(r){if(null!=l)if(p){if(null==
k)throw new q("Missing depth dimension for 3D texture upload");n.compressedTexSubImage3D(a,d,0,0,0,c,h,k,f,l)}else m.compressedTexSubImage2D(a,d,0,0,c,h,f,l)}else if(p){if(null==k)throw new q("Missing depth dimension for 3D texture upload");n.compressedTexImage3D(a,d,f,c,h,k,0,l)}else m.compressedTexImage2D(a,d,f,c,h,0,l)};b._forEachMipmapLevel=function(a,d=Infinity){let {width:f,height:c,depth:h,hasMipmap:k,target:l}=this._descriptor;const m=l===g.TextureType.TEXTURE_3D;if(null==f||null==c||m&&null==
h)throw new q("Missing texture dimensions for mipmap calculation");for(let n=0;;++n){a(n,f,c,h);if(!k||1===f&&1===c&&(!m||1===h)||n>=d)break;f=Math.max(1,f>>1);c=Math.max(1,c>>1);m&&(h=Math.max(1,h>>1))}};L._createClass(e,[{key:"glName",get:function(){return this._glName}},{key:"descriptor",get:function(){return this._descriptor}},{key:"gpuMemoryUsage",get:function(){G.delete(this);return N.estimateMemory(this._descriptor)}},{key:"isDirty",get:function(){return this._samplingModeDirty||this._wrapModeDirty}}]);
return e}();C.TEXTURE_UNIT_FOR_UPDATES=0;const G=new Map;B.Texture=C;B.clearUnestimatedTextures=function(){const e=[];G.forEach((b,a)=>e.push([a.gpuMemoryUsage,b]));G.clear();e.sort((b,a)=>a[0]-b[0]);return e.reduce((b,a)=>`${b}\n\n${Math.round(a[0]/1024)}KB: ${a[1]}`,"")};Object.defineProperty(B,Symbol.toStringTag,{value:"Module"})});