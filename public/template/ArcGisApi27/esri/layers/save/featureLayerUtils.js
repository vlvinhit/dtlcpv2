// All material copyright ESRI, All Rights Reserved, unless otherwise specified.
// See https://js.arcgis.com/4.27/esri/copyright.txt for details.
//>>built
define("exports ../../core/arrayUtils ../../core/Error ../../core/Logger ../../core/promiseUtils ../../core/accessorSupport/originUtils ../FeatureLayer ../support/arcgisLayerUrl ../support/fetchService ../support/layerUtils ../../portal/Portal ../../portal/PortalItem ../../portal/support/jsonContext ../../portal/support/portalItemUtils".split(" "),function(n,G,k,r,p,t,H,I,J,y,K,L,u,h){function m(a,b){return`Layer (title: ${a.title}, id: ${a.id}) of type '${a.declaredClass}' ${b}`}function z(a,b){if("Feature Service"!==
b.type)throw new k("feature-layer:portal-item-wrong-type",m(a,'should have portal item of type "Feature Service"'));}async function A(a){await a.load();if(y.isFeatureCollectionLayer(a))throw new k("feature-layer:save",m(a,"using an in-memory source cannot be saved to a portal item"));}function M(a,b){a=(a.messages??[]).filter(({type:c})=>"error"===c).map(({name:c,message:d,details:e})=>new k(c,d,e));b?.ignoreUnsupported&&(a=a.filter(({name:c})=>"layer:unsupported"!==c&&"symbol:unsupported"!==c&&"symbol-layer:unsupported"!==
c&&"property:unsupported"!==c&&"url:unsupported"!==c));if(0<a.length)throw new k("feature-layer:save","Failed to save feature layer due to unsupported or invalid content. See 'details.errors' for more detailed information",{errors:a});}async function v(a,b,c){"beforeSave"in a&&"function"===typeof a.beforeSave&&await a.beforeSave();a=a.write({},b);M(b,c);return a}function B(a){const {layer:b,layerJSON:c}=a;return b.isTable?{layers:[],tables:[c]}:{layers:[c],tables:[]}}function w(a){h.addTypeKeyword(a,
h.TypeKeyword.JSAPI);a.typeKeywords&&(a.typeKeywords=a.typeKeywords.filter((b,c,d)=>d.indexOf(b)===c))}async function C(a,b){return/\/\d+\/?$/.test(a.url??"")?B(b[0]):N(a,b)}async function N(a,b){const {layer:{url:c,customParameters:d,apiKey:e}}=b[0];(a=await a.fetchData("json"))&&null!=a.layers&&null!=a.tables||(a=await O(a,{url:c??"",customParameters:d,apiKey:e},b.map(f=>f.layer.layerId)));for(const f of b)D(f.layer,f.layerJSON,a);return a}async function O(a,b,c){var d,e;a||(a={});(d=a).layers||
(d.layers=[]);(e=a).tables||(e.tables=[]);const {url:f,customParameters:g,apiKey:l}=b,{serviceJSON:q,layersJSON:x}=await J.fetchFeatureService(f,{customParameters:g,apiKey:l});b=E(a.layers,q.layers,c);c=E(a.tables,q.tables,c);a.layers=b.itemResources;a.tables=c.itemResources;c=[...b.added,...c.added];b=x?[...x.layers,...x.tables]:[];await P(a,c,f,b);return a}function E(a,b,c){const d=G.difference(a,b,(e,f)=>e.id===f.id);a=a.filter(e=>!d.removed.some(f=>f.id===e.id));b=d.added.map(({id:e})=>({id:e}));
b.forEach(({id:e})=>{a.push({id:e})});return{itemResources:a,added:b.filter(({id:e})=>!c.includes(e))}}async function P(a,b,c,d){b=b.map(({id:e})=>new H({url:c,layerId:e,sourceJSON:d.find(({id:f})=>f===e)}));await p.eachAlways(b.map(e=>e.load()));b.forEach(e=>{const {layerId:f,loaded:g,defaultPopupTemplate:l}=e;if(g&&null!=l){var q={id:f,popupInfo:l.toJSON()};D(e,q,a)}})}function D(a,b,c){a.isTable?F(c.tables,b):F(c.layers,b)}function F(a,b){if(a){var c=a.findIndex(({id:d})=>d===b.id);-1===c?a.push(b):
a[c]=b}}function Q(a){const {portalItem:b}=a;return y.isFeatureServiceLayer(a)&&!a.dynamicDataSource&&!!b?.loaded&&"Feature Service"===b.type}async function R(a){if(!a?.length)throw new k("feature-layer-utils-saveall:missing-parameters","'layers' array should contain at least one feature layer");await Promise.all(a.map(c=>c.load()));for(var b of a)if(!Q(b))throw new k("feature-layer-utils-saveall:invalid-parameters",`'layers' array should only contain layers or tables in a feature service loaded from 'Feature Service' item. ${m(b,
"does not conform")}`,{layer:b});b=a.map(c=>c.portalItem.id);if(1<(new Set(b)).size)throw new k("feature-layer-utils-saveall:invalid-parameters","All layers in the 'layers' array should be loaded from the same portal item");a=a.map(c=>c.layerId);if((new Set(a)).size!==a.length)throw new k("feature-layer-utils-saveall:invalid-parameters","'layers' array should contain only one instance each of layer or table in a feature service");}async function S(a,b){const {url:c,layerId:d,title:e,fullExtent:f,
isTable:g}=a;a=I.parse(c);b.url=null!=a&&"FeatureServer"===a.serverType?c:`${c}/${d}`;b.title||(b.title=e);b.extent=null;g||null==f||(b.extent=await h.getWGS84ExtentForItem(f));h.removeTypeKeyword(b,h.TypeKeyword.METADATA);h.removeTypeKeyword(b,h.TypeKeyword.MULTI_LAYER);h.addTypeKeyword(b,h.TypeKeyword.SINGLE_LAYER);g&&h.addTypeKeyword(b,h.TypeKeyword.TABLE);w(b)}async function T(a,b,c){const d=a.portal;await d?.signIn();await d?.user?.addItem({item:a,data:b,folder:c?.folder})}const U=r.getLogger("esri.layers.FeatureLayer");
r=p.debounce(async function(a,b){await A(a);var c=a.portalItem;if(!c)throw U.error("save: requires the portalItem property to be set"),new k("feature-layer:portal-item-not-set",m(a,"requires the portalItem property to be set"));if(!c.loaded)throw new k("feature-layer:portal-item-not-loaded",m(a,"cannot be saved to a portal item that does not exist or is inaccessible"));z(a,c);c=a.portalItem;const d=u.createForItemWrite(c);b=await v(a,d,b);a=await C(c,[{layer:a,layerJSON:b}]);w(c);await c.update({data:a});
t.updateOrigins(d);return c});const V=p.debounce(async(a,b)=>{await R(a);const c=a[0].portalItem,d=u.createForItemWrite(c),e=await Promise.all(a.map(g=>v(g,d,b))),f=await C(c,a.map((g,l)=>({layer:g,layerJSON:e[l]})));w(c);await c.update({data:f});await Promise.all(a.slice(1).map(g=>g.portalItem.reload()));t.updateOrigins(d);return c.clone()}),W=p.debounce(async function(a,b,c){await A(a);var d,e;b=L.from(b);b.id&&(b=b.clone(),b.id=null);(d=b).type??(d.type="Feature Service");(e=b).portal??(e.portal=
K.getDefault());z(a,b);d=b;e=u.createForItemWrite(d);b=await v(a,e,c);b=B({layer:a,layerJSON:b});await S(a,d);await T(d,b,c);a.portalItem=d;t.updateOrigins(e);return d});n.save=r;n.saveAll=V;n.saveAs=W;Object.defineProperty(n,Symbol.toStringTag,{value:"Module"})});