// All material copyright ESRI, All Rights Reserved, unless otherwise specified.
// See https://js.arcgis.com/4.27/esri/copyright.txt for details.
//>>built
define("exports ../../chunks/_rollupPluginBabelHelpers ../../core/asyncUtils ../../core/Error ../../core/maybe ../../core/promiseUtils ../../core/unitUtils ../../geometry/Multipoint ../../geometry/Point ../../geometry/Polyline ../../geometry/projection ../../geometry/support/aaBoundingRect ./ElevationSampler ./ElevationTile ./TileKey".split(" "),function(C,w,O,u,I,y,F,G,J,P,z,D,K,L,M){function H(m,h,a=0){const b=A(m,h);h=b.length-1;if(0<a){m=F.getMetersPerUnitForSR(m.spatialReference);const c=a/m;
a=b.findIndex(d=>d.resolution<c);0===a?h=0:0<a&&(h=a-1)}return h}function A(m,h){m=m.lods;if(null!=h?.tileInfo){const {effectiveMinLOD:a,effectiveMaxLOD:b}=h;return m.filter(c=>c.level>=a&&c.level<=b)}return m}let S=function(){function m(){}var h=m.prototype;h.queryAll=async function(a,b,c){a=c&&c.ignoreInvisibleLayers?a.filter(e=>e.visible):a.slice();if(!a.length)throw new u("elevation-query:invalid-layer","Elevation queries require at least one elevation layer to fetch tiles from");var d=B.fromGeometry(b);
b=!1;c&&c.returnSampleInfo||(b=!0);c={...E,...c,returnSampleInfo:!0};d=await this.query(a[a.length-1],d,c);a=await this._queryAllContinue(a,d,c);a.geometry=a.geometry.export();b&&delete a.sampleInfo;return a};h.query=async function(a,b,c){if(!a)throw new u("elevation-query:invalid-layer","Elevation queries require an elevation layer to fetch tiles from");if(!b||!(b instanceof B)&&"point"!==b.type&&"multipoint"!==b.type&&"polyline"!==b.type)throw new u("elevation-query:invalid-geometry","Only point, polyline and multipoint geometries can be used to query elevation");
var d={...E,...c};c=new Q(a,b.spatialReference,d);d=d.signal;await a.load({signal:d});await this._createGeometryDescriptor(c,b,d);await this._selectTiles(c,d);await this._populateElevationTiles(c,d);this._sampleGeometryWithElevation(c);return this._createQueryResult(c,d)};h.createSampler=async function(a,b,c){if(!a)throw new u("elevation-query:invalid-layer","Elevation queries require an elevation layer to fetch tiles from");if(!b||"extent"!==b.type)throw new u("elevation-query:invalid-extent","Invalid or undefined extent");
return this._createSampler(a,b,{...E,...c})};h.createSamplerAll=async function(a,b,c){a=c&&c.ignoreInvisibleLayers?a.filter(e=>e.visible):a.slice();if(!a.length)throw new u("elevation-query:invalid-layer","Elevation queries require at least one elevation layer to fetch tiles from");if(!b||"extent"!==b.type)throw new u("elevation-query:invalid-extent","Invalid or undefined extent");c={...E,...c,returnSampleInfo:!0};const d=await this._createSampler(a[a.length-1],b,c);return this._createSamplerAllContinue(a,
b,d,c)};h._createSampler=async function(a,b,c,d){const e=c.signal;await a.load({signal:e});const f=b.spatialReference,g=a.tileInfo.spatialReference;f.equals(g)||(await z.initializeProjection([{source:f,dest:g}],{signal:e}),b=z.project(b,g));a=new R(a,b,c,d);await this._selectTiles(a,e);await this._populateElevationTiles(a,e);return new K.MultiTileElevationSampler(a.elevationTiles,a.layer.tileInfo,a.options.noDataValue)};h._createSamplerAllContinue=async function(a,b,c,d){a.pop();if(!a.length)return c;
var e=c.samplers.map(f=>D.fromExtent(f.extent));e=await this._createSampler(a[a.length-1],b,d,e);if(0===e.samplers.length)return c;c=c.samplers.concat(e.samplers);c=new K.MultiTileElevationSampler(c,d.noDataValue);return this._createSamplerAllContinue(a,b,c,d)};h._queryAllContinue=async function(a,b,c){var d=a.pop();const e=b.geometry.coordinates,f=b.sampleInfo;I.assertIsSome(f);const g=[],l=[];for(let q=0;q<e.length;q++){const k=f[q];0<=k.demResolution?k.source||(k.source=d):a.length&&(g.push(e[q]),
l.push(q))}if(!a.length||0===g.length)return b;d=b.geometry.clone(g);const p=await this.query(a[a.length-1],d,c),x=p.sampleInfo;if(!x)throw Error("no sampleInfo");l.forEach((q,k)=>{e[q].z=p.geometry.coordinates[k].z;f[q].demResolution=x[k].demResolution});return this._queryAllContinue(a,b,c)};h._createQueryResult=async function(a,b){b=await a.geometry.project(a.outSpatialReference,b);I.assertIsSome(b);b={geometry:b.export(),noDataValue:a.options.noDataValue};a.options.returnSampleInfo&&(b.sampleInfo=
this._extractSampleInfo(a));a.geometry.coordinates.forEach(c=>{c.tile=null;c.elevationTile=null});return b};h._createGeometryDescriptor=async function(a,b,c){const d=a.layer.tileInfo.spatialReference;b instanceof B?c=await b.project(d,c):(await z.initializeProjection([{source:b.spatialReference,dest:d}],{signal:c}),c=z.project(b,d));if(!c)throw new u("elevation-query:spatial-reference-mismatch",`Cannot query elevation in '${b.spatialReference.wkid}' on an elevation service in '${d.wkid}'`);a.geometry=
B.fromGeometry(c)};h._selectTiles=async function(a,b){"geometry"===a.type&&this._preselectOutsideLayerExtent(a);const c=a.options.demResolution;if("number"===typeof c)this._selectTilesClosestResolution(a,c);else if("finest-contiguous"===c)await this._selectTilesFinestContiguous(a,b);else if("auto"===c)await this._selectTilesAuto(a,b);else throw new u("elevation-query:invalid-dem-resolution",`Invalid dem resolution value '${c}', expected a number, "finest-contiguous" or "auto"`);};h._preselectOutsideLayerExtent=
function(a){if(null!=a.layer.fullExtent){var b=new L.ElevationTile(null);b.sample=()=>a.options.noDataValue;a.outsideExtentTile=b;var c=a.layer.fullExtent;a.geometry.coordinates.forEach(d=>{const e=d.x,f=d.y;if(e<c.xmin||e>c.xmax||f<c.ymin||f>c.ymax)d.elevationTile=b})}};h._selectTilesClosestResolution=function(a,b){b=this._findNearestDemResolutionLODIndex(a,b);a.selectTilesAtLOD(b)};h._findNearestDemResolutionLODIndex=function(a,b){const {tileInfo:c,tilemapCache:d}=a.layer;a=F.getMetersPerUnitForSR(c.spatialReference);
b/=a;a=A(c,d);let e=a[0],f=0;for(let g=1;g<a.length;g++){const l=a[g];Math.abs(l.resolution-b)<Math.abs(e.resolution-b)&&(e=l,f=g)}return f};h._selectTilesFinestContiguous=async function(a,b){const {tileInfo:c,tilemapCache:d}=a.layer,e=H(c,d,a.options.minDemResolution);await this._selectTilesFinestContiguousAt(a,e,b)};h._selectTilesFinestContiguousAt=async function(a,b,c){var d=a.layer;a.selectTilesAtLOD(b);if(!(0>b)){var e=d.tilemapCache;d=a.getTilesToFetch();try{if(e&&null==e?.tileInfo)await y.whenOrAbort(Promise.all(d.map(f=>
e.fetchAvailability(f.level,f.row,f.col,{signal:c}))),c);else if(await this._populateElevationTiles(a,c),!a.allElevationTilesFetched())throw a.clearElevationTiles(),new u("elevation-query:has-unavailable-tiles");}catch(f){y.throwIfAbortError(f),await this._selectTilesFinestContiguousAt(a,b-1,c)}}};h._populateElevationTiles=async function(a,b){var c=a.getTilesToFetch();const d={},e=a.options.cache,f=a.options.noDataValue;c=c.map(async g=>{if(null!=g.id){var l=`${a.layer.uid}:${g.id}:${f}`,p=null!=
e?e.get(l):null;p=null!=p?p:await a.layer.fetchTile(g.level,g.row,g.col,{noDataValue:f,signal:b});null!=e&&e.put(l,p);d[g.id]=new L.ElevationTile(g,p)}});await y.whenOrAbort(y.eachAlways(c),b);a.populateElevationTiles(d)};h._selectTilesAuto=async function(a,b){this._selectTilesAutoFinest(a);this._reduceTilesForMaximumRequests(a);const c=a.layer.tilemapCache;if(!c||null!=c?.tileInfo)return this._selectTilesAutoPrefetchUpsample(a,b);const d={},e=a.getTilesToFetch().map(async f=>{const g=new M.TileKey(null,
0,0,0,D.create()),l=await O.result(c.fetchAvailabilityUpsample(f.level,f.row,f.col,g,{signal:b}));!1===l.ok?y.throwIfAbortError(l.error):null!=f.id&&(d[f.id]=g)});await y.whenOrAbort(Promise.all(e),b);a.remapTiles(d)};h._reduceTilesForMaximumRequests=function(a){const b=a.layer.tileInfo;let c=0;const d={},e=l=>{null!=l.id&&(l.id in d?d[l.id]++:(d[l.id]=1,c++))},f=l=>{if(null!=l.id){var p=d[l.id];1===p?(delete d[l.id],c--):d[l.id]=p-1}};a.forEachTileToFetch(e,f);let g=!0;for(;g&&(g=!1,a.forEachTileToFetch(l=>
{c<=a.options.maximumAutoTileRequests||(f(l),b.upsampleTile(l)&&(g=!0),e(l))},f),g););};h._selectTilesAutoFinest=function(a){const {tileInfo:b,tilemapCache:c}=a.layer,d=H(b,c,a.options.minDemResolution);a.selectTilesAtLOD(d,a.options.maximumAutoTileRequests)};h._selectTilesAutoPrefetchUpsample=async function(a,b){const c=a.layer.tileInfo;await this._populateElevationTiles(a,b);let d=!1;a.forEachTileToFetch((e,f)=>{c.upsampleTile(e)?d=!0:f()});d&&await this._selectTilesAutoPrefetchUpsample(a,b)};h._sampleGeometryWithElevation=
function(a){a.geometry.coordinates.forEach(b=>{var c=b.elevationTile;let d=a.options.noDataValue;c&&(c=c.sample(b.x,b.y),null!=c?d=c:b.elevationTile=null);b.z=d})};h._extractSampleInfo=function(a){const b=a.layer.tileInfo,c=F.getMetersPerUnitForSR(b.spatialReference);return a.geometry.coordinates.map(d=>{let e=-1;d.elevationTile&&d.elevationTile!==a.outsideExtentTile&&(e=b.lodAt(d.elevationTile.tile.level).resolution*c);return{demResolution:e}})};return w._createClass(m)}(),B=function(){function m(){}
var h=m.prototype;h.export=function(){return this._exporter(this.coordinates,this.spatialReference)};h.clone=function(a){const b=new m;b.geometry=this.geometry;b.spatialReference=this.spatialReference;b.coordinates=a||this.coordinates.map(c=>c.clone());b._exporter=this._exporter;return b};h.project=async function(a,b){if(this.spatialReference.equals(a))return this.clone();await z.initializeProjection([{source:this.spatialReference,dest:a}],{signal:b});b=new G({spatialReference:this.spatialReference,
points:this.coordinates.map(d=>[d.x,d.y])});const c=z.project(b,a);if(!c)return null;b=this.coordinates.map((d,e)=>{d=d.clone();e=c.points[e];d.x=e[0];d.y=e[1];return d});b=this.clone(b);b.spatialReference=a;return b};m.fromGeometry=function(a){const b=new m;b.geometry=a;b.spatialReference=a.spatialReference;if(a instanceof m)b.coordinates=a.coordinates.map(c=>c.clone()),b._exporter=(c,d)=>{c=a.clone(c);c.spatialReference=d;return c};else switch(a.type){case "point":const {hasZ:c,hasM:d}=a;b.coordinates=
c&&d?[new r(a.x,a.y,a.z,a.m)]:c?[new r(a.x,a.y,a.z)]:d?[new r(a.x,a.y,null,a.m)]:[new r(a.x,a.y)];b._exporter=(k,n)=>a.hasM?new J(k[0].x,k[0].y,k[0].z,k[0].m,n):new J(k[0].x,k[0].y,k[0].z,n);break;case "multipoint":const {hasZ:e,hasM:f}=a;b.coordinates=e&&f?a.points.map(k=>new r(k[0],k[1],k[2],k[3])):e?a.points.map(k=>new r(k[0],k[1],k[2])):f?a.points.map(k=>new r(k[0],k[1],null,k[2])):a.points.map(k=>new r(k[0],k[1]));b._exporter=(k,n)=>a.hasM?new G({points:k.map(v=>[v.x,v.y,v.z,v.m]),hasZ:!0,hasM:!0,
spatiaReference:n}):new G(k.map(v=>[v.x,v.y,v.z]),n);break;case "polyline":const g=[],l=[],{hasZ:p,hasM:x}=a;let q=0;for(const k of a.paths)if(l.push([q,q+k.length]),q+=k.length,p&&x)for(const n of k)g.push(new r(n[0],n[1],n[2],n[3]));else if(p)for(const n of k)g.push(new r(n[0],n[1],n[2]));else if(x)for(const n of k)g.push(new r(n[0],n[1],null,n[2]));else for(const n of k)g.push(new r(n[0],n[1]));b.coordinates=g;b._exporter=(k,n)=>{const v=a.hasM?k.map(t=>[t.x,t.y,t.z,t.m]):k.map(t=>[t.x,t.y,t.z]);
k=l.map(t=>v.slice(t[0],t[1]));return new P({paths:k,hasM:a.hasM,hasZ:!0,spatialReference:n})}}return b};return w._createClass(m)}(),r=function(){function m(h,a,b=null,c=null,d=null,e=null){this.x=h;this.y=a;this.z=b;this.m=c;this.tile=d;this.elevationTile=e}m.prototype.clone=function(){return new m(this.x,this.y,this.z,this.m)};return w._createClass(m)}(),N=w._createClass(function(m,h){this.layer=m;this.options=h}),Q=function(m){function h(b,c,d){b=m.call(this,b,d)||this;b.outSpatialReference=c;
b.type="geometry";return b}w._inherits(h,m);var a=h.prototype;a.selectTilesAtLOD=function(b){if(0>b)this.geometry.coordinates.forEach(c=>c.tile=null);else{const {tileInfo:c,tilemapCache:d}=this.layer,e=A(c,d)[b].level;this.geometry.coordinates.forEach(f=>f.tile=c.tileAt(e,f.x,f.y))}};a.allElevationTilesFetched=function(){return!this.geometry.coordinates.some(b=>!b.elevationTile)};a.clearElevationTiles=function(){for(const b of this.geometry.coordinates)b.elevationTile!==this.outsideExtentTile&&(b.elevationTile=
null)};a.populateElevationTiles=function(b){for(const c of this.geometry.coordinates)!c.elevationTile&&c.tile?.id&&(c.elevationTile=b[c.tile.id])};a.remapTiles=function(b){for(const c of this.geometry.coordinates){const d=c.tile?.id;c.tile=d?b[d]:null}};a.getTilesToFetch=function(){const b={},c=[];for(const d of this.geometry.coordinates){const e=d.tile;if(!e)continue;const f=d.tile?.id;d.elevationTile||!f||b[f]||(b[f]=e,c.push(e))}return c};a.forEachTileToFetch=function(b){for(const c of this.geometry.coordinates)c.tile&&
!c.elevationTile&&b(c.tile,()=>{c.tile=null})};return w._createClass(h)}(N),R=function(m){function h(b,c,d,e){d=m.call(this,b,d)||this;d.type="extent";d.elevationTiles=[];d._candidateTiles=[];d._fetchedCandidates=new Set;d.extent=c.intersection(b.fullExtent);d.maskExtents=e;return d}w._inherits(h,m);var a=h.prototype;a.selectTilesAtLOD=function(b,c){c=this._maximumLodForRequests(c);b=Math.min(c,b);0>b?this._candidateTiles.length=0:this._selectCandidateTilesCoveringExtentAt(b)};a._maximumLodForRequests=
function(b){const {tileInfo:c,tilemapCache:d}=this.layer,e=A(c,d);if(!b)return e.length-1;const f=this.extent;if(null==f)return-1;for(let g=e.length-1;0<=g;g--){const l=e[g];if(Math.ceil(f.width/(l.resolution*c.size[0]))*Math.ceil(f.height/(l.resolution*c.size[1]))<=b)return g}return-1};a.allElevationTilesFetched=function(){return this._candidateTiles.length===this.elevationTiles.length};a.clearElevationTiles=function(){this.elevationTiles.length=0;this._fetchedCandidates.clear()};a.populateElevationTiles=
function(b){for(const c of this._candidateTiles){const d=c.id&&b[c.id];d&&(this._fetchedCandidates.add(c),this.elevationTiles.push(d))}};a.remapTiles=function(b){this._candidateTiles=this._uniqueNonOverlappingTiles(this._candidateTiles.map(c=>b[c.id]))};a.getTilesToFetch=function(){return this._candidateTiles};a.forEachTileToFetch=function(b,c){const d=this._candidateTiles;this._candidateTiles=[];d.forEach(e=>{if(this._fetchedCandidates.has(e))c&&c(e);else{var f=!1;b(e,()=>f=!0);f?c&&c(e):this._candidateTiles.push(e)}});
this._candidateTiles=this._uniqueNonOverlappingTiles(this._candidateTiles,c)};a._uniqueNonOverlappingTiles=function(b,c){const d={},e=[];for(const g of b)(b=g.id)&&!d[b]?(d[b]=g,e.push(g)):c&&c(g);const f=e.sort((g,l)=>g.level-l.level);return f.filter((g,l)=>{for(let p=0;p<l;p++){const x=f[p].extent;if(x&&g.extent&&D.contains(x,g.extent))return c&&c(g),!1}return!0})};a._selectCandidateTilesCoveringExtentAt=function(b){this._candidateTiles.length=0;var c=this.extent;if(null!=c){var {tileInfo:d,tilemapCache:e}=
this.layer,f=A(d,e)[b];b=d.tileAt(f.level,c.xmin,c.ymin);var g=b.extent;if(null!=g){var l=Math.ceil((c.xmax-g[0])/(f.resolution*d.size[0]));c=Math.ceil((c.ymax-g[1])/(f.resolution*d.size[1]));for(f=0;f<c;f++)for(g=0;g<l;g++){const p=new M.TileKey(null,b.level,b.row-f,b.col+g);d.updateTileInfo(p);this._tileIsMasked(p)||this._candidateTiles.push(p)}}}};a._tileIsMasked=function(b){return this.maskExtents?this.maskExtents.some(c=>b.extent&&D.contains(c,b.extent)):!1};return w._createClass(h)}(N);const E=
{maximumAutoTileRequests:20,noDataValue:0,returnSampleInfo:!1,demResolution:"auto",minDemResolution:0};C.ElevationQuery=S;C.GeometryDescriptor=B;C.getFinestLodIndex=H;Object.defineProperty(C,Symbol.toStringTag,{value:"Module"})});