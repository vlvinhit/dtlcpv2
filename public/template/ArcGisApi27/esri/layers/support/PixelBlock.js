// All material copyright ESRI, All Rights Reserved, unless otherwise specified.
// See https://js.arcgis.com/4.27/esri/copyright.txt for details.
//>>built
define("../../chunks/_rollupPluginBabelHelpers ../../chunks/tslib.es6 ../../core/Error ../../core/JSONSupport ../../core/lang ../../core/Logger ../../core/accessorSupport/decorators/property ../../core/accessorSupport/decorators/cast ../../core/accessorSupport/decorators/subclass ./SimpleBandStatistics ./rasterFormats/pixelRangeUtils".split(" "),function(x,q,A,m,B,v,t,C,D,y,E){var u;m=u=function(z){function w(a){a=z.call(this,a)||this;a.width=null;a.height=null;a.pixelType="f32";a.validPixelCount=
null;a.mask=null;a.maskIsAlpha=!1;a.premultiplyAlpha=!1;a.statistics=null;a.depthCount=1;return a}x._inherits(w,z);w.createEmptyBand=function(a,b){return new (u.getPixelArrayConstructor(a))(b)};w.getPixelArrayConstructor=function(a){let b;switch(a){case "u1":case "u2":case "u4":case "u8":b=Uint8Array;break;case "u16":b=Uint16Array;break;case "u32":b=Uint32Array;break;case "s8":b=Int8Array;break;case "s16":b=Int16Array;break;case "s32":b=Int32Array;break;case "f32":b=Float32Array;break;case "f64":b=
Float64Array;break;case "c64":case "c128":case "unknown":b=Float32Array}return b};var r=w.prototype;r.castPixelType=function(a){if(!a)return"f32";a=a.toLowerCase();["u1","u2","u4"].includes(a)?a="u8":"unknown u8 s8 u16 s16 u32 s32 f32 f64".split(" ").includes(a)||(a="f32");return a};r.getPlaneCount=function(){return this.pixels?.length};r.addData=function(a){if(!a.pixels||a.pixels.length!==this.width*this.height)throw new A("pixelblock:invalid-or-missing-pixels","add data requires valid pixels array that has same length defined by pixel block width * height");
this.pixels||(this.pixels=[]);this.statistics||(this.statistics=[]);this.pixels.push(a.pixels);this.statistics.push(a.statistics??new y.SimpleBandStatistics)};r.getAsRGBA=function(){const a=new ArrayBuffer(this.width*this.height*4);switch(this.pixelType){case "s8":case "s16":case "u16":case "s32":case "u32":case "f32":case "f64":this._fillFromNon8Bit(a);break;default:this._fillFrom8Bit(a)}return new Uint8ClampedArray(a)};r.getAsRGBAFloat=function(){const a=new Float32Array(this.width*this.height*
4);this._fillFrom32Bit(a);return a};r.updateStatistics=function(){if(this.pixels){this.statistics=this.pixels.map(h=>this._calculateBandStatistics(h,this.mask));var a=this.mask,b=0;if(null!=a)for(let h=0;h<a.length;h++)a[h]&&b++;else b=this.width*this.height;this.validPixelCount=b}};r.clamp=function(a){if(a&&"f64"!==a&&"f32"!==a&&this.pixels){var [b,h]=E.getPixelValueRange(a),g=this.pixels,f=this.width*this.height,d=g.length,c=[];for(let e=0;e<d;e++){var l=u.createEmptyBand(a,f);var k=g[e];for(let p=
0;p<f;p++){var n=k[p];l[p]=n>h?h:n<b?b:n}c.push(l)}this.pixels=c;this.pixelType=a}};r.extractBands=function(a){const {pixels:b,statistics:h}=this;if(null==a||0===a.length||!b||0===b.length)return this;var g=b.length,f=a.some(e=>e>=b.length),d=g===a.length&&!a.some((e,p)=>e!==p);if(f||d)return this;g=this.bandMasks?.length===g?a.map(e=>this.bandMasks[e]):void 0;let {mask:c,validPixelCount:l}=this;const {width:k,height:n}=this;if(g){if(1===g.length)c=g[0];else for(f=k*n,c=(new Uint8Array(f)).fill(255),
d=0;d<g.length;d++){const e=g[d];for(let p=0;p<f;p++)e[p]||(c[p]=0)}l=c.filter(e=>!!e).length}return new u({pixelType:this.pixelType,width:k,height:n,mask:c,bandMasks:g,validPixelCount:l,maskIsAlpha:this.maskIsAlpha,pixels:a.map(e=>b[e]),statistics:h&&a.map(e=>h[e])})};r.clone=function(){const a=new u({width:this.width,height:this.height,pixelType:this.pixelType,maskIsAlpha:this.maskIsAlpha,validPixelCount:this.validPixelCount});null!=this.mask&&(a.mask=this.mask instanceof Uint8Array?new Uint8Array(this.mask):
this.mask.slice(0));this.bandMasks&&(a.bandMasks=this.bandMasks.map(g=>new Uint8Array(g)));let b;const h=u.getPixelArrayConstructor(this.pixelType);if(this.pixels&&0<this.pixels.length){a.pixels=[];const g=!!this.pixels[0].slice;for(b=0;b<this.pixels.length;b++)a.pixels[b]=g?this.pixels[b].slice(0,this.pixels[b].length):new h(this.pixels[b])}if(this.statistics)for(a.statistics=[],b=0;b<this.statistics.length;b++)a.statistics[b]=B.clone(this.statistics[b]);a.premultiplyAlpha=this.premultiplyAlpha;
return a};r._fillFrom8Bit=function(a){const {mask:b,maskIsAlpha:h,premultiplyAlpha:g,pixels:f}=this;if(a&&f&&f.length){var d,c;var l=d=c=f[0];3<=f.length?(d=f[1],c=f[2]):2===f.length&&(d=f[1]);var k=new Uint32Array(a),n=this.width*this.height;if(l.length!==n)v.getLogger(this).error("getAsRGBA()","Unable to convert to RGBA. The pixelblock is invalid.");else if(null!=b&&b.length===n)if(h)for(a=0;a<n;a++){const e=b[a];if(e){const p=e/255;k[a]=g?e<<24|c[a]*p<<16|d[a]*p<<8|l[a]*p:e<<24|c[a]<<16|d[a]<<
8|l[a]}}else for(a=0;a<n;a++)b[a]&&(k[a]=-16777216|c[a]<<16|d[a]<<8|l[a]);else for(a=0;a<n;a++)k[a]=-16777216|c[a]<<16|d[a]<<8|l[a]}else v.getLogger(this).error("getAsRGBA()","Unable to convert to RGBA. The input pixel block is empty.")};r._fillFromNon8Bit=function(a){const {pixels:b,mask:h,statistics:g}=this;if(a&&b&&b.length){var f=this.pixelType,d=1,c=0;d=1;if(g&&0<g.length){for(var l of g)null!=l.minValue&&(c=Math.min(c,l.minValue)),null!=l.maxValue&&null!=l.minValue&&(d=Math.max(d,l.maxValue-
l.minValue));d=255/d}else d=255,"s8"===f?(c=-128,d=127):"u16"===f?d=65535:"s16"===f?(c=-32768,d=32767):"u32"===f?d=4294967295:"s32"===f?(c=-2147483648,d=2147483647):"f32"===f?(c=-3.4*1E39,d=3.4*1E39):"f64"===f&&(c=-Number.MAX_VALUE,d=Number.MAX_VALUE),d=255/(d-c);a=new Uint32Array(a);f=this.width*this.height;var k,n,e;l=k=n=b[0];if(l.length!==f)return v.getLogger(this).error("getAsRGBA()","Unable to convert to RGBA. The pixelblock is invalid.");if(2<=b.length)if(k=b[1],3<=b.length&&(n=b[2]),null!=
h&&h.length===f)for(e=0;e<f;e++)h[e]&&(a[e]=-16777216|(n[e]-c)*d<<16|(k[e]-c)*d<<8|(l[e]-c)*d);else for(e=0;e<f;e++)a[e]=-16777216|(n[e]-c)*d<<16|(k[e]-c)*d<<8|(l[e]-c)*d;else if(null!=h&&h.length===f)for(e=0;e<f;e++)k=(l[e]-c)*d,h[e]&&(a[e]=-16777216|k<<16|k<<8|k);else for(e=0;e<f;e++)k=(l[e]-c)*d,a[e]=-16777216|k<<16|k<<8|k}else v.getLogger(this).error("getAsRGBA()","Unable to convert to RGBA. The input pixel block is empty.")};r._fillFrom32Bit=function(a){const {pixels:b,mask:h}=this;if(!a||!b||
!b.length)return v.getLogger(this).error("getAsRGBAFloat()","Unable to convert to RGBA. The input pixel block is empty.");let g,f,d,c;g=f=d=b[0];3<=b.length?(f=b[1],d=b[2]):2===b.length&&(f=b[1]);const l=this.width*this.height;if(g.length!==l)return v.getLogger(this).error("getAsRGBAFloat()","Unable to convert to RGBA. The pixelblock is invalid.");let k=0;if(null!=h&&h.length===l)for(c=0;c<l;c++)a[k++]=g[c],a[k++]=f[c],a[k++]=d[c],a[k++]=h[c]&1;else for(c=0;c<l;c++)a[k++]=g[c],a[k++]=f[c],a[k++]=
d[c],a[k++]=1};r._calculateBandStatistics=function(a,b){let h=Infinity,g=-Infinity;const f=a.length;let d,c=0;if(null!=b)for(d=0;d<f;d++)b[d]&&(c=a[d],h=c<h?c:h,g=c>g?c:g);else for(d=0;d<f;d++)c=a[d],h=c<h?c:h,g=c>g?c:g;return new y.SimpleBandStatistics(h,g)};return x._createClass(w)}(m.JSONSupport);q.__decorate([t.property({json:{write:!0}})],m.prototype,"width",void 0);q.__decorate([t.property({json:{write:!0}})],m.prototype,"height",void 0);q.__decorate([t.property({json:{write:!0}})],m.prototype,
"pixelType",void 0);q.__decorate([C.cast("pixelType")],m.prototype,"castPixelType",null);q.__decorate([t.property({json:{write:!0}})],m.prototype,"validPixelCount",void 0);q.__decorate([t.property({json:{write:!0}})],m.prototype,"mask",void 0);q.__decorate([t.property({json:{write:!0}})],m.prototype,"maskIsAlpha",void 0);q.__decorate([t.property({json:{write:!0}})],m.prototype,"pixels",void 0);q.__decorate([t.property()],m.prototype,"premultiplyAlpha",void 0);q.__decorate([t.property({json:{write:!0}})],
m.prototype,"statistics",void 0);q.__decorate([t.property({json:{write:!0}})],m.prototype,"depthCount",void 0);q.__decorate([t.property({json:{write:!0}})],m.prototype,"noDataValues",void 0);q.__decorate([t.property({json:{write:!0}})],m.prototype,"bandMasks",void 0);return m=u=q.__decorate([D.subclass("esri.layers.support.PixelBlock")],m)});