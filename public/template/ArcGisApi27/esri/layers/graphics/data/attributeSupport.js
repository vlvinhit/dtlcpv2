// All material copyright ESRI, All Rights Reserved, unless otherwise specified.
// See https://js.arcgis.com/4.27/esri/copyright.txt for details.
//>>built
define(["exports","../../../core/Error","../../../core/jsonMap","../../../core/sql/WhereClauseCache"],function(e,m,f,n){function p(b,a,c={}){a=w(b,a);if(!a)throw new m("feature-store:unsupported-query","invalid SQL expression",{expression:b});const d=c.expressionName||"expression";if(c.validateStandardized&&!a.isStandardized)throw new m("feature-store:unsupported-query",`${d} is not standard`,{expression:b});if(c.validateAggregate&&!a.isAggregate)throw new m("feature-store:unsupported-query",`${d} does not contain a valid aggregate function`,
{expression:b});return a.fieldNames}function w(b,a){return b?x.get(b,a):null}function q(b,a,c={}){c.errorMessage||(c.errorMessage=c.expressionName?`${c.expressionName} contains invalid fields`:"Fields are invalid");r(b,a,(d,g)=>g.has(d),c)}function t(b,a,c={}){c.errorMessage||(c.errorMessage=c.expressionName?`${c.expressionName} only supports ${y} field types`:`Only ${y} field types are supported`);r(b,a,(d,g)=>!z(d,g),c)}function r(b,a,c,d={}){const g=d.verifyExpression??!0,h=[];for(const k of a)if(a=
c(k,b),"*"!==k&&!a)if(g){a=A(k);try{const l=p(a,b,{validateStandardized:!0});r(b,l,c,d)}catch(l){a=l?.details;if(a?.expression)throw l;a?.invalidFields?h.push(...a.invalidFields):h.push(k)}}else h.push(k);if(h.length)throw new m("feature-store:unsupported-query",d.errorMessage,{invalidFields:h,query:d.query});}function A(b){return b.split(" as ")[0]}function z(b,a,c=B){return(b=a.get(b))?!c.has(b.type):!1}const x=new n.WhereClauseCache(50,500);n=new f.JSONMap({esriFieldTypeString:"string"});const u=
new f.JSONMap({esriFieldTypeOID:"oid",esriFieldTypeSmallInteger:"small-integer",esriFieldTypeInteger:"integer",esriFieldTypeSingle:"single",esriFieldTypeDouble:"double",esriFieldTypeLong:"long"}),v=new f.JSONMap({esriFieldTypeDate:"date"});f=new f.JSONMap({esriFieldTypeGUID:"guid",esriFieldTypeGlobalId:"global-id"});const B=new Set([...u.jsonValues,...v.jsonValues,...n.jsonValues,...f.jsonValues]),y=(new Intl.ListFormat("en-US",{type:"conjunction"})).format([...u.apiValues,...v.apiValues,...n.apiValues,
...f.apiValues]);e.getAliasFromFieldName=function(b){return b.split(" as ")[1]};e.getExpressionFromFieldName=A;e.getWhereClause=w;e.hasInvalidFieldType=z;e.validDateTypesKebabDict=v;e.validGuidTypesKebabDict=f;e.validNumericTypesKebabDict=u;e.validStringTypesKebabDict=n;e.validateFieldTypes=t;e.validateFields=q;e.validateHaving=function(b,a,c,d){if(!a)return!0;const g=p(a,b,{validateAggregate:!0,expressionName:"having"});q(b,g,{expressionName:"having",query:d});t(b,g,{expressionName:"having",query:d});
if(!x.get(a,b)?.getExpressions().every(h=>{const {aggregateType:k,field:l}=h,C=b.get(l)?.name;return c.some(D=>{const {onStatisticField:E,statisticType:F}=D;return b.get(E)?.name===C&&F.toLowerCase().trim()===k})}))throw new m("feature-store:unsupported-query","expressions in having should also exist in outStatistics",{having:a});return!0};e.validateWhere=function(b,a,c){if(!a)return!0;a=p(a,b,{validateStandardized:!0,expressionName:"where clause"});q(b,a,{expressionName:"where clause",query:c});
t(b,a,{expressionName:"where clause",query:c});return!0};Object.defineProperty(e,Symbol.toStringTag,{value:"Module"})});