// All material copyright ESRI, All Rights Reserved, unless otherwise specified.
// See https://js.arcgis.com/4.27/esri/copyright.txt for details.
//>>built
define("exports ../../../../request ../../../../core/Error ../../../../core/Logger ../../../../core/promiseUtils ../../../../core/urlUtils ../../../../core/uuid ../../../../geometry/support/meshUtils/External ./uploads ../../../support/infoFor3D".split(" "),function(r,n,k,y,h,q,z,l,A,p){async function B(a,{layer:b,ongoingUploads:c},e){const g=c.get(a);if(g)return g;if(!b.infoFor3D||!b.url)throw new k(`${b.type}-layer:upload-failure`,"Layer does not support asset uploads.",Error());if(C(a,b))return a;
b=D(a,b,e);c.set(a,b);try{await b}finally{c.delete(a)}return a}function C(a,b){const {parsedUrl:c}=b;return null!=c&&a.metadata.externalSources.some(e=>l.externalIsOnService(e,c))}async function D(a,b,c){var {metadata:e}=a,{displaySource:g}=e;g=t(g?.source,b);e=0<e.externalSources.length;b=await (g?E(g,b,c):e?F(a,b,c):G(a,b,c));h.throwIfAborted(c);a.addExternalSources([b]);return a}async function E(a,b,c){return{source:await u(a,b,c),original:!0}}async function F(a,b,c){const e=v(b);var {externalSources:g}=
a.metadata;a:{for(d of g)if(g=t(d.source,b)){var d=g;break a}d=null}if(!d)throw new k(`${b.type}-layer:upload-failure`,"Could not find an external source that is supported by the service.",Error());c=await u(d,b,c);a.addExternalSources([{source:c,original:!0}]);return{source:await H(c,b,e)}}async function G(a,b,c){const e=I(a,b,c);return{source:await w([e],b,c),extent:a.extent.clone(),original:!0}}async function I(a,b,c){b=v(b);a=await (await a.load(c)).toBinaryGLTF({ignoreLocalTransform:!0});h.throwIfAborted(c);
a=await a.buffer();h.throwIfAborted(c);return{blob:new Blob([a.data],{type:a.type}),assetName:`${z.generateBracedUUID()}.glb`,assetType:b}}function t(a,b){if(!a)return null;const {infoFor3D:{supportedFormats:c,editFormats:e}}=b;a=l.externalSourceToMultiPart(a);b=[];let g=!1;for(let f=0;f<a.length;++f){{var d=a[f];const m=l.assetFormatId(d,c);d=m?{asset:d,assetType:m}:null}if(!d)return null;e.includes(d.assetType)&&(g=!0);b.push(d)}return g?b:null}async function u(a,b,c){a=a.map(e=>J(e,c));return w(a,
b,c)}async function w(a,b,c){const e=await Promise.all(a.map(async d=>{d=K(await d,b,c);h.throwIfAborted(c);return d}));h.throwIfAborted(c);const {uploadResults:g}=await L(e.map(({item:d})=>d),b,c);h.throwIfAborted(c);return a.map((d,f)=>{d=e[f];f=g[f];const {success:m}=f;if(!m)throw{error:f}=f,new k(`${b.type}-layer:upload-failure`,`Failed to upload mesh file ${d.assetName}. Error code: ${f.code}. Error message: ${f.messages}`,Error());({assetHash:f}=f);const {assetName:M,item:{assetType:x}}=d;({infoFor3D:{supportedFormats:d}}=
b);d=p.getFormatIdMimeType(x,d);if(!d)throw new k(`${b.type}-layer:upload-failure`,`The service allowed us to upload an asset of FormatID ${x}, but it does not list it in its supported formats.`,Error());return new l.ServiceAsset(M,d,[new l.ServiceAssetPart(`${b.parsedUrl.path}/assets/${f}`,f)])})}async function J(a,b){const {asset:c,assetType:e}=a;if(c instanceof File)return{blob:c,assetName:c.name,assetType:e};a=await c.toBlob(b);h.throwIfAborted(b);return{blob:a,assetName:c.assetName,assetType:e}}
async function K(a,b,c){const {blob:e,assetType:g,assetName:d}=a;a=null;try{var f=await A.uploadItem({data:e,name:d},b.url,c);h.throwIfAborted(c);a={assetType:g,assetUploadId:f.itemID}}catch(m){h.throwIfAbortError(m),y.getLogger("esri.layers.graphics.sources.support.uploadAssets").warnOnce(`Service ${b.url} does not support the REST Uploads API.`)}if(!a){f=await q.parseData(e);h.throwIfAborted(c);if(!f.isBase64)throw new k(`${b.type}-layer:uploadAssets-failure`,"Expected gltf data in base64 format after conversion.",
Error());a={assetType:g,assetData:f.data}}if(!a)throw new k(`${b.type}-layer:uploadAssets-failure`,"Unable to prepare uploadAsset request options.",Error());return{item:a,assetName:d}}async function L(a,b,c){const e=await n(q.join(b.parsedUrl.path,"uploadAssets"),{timeout:0,query:{f:"json",assets:JSON.stringify(a)},method:"post",responseType:"json"});h.throwIfAborted(c);if(e.data.uploadResults.length!==a.length)throw new k(`${b.type}-layer:uploadAssets-failure`,`Bad response. Uploaded ${a.length} items and received ${e.data.uploadResults.length} results.`,
Error());return e.data}async function H(a,b,c){var e=a.map(({assetName:d,parts:f})=>({assetName:d,assetHash:f[0].partHash}));a=b.capabilities?.operations.supportsAsyncConvert3D;c={query:{f:"json",assets:JSON.stringify(e),transportType:"esriTransportTypeUrl",targetFormat:c,async:a},responseType:"json",timeout:0};e=q.join(b.parsedUrl.path,"convert3D");a=(a?await N(e,c):await n(e,c)).data;const {infoFor3D:{supportedFormats:g}}=b;return a.assets.map(d=>{const f=p.getMimeTypeFormatId(d.contentType,g);
if(!f)throw new k(`${b.type}-layer:upload-failure`,`The service allowed us to upload an asset of FormatID ${f}, but it does not list it in its supported formats.`,Error());return new l.ServiceAsset(d.assetName,d.contentType,[new l.ServiceAssetPart(d.assetURL,d.assetHash)])})}async function N(a,b){for(a=(await n(a,b)).data.statusUrl;;){b=(await n(a,{query:{f:"json"},responseType:"json"})).data;switch(b.status){case "Completed":return n(b.resultUrl,{query:{f:"json"},responseType:"json"});case "CompletedWithErrors":throw new k("async-convert3D-failed",
"asynchronous convert3D call failed.");case "Failed ImportChanges":case "InProgress":case "Pending":case "ExportAttachments":case "ExportChanges":case "ExportingData":case "ExportingSnapshot":case "ImportAttachments":case "ProvisioningReplica":case "UnRegisteringReplica":break;default:throw new k("async-convert3D-failed","asynchronous convert3D call failed (undefined response status)");}await h.after(1E3)}}function v(a){var {infoFor3D:b}=a;b=p.getMimeTypeFormatId("model/gltf-binary",b.supportedFormats)??
p.getFilenameFormatId("glb",b.supportedFormats);if(!b)throw new k(`${a.type}-layer:upload-failure`,"Layer does not support glb.",Error());return b}r.uploadAssets=async function(a,b,c){return a.length?Promise.all(a.map(e=>B(e,b,c))):[]};Object.defineProperty(r,Symbol.toStringTag,{value:"Module"})});