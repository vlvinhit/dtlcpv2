// All material copyright ESRI, All Rights Reserved, unless otherwise specified.
// See https://js.arcgis.com/4.27/esri/copyright.txt for details.
//>>built
define("exports ../../../core/Error ../../../chunks/mat3 ../../../geometry/Point ../../../geometry/projection ../../../geometry/support/webMercatorUtils ../../ElevationLayer ./utils".split(" "),function(D,J,K,u,G,B,L,z){async function E(n,a,h=!1){if(h)return H(n,1);const {feature:f,options:r,currentCoveragePolygon:c}=a;a=f.attributes.elevationSource;if(!a?.url&&!a?.constantElevation)return n;const {url:g,constantElevation:t}=a;if(t)return H(n,t);!f.elevationSample&&(a="esri.Graphic"===c?.declaredClass?
c.geometry?.extent:c.extent)&&(a=a.clone(),h=new L(g),a.xmin/=2,a.xmax*=2,a.ymin/=2,a.ymax*=2,f.elevationSample=await h.createElevationSampler(a,r),h.destroy());return Promise.all(n.map(async p=>{p.z=1;const q=f.elevationSample?.queryElevation(G.project(p,f.elevationSample.spatialReference));q?.z&&(p.z=q.z);return p}))}function H(n,a){return n.map(h=>{h.z=a;return h})}function M(n,a){const {feature:h,imageProperties:f}=a,{width:r,height:c}=f,{attributes:g}=h;a=z.calculateRotationMatrix("HPR",[g.cameraHeading,
g.cameraPitch,g.cameraRoll]);const t=Math.sin(g.imageRotation??0*C),p=Math.cos(g.imageRotation??0*C),q=r??1,w=c??1,k=[Math.abs(p*q+t*w),Math.abs(p*w-t*q)],v=[-(1/(2*Math.tan(g.horizontalFieldOfView*C/2))),0,.5,0,1/(2*Math.tan(g.verticalFieldOfView*C/2)),.5,0,0,1];let b=new u(g.geometry);b.spatialReference.isWGS84&&4!==g.cameraOrientation?.type&&(b=B.geographicToWebMercator(b));const l=b.spatialReference.isWebMercator?1/Math.cos(Math.PI/2-2*Math.atan(Math.exp(-1*b.y/6378137))):1,d=K.mul(Array(9),a,
v);return n.map(e=>{var m=new u(e);m.spatialReference.isWGS84&&(4===g.cameraOrientation?.type?(e=g.cameraOrientation,m=new u(z.geographicToLTP(m,[e.latitude,e.longitude,e.ellipsoidRadius,e.squaredEccentricity]))):m=new u(B.geographicToWebMercator(m)));e=(m.z??0)-(b.z??0);const x=(m.x-b.x)/l,y=(m.y-b.y)/l;m=(d[0]*x+d[1]*y+d[2]*e)/(d[6]*x+d[7]*y+d[8]*e)*k[0];e=(d[3]*x+d[4]*y+d[5]*e)/(d[6]*x+d[7]*y+d[8]*e)*k[1];return{x:p*(m-k[0]/2)+t*(e-k[1]/2)+q/2,y:-t*(m-k[0]/2)+p*(e-k[1]/2)+w/2}})}function N(n,a){({feature:a}=
a);const {attributes:h}=a;a=h.cameraOrientation;if(!a)throw new J("groundToImageUtils:missing-camera-orientation-parameters","CameraOrientation Parameters are required to perform advanced transformations");let f=new u(h.location);f.spatialReference.isWGS84&&4!==h.cameraOrientation?.type&&(f=B.geographicToWebMercator(f));const r=f.spatialReference.isWebMercator?1/Math.cos(Math.PI/2-2*Math.atan(Math.exp(-1*f.y/6378137))):1;let c;if("esri.layers.orientedImagery.core.CameraOrientationOPK"===a.declaredClass){const {omega:k,
phi:v,kappa:b}=a;c=z.calculateRotationMatrix("OPK",[k,v,b])}else{const {cameraHeading:k,cameraPitch:v,cameraRoll:b}=h;c=z.calculateRotationMatrix("HPR",[k,v,b])}const {principalOffsetPoint:g,focalLength:t,radialDistortionCoefficients:p,affineTransformations:q,tangentialDistortionCoefficients:w}=a;return Promise.all(n.map(k=>{function v(b){if(b.spatialReference.isWGS84)if(4===h.cameraOrientation?.type){var l=h.cameraOrientation;b=new u(z.geographicToLTP(b,[l.latitude,l.longitude,l.ellipsoidRadius,
l.squaredEccentricity]))}else b=new u(B.geographicToWebMercator(b));l=(b.z??0)-(f.z??0);var d=(b.x-f.x)/r,e=(b.y-f.y)/r;b=(c[0]*d+c[1]*e+c[2]*l)/(c[6]*d+c[7]*e+c[8]*l);l=(c[3]*d+c[4]*e+c[5]*l)/(c[6]*d+c[7]*e+c[8]*l);d=b**2+l**2;var m=0;let x=0,y=0,F=e=0;var A=0;let I=0;p&&(m=p[0]??0,x=p[1]??0,y=p[2]??0);w&&(e=w[0],F=w[1]);g&&(A=g[0]??0,I=g[1]??0);m=1+(m||0)*d+(x||0)*d*d+(y||0)*d*d*d;A=-(t??0)*(b*m+(e||0)*(d+2*b**2)+2*(F||0)*b*l)+A;b=-(t??0)*(l*m+(F||0)*(d+2*l**2)+2*(e||0)*b*l)+I;return{x:Number(q[0])+
Number(q[1])*A+Number(q[2])*b,y:Number(q[3])+Number(q[4])*A+Number(q[5])*b}}return k.spatialReference.equals(f.spatialReference)?(k=new u(k),v(k)):(k=G.project(k,f.spatialReference))?v(k):null}))}const C=Math.PI/180;D.transformPoints=async function(n,a,h=!1){if(!n)return[];n=n.map(c=>"esri.geometry.Point"===c.declaredClass?c:u.fromJSON(c));const {feature:f}=a;var {attributes:r}=f;isNaN(parseFloat(r.elevation))&&(r=await E([f.geometry],a),f.attributes.elevation=r[0].z);return E(n,a,h).then(c=>{{const {attributes:g}=
a.feature;c=g.isSpherical||360===g.horizontalFieldOfView?{}:g.cameraOrientation?.isAdvanced?N(c,a):Promise.resolve(M(c,a))}return c})};D.updateElevation=E;Object.defineProperty(D,Symbol.toStringTag,{value:"Module"})});