/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.27/esri/copyright.txt for details.
*/
import{h as e}from"../../chunks/utils.js";import{L as s}from"../../chunks/Logger.js";import{isPromiseLike as t,createAbortError as i,createResolver as n,throwIfAborted as o}from"../promiseUtils.js";import{Q as r}from"../../chunks/Queue.js";import l from"./RemoteClient.js";import"../lang.js";import"../../chunks/typedArrayUtil.js";import"../../chunks/maybe.js";import"../../config.js";import"../../chunks/object.js";import"../../chunks/string.js";import"../Error.js";import"../../chunks/tracking.js";import"../../chunks/SimpleObservable.js";import"../../chunks/ObservableBase.js";import"../../kernel.js";import"../urlUtils.js";class h{constructor(){this._inUseClients=new Array,this._clients=new Array,this._clientPromises=new Array,this._ongoingJobsQueue=new r}destroy(){this.close()}get closed(){return!this._clients||!this._clients.length}open(e,s){return new Promise(((i,n)=>{let r=!0;const h=e=>{o(s.signal),r&&(r=!1,e())};this._clients.length=e.length,this._clientPromises.length=e.length,this._inUseClients.length=e.length;for(let o=0;o<e.length;++o){const r=e[o];t(r)?this._clientPromises[o]=r.then((e=>(this._clients[o]=new l(e,s,(()=>this._ongoingJobsQueue.pop()??null)),h(i),this._clients[o])),(()=>(h(n),null))):(this._clients[o]=new l(r,s,(()=>this._ongoingJobsQueue.pop()??null)),this._clientPromises[o]=Promise.resolve(this._clients[o]),h(i))}}))}broadcast(e,s,t){const i=new Array(this._clientPromises.length);for(let n=0;n<this._clientPromises.length;++n){const o=this._clientPromises[n];i[n]=o.then((i=>i?.invoke(e,s,t)))}return i}close(){let e;for(;e=this._ongoingJobsQueue.pop();)e.resolver.reject(i(`Worker closing, aborting job calling '${e.methodName}'`));for(const e of this._clientPromises)e.then((e=>e?.close()));this._clients.length=0,this._clientPromises.length=0,this._inUseClients.length=0}invoke(e,t,i){let o;Array.isArray(i)?(s.getLogger("esri.core.workers.Connection").warn("invoke()","The transferList parameter is deprecated, use the options object instead"),o={transferList:i}):o=i;const r=n();this._ongoingJobsQueue.push({methodName:e,data:t,invokeOptions:o,resolver:r});for(let e=0;e<this._clientPromises.length;e++){const s=this._clients[e];s?s.jobAdded():this._clientPromises[e].then((e=>e?.jobAdded()))}return r.promise}on(s,t){return Promise.all(this._clientPromises).then((()=>e(this._clients.map((e=>e.on(s,t))))))}openPorts(){return new Promise((e=>{const s=new Array(this._clientPromises.length);let t=s.length;for(let i=0;i<this._clientPromises.length;++i)this._clientPromises[i].then((n=>{n&&(s[i]=n.openPort()),0==--t&&e(s)}))}))}get test(){return{numClients:this._clients.length}}}export{h as default};
