"use strict";(self.webpackChunkRemoteClient=self.webpackChunkRemoteClient||[]).push([[9410],{19410:(e,t,s)=>{s.d(t,{uploadAssets:()=>m});var a=s(82058),r=s(60991),n=s(92143),o=s(50406),i=s(32101),l=s(10279),u=s(20114),c=s(21132),p=s(13235);s(31450),s(48578),s(71552),s(76506),s(88762),s(40642),s(38742);const d=1e6,f=20*d,y=2e9,w=3;async function m(e,t,s){return e.length?Promise.all(e.map((e=>async function(e,{layer:t,ongoingUploads:s},n){const c=s.get(e);if(c)return c;if(!(d=t).infoFor3D||!d.url)throw new r.Z(`${t.type}-layer:upload-failure`,"Layer does not support asset uploads.",new Error);var d;if(function(e,t){const{parsedUrl:s}=t;return null!=s&&e.metadata.externalSources.some((e=>(0,u.a)(e,s)))}(e,t))return e;const f=async function(e,t,s){const{metadata:n}=e,{displaySource:c}=n,d=h(c?.source,t),f=!!d,y=n.externalSources.length>0,w=f?async function(e,t,s){return{source:await T(e,t,s),original:!0}}(d,t,s):y?async function(e,t,s){const n=v(t),{externalSources:l}=e.metadata,c=function(e,t){for(const s of e){const e=h(s.source,t);if(e)return e}return null}(l,t);if(!c)throw new r.Z(`${t.type}-layer:upload-failure`,"Could not find an external source that is supported by the service.",new Error);const d=await T(c,t,s);e.addExternalSources([{source:d,original:!0}]);const f=await async function(e,t,s){const n=e.map((({assetName:e,parts:t})=>({assetName:e,assetHash:t[0].partHash}))),l=t.capabilities?.operations.supportsAsyncConvert3D,c={query:{f:"json",assets:JSON.stringify(n),transportType:"esriTransportTypeUrl",targetFormat:s,async:l},responseType:"json",timeout:0},d=(0,i.v_)(t.parsedUrl.path,"convert3D"),f=(l?await async function(e,t){const s=(await(0,a.default)(e,t)).data.statusUrl;for(;;){const e=(await(0,a.default)(s,{query:{f:"json"},responseType:"json"})).data;switch(e.status){case"Completed":return(0,a.default)(e.resultUrl,{query:{f:"json"},responseType:"json"});case"CompletedWithErrors":throw new r.Z("async-convert3D-failed","asynchronous convert3D call failed.");case"Failed ImportChanges":case"InProgress":case"Pending":case"ExportAttachments":case"ExportChanges":case"ExportingData":case"ExportingSnapshot":case"ImportAttachments":case"ProvisioningReplica":case"UnRegisteringReplica":break;default:throw new r.Z("async-convert3D-failed","asynchronous convert3D call failed (undefined response status)")}await(0,o.e4)(E)}}(d,c):await(0,a.default)(d,c)).data,{infoFor3D:{supportedFormats:y}}=t;return f.assets.map((e=>{const s=(0,p.a)(e.contentType,y);if(!s)throw new r.Z(`${t.type}-layer:upload-failure`,`The service allowed us to upload an asset of FormatID ${s}, but it does not list it in its supported formats.`,new Error);return new u.c(e.assetName,e.contentType,[new u.S(e.assetURL,e.assetHash)])}))}(d,t,n);return{source:f}}(e,t,s):async function(e,t,s){const a=async function(e,t,s){const a=v(t),r=await e.load(s),n=await r.toBinaryGLTF({ignoreLocalTransform:!0});(0,o.k_)(s);const i=await n.buffer();return(0,o.k_)(s),{blob:new Blob([i.data],{type:i.type}),assetName:`${(0,l.a)()}.glb`,assetType:a}}(e,t,s);return{source:await b([a],t,s),extent:e.extent.clone(),original:!0}}(e,t,s),m=await w;return(0,o.k_)(s),e.addExternalSources([m]),e}(e,t,n);s.set(e,f);try{await f}finally{s.delete(e)}return e}(e,t,s)))):[]}function h(e,t){if(!e)return null;const{infoFor3D:{supportedFormats:s,editFormats:a}}=t,r=(0,u.f)(e),n=new Array;let o=!1;for(let e=0;e<r.length;++e){const t=g(r[e],s);if(!t)return null;a.includes(t.assetType)&&(o=!0),n.push(t)}return o?n:null}function g(e,t){const s=(0,u.d)(e,t);return s?{asset:e,assetType:s}:null}async function T(e,t,s){const a=e.map((e=>async function(e,t){const{asset:s,assetType:a}=e;if(s instanceof File)return{blob:s,assetName:s.name,assetType:a};const r=await s.toBlob(t);return(0,o.k_)(t),{blob:r,assetName:s.assetName,assetType:a}}(e,s)));return b(a,t,s)}async function b(e,t,s){const l=await Promise.all(e.map((async e=>{const l=async function(e,t,s){const{blob:l,assetType:u,assetName:p}=e;let m=null;try{const e=await async function({data:e,name:t,description:s},r,n){let l=null;try{const u=(0,i.v_)(r,"uploads"),p=(0,i.v_)(u,"info"),{data:m}=await(0,a.default)(p,{query:{f:"json"},responseType:"json"});(0,o.k_)(n);const h=(0,c.i)(r),g=m.maxUploadFileSize*d,T=h?y:g,b=h?Math.min(f,g):f;if(e.size>T)throw new Error("Data too large");const v=(0,i.v_)(u,"register"),{data:E}=await(0,a.default)(v,{query:{f:"json",itemName:t,description:s},responseType:"json",method:"post"});if((0,o.k_)(n),!E.success)throw new Error("Registration failed");const{itemID:_}=E.item;l=(0,i.v_)(u,_);const $=(0,i.v_)(l,"uploadPart"),F=Math.ceil(e.size/b),j=new Array;for(let t=0;t<F;++t)j.push(e.slice(t*b,Math.min((t+1)*b,e.size)));const k=j.slice().reverse(),D=new Array,U=async()=>{for(;0!==k.length;){const e=j.length-k.length,t=k.pop(),s=new FormData;s.append("f","json"),s.append("file",t),s.append("partId",`${e}`);const{data:r}=await(0,a.default)($,{timeout:0,body:s,responseType:"json",method:"post"});if((0,o.k_)(n),!r.success)throw new Error("Part upload failed")}};for(let e=0;e<w&&0!==k.length;++e)D.push(U());await Promise.all(D);const x=(0,i.v_)(l,"commit"),{data:A}=await(0,a.default)(x,{query:{f:"json",parts:j.map(((e,t)=>t)).join(",")},responseType:"json",method:"post"});if((0,o.k_)(n),!A.success)throw new Error("Commit failed");return A.item}catch(e){if(null!=l){const e=(0,i.v_)(l,"delete");await(0,a.default)(e,{query:{f:"json"},responseType:"json",method:"post"})}throw e}}({data:l,name:p},t.url,s);(0,o.k_)(s),m={assetType:u,assetUploadId:e.itemID}}catch(e){(0,o.r9)(e),n.L.getLogger("esri.layers.graphics.sources.support.uploadAssets").warnOnce(`Service ${t.url} does not support the REST Uploads API.`)}if(!m){const e=await(0,i.IR)(l);if((0,o.k_)(s),!e.isBase64)throw new r.Z(`${t.type}-layer:uploadAssets-failure`,"Expected gltf data in base64 format after conversion.",new Error);m={assetType:u,assetData:e.data}}if(!m)throw new r.Z(`${t.type}-layer:uploadAssets-failure`,"Unable to prepare uploadAsset request options.",new Error);return{item:m,assetName:p}}(await e,t,s);return(0,o.k_)(s),l})));(0,o.k_)(s);const{uploadResults:m}=await async function(e,t,s){const n=await(0,a.default)((0,i.v_)(t.parsedUrl.path,"uploadAssets"),{timeout:0,query:{f:"json",assets:JSON.stringify(e)},method:"post",responseType:"json"});if((0,o.k_)(s),n.data.uploadResults.length!==e.length)throw new r.Z(`${t.type}-layer:uploadAssets-failure`,`Bad response. Uploaded ${e.length} items and received ${n.data.uploadResults.length} results.`,new Error);return n.data}(l.map((({item:e})=>e)),t,s);return(0,o.k_)(s),e.map(((e,s)=>function(e,t,s){const{success:a}=t;if(!a){const{error:a}=t;throw new r.Z(`${s.type}-layer:upload-failure`,`Failed to upload mesh file ${e.assetName}. Error code: ${a.code}. Error message: ${a.messages}`,new Error)}const{assetHash:n}=t,{assetName:o,item:{assetType:i}}=e,{infoFor3D:{supportedFormats:l}}=s,c=(0,p.c)(i,l);if(!c)throw new r.Z(`${s.type}-layer:upload-failure`,`The service allowed us to upload an asset of FormatID ${i}, but it does not list it in its supported formats.`,new Error);return new u.c(o,c,[new u.S(`${s.parsedUrl.path}/assets/${n}`,n)])}(l[s],m[s],t)))}function v(e){const{infoFor3D:t}=e,s=(0,p.a)("model/gltf-binary",t.supportedFormats)??(0,p.g)("glb",t.supportedFormats);if(!s)throw new r.Z(`${e.type}-layer:upload-failure`,"Layer does not support glb.",new Error);return s}const E=1e3}}]);