/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.27/esri/copyright.txt for details.
*/
import t from"../../config.js";import s from"../../core/Error.js";import{L as e}from"../../chunks/Logger.js";import o from"../Polygon.js";import n from"../Polyline.js";import{g as r,c as i,o as c,u as p}from"../../chunks/normalizeUtilsCommon.js";import{h as l}from"../../chunks/unitUtils.js";import{geographicToWebMercator as u,webMercatorToGeographic as m}from"./webMercatorUtils.js";import{c as h,s as a}from"../../chunks/simplify.js";import"../../chunks/typedArrayUtil.js";import"../../chunks/object.js";import"../../core/lang.js";import"../../chunks/string.js";import"../../chunks/tslib.es6.js";import"../../core/accessorSupport/decorators/property.js";import"../../chunks/ensureType.js";import"../../chunks/get.js";import"../../chunks/utils.js";import"../../chunks/maybe.js";import"../../chunks/metadata.js";import"../../core/accessorSupport/decorators/subclass.js";import"../../chunks/tracking.js";import"../../chunks/writer.js";import"../Extent.js";import"../Geometry.js";import"../../core/JSONSupport.js";import"../../core/Accessor.js";import"../../core/Handles.js";import"../../chunks/ObjectPool.js";import"../../chunks/ObservableBase.js";import"../../chunks/watch.js";import"../../chunks/ArrayPool.js";import"../../core/scheduling.js";import"../../chunks/nextTick.js";import"../../chunks/PooledArray.js";import"../../core/promiseUtils.js";import"../../chunks/reader.js";import"../SpatialReference.js";import"../../chunks/jsonMap.js";import"../Point.js";import"../../core/accessorSupport/decorators/cast.js";import"../../chunks/extentUtils.js";import"../../chunks/aaBoundingRect.js";import"../../chunks/mathUtils.js";import"../../chunks/vec3.js";import"../../chunks/vec3f64.js";import"../../chunks/common.js";import"../../chunks/vec4.js";import"../../chunks/zmUtils.js";import"./jsonUtils.js";import"../Multipoint.js";import"../../geometry.js";import"../../chunks/typeUtils.js";import"../../request.js";import"../../kernel.js";import"../../core/urlUtils.js";import"../../chunks/utils4.js";import"../../chunks/utils5.js";const f=e.getLogger("esri.geometry.support.normalizeUtils");function j(t){const s=[];let e=0,o=0;for(let n=0;n<t.length;n++){const r=t[n];let i=null;for(let t=0;t<r.length;t++)i=r[t],s.push(i),0===t?(e=i[0],o=e):(e=Math.min(e,i[0]),o=Math.max(o,i[0]));i&&s.push([(e+o)/2,0])}return s}function g(t,e){if(!(t instanceof n||t instanceof o)){const t="straightLineDensify: the input geometry is neither polyline nor polygon";throw f.error(t),new s(t)}const i=r(t),c=[];for(const t of i){const s=[];c.push(s),s.push([t[0][0],t[0][1]]);for(let o=0;o<t.length-1;o++){const n=t[o][0],r=t[o][1],i=t[o+1][0],c=t[o+1][1],p=Math.sqrt((i-n)*(i-n)+(c-r)*(c-r)),l=(c-r)/p,u=(i-n)/p,m=p/e;if(m>1){for(let t=1;t<=m-1;t++){const o=t*e,i=u*o+n,c=l*o+r;s.push([i,c])}const t=(p+Math.floor(m-1)*e)/2,o=u*t+n,i=l*t+r;s.push([o,i])}s.push([i,c])}}return function(t){return"polygon"===t.type}(t)?new o({rings:c,spatialReference:t.spatialReference}):new n({paths:c,spatialReference:t.spatialReference})}function y(t,s,e){if(s){const s=g(t,1e6);t=m(s,!0)}return e&&(t=p(t,e)),t}function k(t,s,e){if(Array.isArray(t)){const o=t[0];if(o>s){const e=c(o,s);t[0]=o+e*(-2*s)}else if(o<e){const s=c(o,e);t[0]=o+s*(-2*e)}}else{const o=t.x;if(o>s){const e=c(o,s);t=t.clone().offset(e*(-2*s),0)}else if(o<e){const s=c(o,e);t=t.clone().offset(s*(-2*e),0)}}return t}async function x(s,e,m){if(!Array.isArray(s))return x([s],e);e&&"string"!=typeof e&&f.warn("normalizeCentralMeridian()","The url object is deprecated, use the url string instead");const j="string"==typeof e?e:e?.url??t.geometryServiceUrl;let g,d,w,b,U,M,P,R,A=0;const v=[],S=[];for(const t of s)if(null!=t)if(g||(g=t.spatialReference,d=l(g),w=g.isWebMercator,M=w?102100:4326,b=i[M].maxX,U=i[M].minX,P=i[M].plus180Line,R=i[M].minus180Line),d)if("mesh"===t.type)S.push(t);else if("point"===t.type)S.push(k(t.clone(),b,U));else if("multipoint"===t.type){const s=t.clone();s.points=s.points.map((t=>k(t,b,U))),S.push(s)}else if("extent"===t.type){const s=t.clone()._normalize(!1,!1,d);S.push(s.rings?new o(s):s)}else if(t.extent){const s=t.extent,e=c(s.xmin,U)*(2*b);let o=0===e?t.clone():p(t.clone(),e);s.offset(e,0),s.intersects(P)&&s.xmax!==b?(A=s.xmax>A?s.xmax:A,o=y(o,w),v.push(o),S.push("cut")):s.intersects(R)&&s.xmin!==U?(A=s.xmax*(2*b)>A?s.xmax*(2*b):A,o=y(o,w,360),v.push(o),S.push("cut")):S.push(o)}else S.push(t.clone());else S.push(t);else S.push(t);let L=c(A,b),z=-90;const O=L,T=new n;for(;L>0;){const t=360*L-180;T.addPath([[t,z],[t,-1*z]]),z*=-1,L--}if(v.length>0&&O>0){const t=function(t,s){let e=-1;for(let o=0;o<s.cutIndexes.length;o++){const n=s.cutIndexes[o],i=s.geometries[o],p=r(i);for(let t=0;t<p.length;t++){const s=p[t];s.some((e=>{if(e[0]<180)return!0;{let e=0;for(let t=0;t<s.length;t++){const o=s[t][0];e=o>e?o:e}e=Number(e.toFixed(9));const o=-360*c(e,180);for(let e=0;e<s.length;e++){const s=i.getPoint(t,e);i.setPoint(t,e,s.clone().offset(o,0))}return!0}}))}if(n===e){if("polygon"===t[0].type)for(const s of r(i))t[n]=t[n].addRing(s);else if("polyline"===t[0].type)for(const s of r(i))t[n]=t[n].addPath(s)}else e=n,t[n]=i}return t}(v,await h(j,v,T,m)),e=[],o=[];for(let n=0;n<S.length;n++){const r=S[n];if("cut"!==r)o.push(r);else{const r=t.shift(),i=s[n];null!=i&&"polygon"===i.type&&i.rings&&i.rings.length>1&&r.rings.length>=i.rings.length?(e.push(r),o.push("simplify")):o.push(w?u(r):r)}}if(!e.length)return o;const n=await a(j,e,m),i=[];for(let t=0;t<o.length;t++){const s=o[t];"simplify"!==s?i.push(s):i.push(w?u(n.shift()):n.shift())}return i}const q=[];for(let t=0;t<S.length;t++){const s=S[t];if("cut"!==s)q.push(s);else{const t=v.shift();q.push(!0===w?u(t):t)}}return q}function d(t){if(!t)return null;const s=t.extent;if(!s)return null;const e=t.spatialReference&&l(t.spatialReference);if(!e)return s;const[o,n]=e.valid,r=2*n,{width:i}=s;let c,{xmin:p,xmax:u}=s;if([p,u]=[u,p],"extent"===t.type||0===i||i<=n||i>r||p<o||u>n)return s;switch(t.type){case"polygon":if(!(t.rings.length>1))return s;c=j(t.rings);break;case"polyline":if(!(t.paths.length>1))return s;c=j(t.paths);break;case"multipoint":c=t.points}const m=s.clone();for(let t=0;t<c.length;t++){let s=c[t][0];s<0?(s+=n,u=Math.max(s,u)):(s-=n,p=Math.min(s,p))}return m.xmin=p,m.xmax=u,m.width<i?(m.xmin-=n,m.xmax-=n,m):s}function w(t,s){const e=l(s);if(e){const[s,o]=e.valid,n=o-s;if(t<s)for(;t<s;)t+=n;if(t>o)for(;t>o;)t-=n}return t}export{d as getDenormalizedExtent,x as normalizeCentralMeridian,w as normalizeMapX,g as straightLineDensify};
