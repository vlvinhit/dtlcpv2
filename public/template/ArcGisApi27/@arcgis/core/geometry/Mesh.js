/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.27/esri/copyright.txt for details.
*/
import{_ as e}from"../chunks/tslib.es6.js";import t from"../core/Error.js";import{HandleOwnerMixin as r}from"../core/HandleOwner.js";import o from"../core/Loadable.js";import{L as n}from"../chunks/Logger.js";import{EsriPromiseMixin as s}from"../core/Promise.js";import{whenOrAbort as i,throwIfAborted as a,eachAlwaysValues as c,isAborted as l,createAbortError as p}from"../core/promiseUtils.js";import{watch as u}from"../core/reactiveUtils.js";import{property as m}from"../core/accessorSupport/decorators/property.js";import"../chunks/ensureType.js";import"../chunks/typedArrayUtil.js";import{subclass as f}from"../core/accessorSupport/decorators/subclass.js";import{c as h,Z as g}from"../chunks/vec3f64.js";import d from"./Extent.js";import x from"./Geometry.js";import y from"./Point.js";import v from"./Polygon.js";import{c as w,a as j,b,d as A,e as k}from"../chunks/axisAngleDegrees.js";import S,{M as R}from"./support/MeshComponent.js";import M from"./support/MeshGeoreferencedRelativeVertexSpace.js";import F from"./support/MeshGeoreferencedVertexSpace.js";import L from"./support/MeshLocalVertexSpace.js";import P from"./support/MeshTransform.js";import{t as U}from"../chunks/triangulationUtils.js";import{p as O,v as C,i as E,u as z,g as T,a as _}from"../chunks/georeference.js";import{b as D,a as G,t as $,n as B,s as I,d as V,e as W}from"../chunks/vec3.js";import{projectPointToVector as N,computeTranslationToOriginAndRotation as q}from"./projection.js";import{removeFile as H,makeRelative as Z}from"../core/urlUtils.js";import{Clonable as J}from"../core/Clonable.js";import K from"../core/Collection.js";import{i as Q,e as X,a as Y}from"../chunks/External.js";import{f as ee}from"../chunks/mat3.js";import{c as te}from"../chunks/mat3f64.js";import{c as re}from"../chunks/mat4f64.js";import{g as oe}from"../chunks/spatialReferenceEllipsoidUtils.js";import{p as ne,a as se,b as ie,c as ae,d as ce,e as le}from"../chunks/projection.js";import{a as pe}from"../chunks/mat4.js";import"../core/lang.js";import"../chunks/object.js";import"../config.js";import"../chunks/string.js";import"../core/Accessor.js";import"../core/Handles.js";import"../chunks/maybe.js";import"../chunks/get.js";import"../chunks/utils.js";import"../chunks/metadata.js";import"../chunks/ObjectPool.js";import"../chunks/ObservableBase.js";import"../chunks/tracking.js";import"../chunks/watch.js";import"../chunks/ArrayPool.js";import"../core/scheduling.js";import"../chunks/nextTick.js";import"../chunks/PooledArray.js";import"../chunks/WatchUpdatingTracking.js";import"./SpatialReference.js";import"../core/JSONSupport.js";import"../chunks/unitUtils.js";import"../chunks/jsonMap.js";import"../chunks/writer.js";import"./support/webMercatorUtils.js";import"../chunks/reader.js";import"../core/accessorSupport/decorators/cast.js";import"../chunks/extentUtils.js";import"../chunks/aaBoundingRect.js";import"../chunks/mathUtils.js";import"../chunks/vec4.js";import"../chunks/common.js";import"../chunks/zmUtils.js";import"../chunks/quat.js";import"../chunks/quatf64.js";import"./support/MeshMaterial.js";import"../Color.js";import"../chunks/colorUtils.js";import"./support/MeshTexture.js";import"../chunks/imageUtils.js";import"../chunks/persistableUrlUtils.js";import"./support/MeshTextureTransform.js";import"./support/MeshMaterialMetallicRoughness.js";import"../chunks/enumeration.js";import"../chunks/earcut.js";import"../chunks/_commonjsHelpers.js";import"../chunks/DoubleArray.js";import"../chunks/Indices.js";import"../chunks/deduplicate.js";import"../chunks/vec32.js";import"../chunks/SimpleObservable.js";import"./Multipoint.js";import"../chunks/pe.js";import"../chunks/assets.js";import"../request.js";import"../kernel.js";import"./Polyline.js";import"../chunks/geodesicConstants.js";import"./support/GeographicTransformation.js";import"./support/GeographicTransformationStep.js";import"../chunks/zscale.js";import"../core/Evented.js";import"../chunks/shared.js";import"../chunks/infoFor3D.js";import"../chunks/BufferView.js";import"../chunks/vec2.js";let ue=null;function me(e,t){let r=1/0,o=1/0,n=1/0,s=-1/0,i=-1/0,a=-1/0;const c=e.length;let l=0;for(;l<c;){const t=e[l++],c=e[l++],p=e[l++];r=Math.min(r,t),o=Math.min(o,c),n=Math.min(n,p),s=Math.max(s,t),i=Math.max(i,c),a=Math.max(a,p)}return new d({xmin:r,ymin:o,zmin:n,xmax:s,ymax:i,zmax:a,spatialReference:t})}const fe="esri.geometry.support.meshUtils.centerAt",he=h(),ge=h(),de=h();function xe(e){const t=H(e.url);return r=>{const o=Z(r,t,t),n=o?o.replace(/^ *\.\//,""):null;return(n?e.files.get(n):null)??r}}function ye(e){return be.fromBlob(e)}const ve=/^(model\/gltf\+json)|(model\/gltf-binary)$/,we=/\.(gltf|glb)/i;function je(e){const r=new Map;let o=null;for(const{name:t,mimeType:n,source:s}of e)(null==o||ve.test(n)||we.test(t))&&(o=s.url),r.set(t,s.url),s.files.forEach(((e,t)=>r.set(t,e)));if(null==o)throw new t("mesh-load-external:missing-files","Missing files to load external mesh source");return new be(o,(()=>e.forEach((({source:e})=>e.dispose()))),r)}class be{constructor(e,t=(()=>{}),r=new Map){this.url=e,this.dispose=t,this.files=r}static fromBlob(e){const t=URL.createObjectURL(e);return new be(t,(()=>URL.revokeObjectURL(t)))}}let Ae=class extends J{constructor(){super(),this.externalSources=new K,this._explicitDisplaySource=null}get displaySource(){return this._explicitDisplaySource??this._implicitDisplaySource}set displaySource(e){if(null!=e&&!Q(e))throw new Error("Cannot use this source for display: it is not in a supported format.");this._explicitDisplaySource=e,e&&this.externalSources.every((t=>!X(t,e)))&&this.externalSources.add(e)}clearSources(){this.displaySource=null,this.externalSources.removeAll()}getExternalSourcesOnService(e){return this.externalSources.items.filter((t=>Y(t,e)))}get _implicitDisplaySource(){return this.externalSources.find(Q)}};function ke(e,t){if(e)for(let r=0;r<e.length;r+=3)for(let o=0;o<3;o++)e[r+o]+=t[o]}e([m()],Ae.prototype,"externalSources",void 0),e([m()],Ae.prototype,"displaySource",null),e([m()],Ae.prototype,"_implicitDisplaySource",null),e([m()],Ae.prototype,"_explicitDisplaySource",void 0),Ae=e([f("esri.geometry.support.meshUtils.Metadata")],Ae);const Se=h(),Re=re(),Me=te(),Fe={position:[-.5,-.5,0,.5,-.5,0,.5,.5,0,-.5,.5,0],normal:[0,0,1,0,0,1,0,0,1,0,0,1],uv:[0,1,1,1,1,0,0,0],faces:[0,1,2,0,2,3],facingAxisOrderSwap:{east:[3,1,2],west:[-3,-1,2],north:[-1,3,2],south:[1,-3,2],up:[1,2,3],down:[1,-2,-3]}};function Le(e,t,r){e.isPlane||function(e){for(let t=0;t<e.position.length;t+=3)e.position[t+2]+=.5}(e),function(e,t){if(null==t)return;const r="number"==typeof t?[t,t,t]:[null!=t.width?t.width:1,null!=t.depth?t.depth:1,null!=t.height?t.height:1];Ce[0]=r[0],Ce[4]=r[1],Ce[8]=r[2];for(let t=0;t<e.position.length;t+=3){for(let r=0;r<3;r++)Oe[r]=e.position[t+r];$(Oe,Oe,Ce);for(let r=0;r<3;r++)e.position[t+r]=Oe[r]}if(r[0]!==r[1]||r[1]!==r[2]){Ce[0]=1/r[0],Ce[4]=1/r[1],Ce[8]=1/r[2];for(let t=0;t<e.normal.length;t+=3){for(let r=0;r<3;r++)Oe[r]=e.normal[t+r];$(Oe,Oe,Ce),B(Oe,Oe);for(let r=0;r<3;r++)e.normal[t+r]=Oe[r]}}}(e,r?.size);const{vertexAttributes:o,vertexSpace:n,transform:s}=_(e,t,r);return{vertexAttributes:new R({...o,uv:e.uv}),vertexSpace:n,transform:s,components:[new S({faces:e.faces,material:r&&r.material||null})],spatialReference:t.spatialReference}}const Pe={faceDescriptions:[{axis:[0,-1,0],uvOrigin:[0,.625],corners:[[-1,-1],[1,-1],[1,1],[-1,1]]},{axis:[1,0,0],uvOrigin:[.25,.625],corners:[[-1,-1],[1,-1],[1,1],[-1,1]]},{axis:[0,1,0],uvOrigin:[.5,.625],corners:[[1,-1],[-1,-1],[-1,1],[1,1]]},{axis:[-1,0,0],uvOrigin:[.75,.625],corners:[[1,-1],[-1,-1],[-1,1],[1,1]]},{axis:[0,0,1],uvOrigin:[0,.375],corners:[[-1,-1],[1,-1],[1,1],[-1,1]]},{axis:[0,0,-1],uvOrigin:[0,.875],corners:[[-1,1],[1,1],[1,-1],[-1,-1]]}],uvScales:[[0,0],[1,0],[1,1],[0,1]],faceVertexOffsets:[0,1,2,0,2,3]},Ue={south:0,east:1,north:2,west:3,up:4,down:5},Oe=h(),Ce=te(),Ee="esri.geometry.support.meshUtils.rotate";function ze(e,t,r,o=g){if(null!=e){pe(Ge,b(t),A(t));for(let t=0;t<e.length;t+=r){for(let r=0;r<3;r++)Te[r]=e[t+r]-o[r];V(Te,Te,Ge);for(let r=0;r<3;r++)e[t+r]=Te[r]+o[r]}}}const Te=h(),_e=h(),De=w(),Ge=re(),$e=te(),Be=h(),Ie="esri.geometry.support.meshUtils.scale";function Ve(e,t,r=g){if(e)for(let o=0;o<e.length;o+=3){for(let t=0;t<3;t++)We[t]=e[o+t]-r[t];W(We,We,t);for(let t=0;t<3;t++)e[o+t]=We[t]+r[t]}}const We=h(),Ne=h(),qe=h();var He;const Ze="esri.geometry.Mesh",Je={base:null,key:"type",defaultKeyValue:"georeferenced",typeMap:{georeferenced:F,"georeferenced-relative":M,local:L}};let Ke=He=class extends(r(o.LoadableMixin(s(x)))){constructor(e){super(e),this.components=null,this.vertexSpace=new F,this.transform=null,this.metadata=new Ae,this.hasZ=!0,this.hasM=!1,this.vertexAttributes=new R,this.type="mesh"}initialize(){(0===this.metadata.externalSources.length||this.vertexAttributes.position.length)&&(this.loadStatus="loaded"),this.when((()=>{this.handles.add(u((()=>({vertexAttributes:this.vertexAttributes,components:this.components?.map((e=>e.clone()))})),(()=>this._clearSources()),{once:!0,sync:!0}))}))}get hasExtent(){return this.loaded?this.vertexAttributes.position.length>0&&(!this.components||this.components.length>0):null!=this.metadata.displaySource?.extent}get _transformedExtent(){const{components:e,spatialReference:t,vertexAttributes:r,vertexSpace:o}=this,n=r.position;if(0===n.length||e&&0===e.length)return new d({xmin:0,ymin:0,zmin:0,xmax:0,ymax:0,zmax:0,spatialReference:t});if("local"===o.type){const{_untransformedExtent:e,transform:r}=this;return function({xmin:e,xmax:t,ymin:r,ymax:o,zmin:n,zmax:s},i,a,c){n??=0,s??=0,ue??=new Float64Array(24);const l=ue;return l[0]=e,l[1]=r,l[2]=n,l[3]=e,l[4]=o,l[5]=n,l[6]=t,l[7]=o,l[8]=n,l[9]=t,l[10]=r,l[11]=n,l[12]=e,l[13]=r,l[14]=s,l[15]=e,l[16]=o,l[17]=s,l[18]=t,l[19]=o,l[20]=s,l[21]=t,l[22]=r,l[23]=s,O({positions:l,transform:i,vertexSpace:a,inSpatialReference:c,outSpatialReference:c,outPositions:l,local:!1}),me(l,c)}(e,r,o,t)}if("georeferenced-relative"===o.type){const{transform:e}=this;return me(O({positions:n,transform:e,vertexSpace:o,inSpatialReference:t,outSpatialReference:t,local:!1}),t)}return me(n,t)}get _untransformedExtent(){return me(this.vertexAttributes.position,this.spatialReference)}get anchor(){const{vertexSpace:e}=this;if(e.isRelative)return e.getOriginPoint(this.spatialReference);const{center:t,zmin:r}=this._transformedExtent;return new y({x:t.x,y:t.y,z:r,spatialReference:this.spatialReference})}get origin(){const{vertexSpace:e}=this;return e.isRelative?e.getOriginPoint(this.spatialReference):this._transformedExtent.center}get extent(){return this.loaded||null==this.metadata?.displaySource?.extent?this._transformedExtent:this.metadata.displaySource.extent.clone()}addComponent(e){this.loaded?(this.components||(this.components=[]),this.components.push(S.from(e)),this.notifyChange("components")):n.getLogger(this).error("addComponent()","Mesh must be loaded before applying operations")}removeComponent(e){if(this.loaded){if(this.components){const t=this.components.indexOf(e);if(-1!==t)return this.components.splice(t,1),void this.notifyChange("components")}n.getLogger(this).error("removeComponent()","Provided component is not part of the list of components")}else n.getLogger(this).error("removeComponent()","Mesh must be loaded before applying operations")}rotate(e,t,r,o){return k(e,t,r,Xe),function(e,t,r){if(!e.vertexAttributes||!e.vertexAttributes.position||0===t[3])return;const{spatialReference:o,vertexSpace:s}=e;if(s.isRelative){C(s,Ee,r);const o=r?.origin??e.origin;e.transform??=new P,function(e,t,r,o){const n=t.origin,s=I(Te,o.x,o.y,o.z??0),i=D(Te,s,n);e.applyLocalInverse(i,_e),e.rotation=j(e.rotation,r,w()),e.applyLocalInverse(i,i),D(i,i,_e),e.translation=G(h(),e.translation,i)}(e.transform,s,t,o)}else{const s=r?.origin??e.origin;E(o,r)?function(e,t,r){const o=e.spatialReference,n=oe(o),s=Be;N(r,s,n)||N(e.origin,s,n);const i=e.vertexAttributes.position,a=e.vertexAttributes.normal,c=e.vertexAttributes.tangent,l=new Float64Array(i.length),p=null!=a?new Float32Array(a.length):null,u=null!=c?new Float32Array(c.length):null;q(n,s,Ge,n),ee($e,Ge);const m=De;$(A(De),A(t),$e),m[3]=t[3],ne(i,o,l),null!=a&&null!=p&&se(a,i,l,o,p),null!=c&&null!=u&&ie(c,i,l,o,u),ze(l,m,3,s),ae(l,i,o),null!=a&&null!=p&&(ze(p,m,3),ce(p,i,l,o,a)),null!=c&&null!=u&&(ze(u,m,4),le(u,i,l,o,c)),e.vertexAttributesChanged()}(e,t,s):function(e,t,r){const o=Be;if(!N(r,o,e.spatialReference)){const t=e.origin;o[0]=t.x,o[1]=t.y,o[2]=t.z,n.getLogger(Ee).error(`Failed to project specified origin (wkid:${r.spatialReference.wkid}) to mesh spatial reference (wkid:${e.spatialReference.wkid}). Projection may be possible after calling projection.load().`)}ze(e.vertexAttributes.position,t,3,o),ze(e.vertexAttributes.normal,t,3),ze(e.vertexAttributes.tangent,t,4),e.vertexAttributesChanged()}(e,t,s)}}(this,Xe,o),this}offset(e,t,r,o){return this.loaded?(Qe[0]=e,Qe[1]=t,Qe[2]=r,function(e,t,r){if(!e.vertexAttributes||!e.vertexAttributes.position)return;const{vertexSpace:o}=e;o.isRelative?(C(o,"esri.geometry.support.meshUtils.offset",r),function(e,t){const r=e.origin;e.origin=G(h(),r,t)}(o,t)):E(e.spatialReference,r)?function(e,t){const r=e.spatialReference,o=e.vertexAttributes.position,n=e.vertexAttributes.normal,s=e.vertexAttributes.tangent,i=new Float64Array(o.length),a=null!=n?new Float32Array(n.length):null,c=null!=s?new Float32Array(s.length):null,l=e.extent.center,p=Se;q(r,[l.x,l.y,l.z],Re,oe(r)),ee(Me,Re),$(p,t,Me),ne(o,r,i),null!=n&&null!=a&&se(n,o,i,r,a),null!=s&&null!=c&&ie(s,o,i,r,c),ke(i,p),ae(i,o,r),null!=n&&null!=a&&ce(a,o,i,r,n),null!=s&&null!=c&&le(c,o,i,r,s),e.vertexAttributesChanged()}(e,t):function(e,t){ke(e.vertexAttributes.position,t),e.vertexAttributesChanged()}(e,t)}(this,Qe,o),this):(n.getLogger(this).error("offset()","Mesh must be loaded before applying operations"),this)}scale(e,t){return this.loaded?(function(e,t,r){if(!e.vertexAttributes||!e.vertexAttributes.position)return;const{spatialReference:o,vertexSpace:s}=e;if(s.isRelative){C(s,Ie,r);const o=r?.origin??e.origin;e.transform??=new P,function(e,t,r,o){const n=t.origin,s=I(We,o.x,o.y,o.z),i=D(We,s,n);e.applyLocalInverse(i,Ne);const a=W(h(),e.scale,r);e.scale=a,e.applyLocalInverse(i,i),D(i,i,Ne),e.translation=G(h(),e.translation,i)}(e.transform,s,t,o)}else{const s=E(o,r),i=r?.origin??e.origin;s?function(e,t,r){const o=e.spatialReference,n=oe(o),s=qe;N(r,s,n)||N(e.origin,s,n);const i=e.vertexAttributes.position,a=e.vertexAttributes.normal,c=e.vertexAttributes.tangent,l=new Float64Array(i.length),p=null!=a?new Float32Array(a.length):null,u=null!=c?new Float32Array(c.length):null;ne(i,o,l),null!=a&&null!=p&&se(a,i,l,o,p),null!=c&&null!=u&&ie(c,i,l,o,u),Ve(l,t,s),ae(l,i,o),null!=a&&null!=p&&ce(p,i,l,o,a),null!=c&&null!=u&&le(u,i,l,o,c),e.vertexAttributesChanged()}(e,t,i):function(e,t,r){const o=qe;if(!N(r,o,e.spatialReference)){const t=e.origin;o[0]=t.x,o[1]=t.y,o[2]=t.z,n.getLogger(Ie).error(`Failed to project specified origin (wkid:${r.spatialReference.wkid}) to mesh spatial reference (wkid:${e.spatialReference.wkid}). Projection may be possible after calling projection.load().`)}Ve(e.vertexAttributes.position,t,o),e.vertexAttributesChanged()}(e,t,i)}}(this,e,t),this):(n.getLogger(this).error("scale()","Mesh must be loaded before applying operations"),this)}centerAt(e,t){return this.loaded?(function(e,t,r){if(!e.vertexAttributes||!e.vertexAttributes.position)return;const{vertexSpace:o}=e,s=r?.origin??e.origin;o.isRelative?(C(o,fe,r),function(e,t,r){const{vertexSpace:o}=e;if(!o.isRelative)return;const s=ge,i=he;if(!N(t,i,e.spatialReference))return void n.getLogger(fe).error(`Failed to project centerAt location (wkid:${t.spatialReference.wkid}) to mesh spatial reference (wkid:${e.spatialReference.wkid}). Projection may be possible after calling projection.load().`);if(!N(r,s,e.spatialReference)){const t=e.origin;s[0]=t.x,s[1]=t.y,s[2]=t.z,n.getLogger(fe).error(`Failed to project specified origin (wkid:${r.spatialReference.wkid}) to mesh spatial reference (wkid:${e.spatialReference.wkid}). Projection may be possible after calling projection.load().`)}const a=D(de,i,s),c=o.origin;o.origin=G(h(),c,a)}(e,t,s)):E(e.spatialReference,r)?function(e,t,r){const o=z(e.vertexAttributes,r,{geographic:!0}),{position:n,normal:s,tangent:i}=T(o,t,{geographic:!0});e.vertexAttributes.position=n,e.vertexAttributes.normal=s,e.vertexAttributes.tangent=i,e.vertexAttributesChanged()}(e,t,s):function(e,t,r){const o=ge,s=he;if(N(t,s,e.spatialReference)){if(!N(r,o,e.spatialReference)){const t=e.origin;o[0]=t.x,o[1]=t.y,o[2]=t.z,n.getLogger(fe).error(`Failed to project specified origin (wkid:${r.spatialReference.wkid}) to mesh spatial reference (wkid:${e.spatialReference.wkid}). Projection may be possible after calling projection.load().`)}(function(e,t,r){if(e)for(let o=0;o<e.length;o+=3)for(let n=0;n<3;n++)e[o+n]+=t[n]-r[n]})(e.vertexAttributes.position,s,o),e.vertexAttributesChanged()}else n.getLogger(fe).error(`Failed to project centerAt location (wkid:${t.spatialReference.wkid}) to mesh spatial reference (wkid:${e.spatialReference.wkid}). Projection may be possible after calling projection.load().`)}(e,t,s)}(this,e,t),this):(n.getLogger(this).error("centerAt()","Mesh must be loaded before applying operations"),this)}load(e){const{metadata:{displaySource:r}}=this;return r&&this.addResolvingPromise(async function(e,r,o){const{source:n}=r,{loadGLTFMesh:s}=await i(import("../chunks/loadGLTFMesh.js"),o),u=await async function(e,r){if(Array.isArray(e)){if(!e.length)throw new t("mesh-load-external:missing-assets","There must be at least one file to load");return e[0]instanceof File?je(e.map((e=>({name:e.name,mimeType:e.type,source:ye(e)})))):async function(e,t){const r=await c(e.map((async e=>{const r=await async function(e,t){const{parts:r}=e;if(1===r.length)return new be(r[0].partUrl);const o=await e.toBlob(t);return a(t),be.fromBlob(o)}(e);return a(t),{name:e.assetName,mimeType:e.assetMimeType,source:r}})));if(l(t))throw r.forEach((e=>e.source.dispose())),p();return je(r)}(e,r)}return ye(e)}(n,o);a(o);const m=s(new y({x:0,y:0,z:0,spatialReference:e.spatialReference}),u.url,{resolveFile:xe(u),useTransform:!0,signal:o?.signal});m.then((()=>u.dispose()),(()=>u.dispose()));const{vertexAttributes:f,components:h}=await m;e.vertexAttributes=f,e.components=h}(this,r,e)),Promise.resolve(this)}addExternalSources(e){this.metadata.externalSources.addMany(e)}updateDisplaySource(e){this.metadata.displaySource=e}clone(){return this.cloneWithVertexSpace(this.vertexSpace.clone())}cloneWithVertexSpace(e){let t=null;if(this.components){const e=new Map,r=new Map;t=this.components.map((t=>t.cloneWithDeduplication(e,r)))}const r={components:t,spatialReference:this.spatialReference,vertexAttributes:this.vertexAttributes.clone(),vertexSpace:e,transform:this.transform?.clone()??null,metadata:this.metadata.clone()};return new He(r)}cloneShallow(){return new He({components:this.components,spatialReference:this.spatialReference,vertexAttributes:this.vertexAttributes,vertexSpace:this.vertexSpace.clone(),transform:this.transform,metadata:this.metadata})}vertexAttributesChanged(){this.notifyChange("vertexAttributes")}async toBinaryGLTF(e){const t=import("../chunks/gltfexport.js"),r=this.load(),o=await Promise.all([t,r]),{toBinaryGLTF:n}=o[0];return n(this,e)}get memoryUsage(){let e=0;if(e+=this.vertexAttributes.memoryUsage,null!=this.components)for(const t of this.components)e+=t.memoryUsage;return e}_clearSources(){this.metadata.clearSources()}static createBox(e,t){if(!(e instanceof y))return n.getLogger(Ze).error(".createBox()","expected location to be a Point instance"),null;const r=new He(Le(function(){const{faceDescriptions:e,faceVertexOffsets:t,uvScales:r}=Pe,o=4*e.length,n=new Float64Array(3*o),s=new Float32Array(3*o),i=new Float32Array(2*o),a=new Uint32Array(2*e.length*3);let c=0,l=0,p=0,u=0;for(let o=0;o<e.length;o++){const m=e[o],f=c/3;for(const e of t)a[u++]=f+e;const h=m.corners;for(let e=0;e<4;e++){const t=h[e];let o=0;i[p++]=.25*r[e][0]+m.uvOrigin[0],i[p++]=m.uvOrigin[1]-.25*r[e][1];for(let e=0;e<3;e++)0!==m.axis[e]?(n[c++]=.5*m.axis[e],s[l++]=m.axis[e]):(n[c++]=.5*t[o++],s[l++]=0)}}return{position:n,normal:s,uv:i,faces:a}}(),e,t));return t&&t.imageFace&&"all"!==t.imageFace?function(e,t){const r=e.components[0],o=r.faces,n=Ue[t],s=6*n,i=new Array(6),a=new Array(o.length-6);let c=0,l=0;for(let e=0;e<o.length;e++)e>=s&&e<s+6?i[c++]=o[e]:a[l++]=o[e];if(null!=e.vertexAttributes.uv){const t=new Float32Array(e.vertexAttributes.uv),r=4*n*2,o=[0,1,1,1,1,0,0,0];for(let e=0;e<o.length;e++)t[r+e]=o[e];e.vertexAttributes.uv=t}return e.components=[new S({faces:i,material:r.material}),new S({faces:a})],e}(r,t.imageFace):r}static createSphere(e,t){return e instanceof y?new He(Le(function(e=0){const t=Math.round(8*2**e),r=2*t,o=(t-1)*(r+1)+2*r,n=new Float64Array(3*o),s=new Float32Array(3*o),i=new Float32Array(2*o),a=new Uint32Array((t-1)*r*2*3);let c=0,l=0,p=0,u=0;for(let e=0;e<=t;e++){const o=e/t*Math.PI+.5*Math.PI,m=Math.cos(o),f=Math.sin(o);Oe[2]=f;const h=0===e||e===t,g=h?r-1:r;for(let o=0;o<=g;o++){const f=o/g*2*Math.PI;Oe[0]=-Math.sin(f)*m,Oe[1]=Math.cos(f)*m;for(let e=0;e<3;e++)n[c]=.5*Oe[e],s[c]=Oe[e],++c;i[l++]=(o+(h?.5:0))/r,i[l++]=e/t,0!==e&&o!==r&&(e!==t&&(a[p++]=u,a[p++]=u+1,a[p++]=u-r),1!==e&&(a[p++]=u,a[p++]=u-r,a[p++]=u-r-1)),u++}}return{position:n,normal:s,uv:i,faces:a}}(t&&t.densificationFactor||0),e,t)):(n.getLogger(Ze).error(".createSphere()","expected location to be a Point instance"),null)}static createCylinder(e,t){return e instanceof y?new He(Le(function(e=0){const t=Math.round(16*2**e),r=4*(t+1)+2*t,o=new Float64Array(3*r),n=new Float32Array(3*r),s=new Float32Array(2*r),i=new Uint32Array(4*t*3);let a=0,c=0,l=0,p=0,u=0;for(let e=0;e<=5;e++){const r=0===e||5===e,m=e<=1||e>=4,f=2===e||4===e,h=r?t-1:t;for(let g=0;g<=h;g++){const d=g/h*2*Math.PI,x=r?0:.5;Oe[0]=x*Math.sin(d),Oe[1]=x*-Math.cos(d),Oe[2]=e<=2?.5:-.5;for(let t=0;t<3;t++)o[a++]=Oe[t],n[c++]=m?2===t?e<=1?1:-1:0:2===t?0:Oe[t]/x;s[l++]=(g+(r?.5:0))/t,s[l++]=e<=1?1*e/3:e<=3?1*(e-2)/3+1/3:1*(e-4)/3+2/3,f||0===e||g===t||(5!==e&&(i[p++]=u,i[p++]=u+1,i[p++]=u-t),1!==e&&(i[p++]=u,i[p++]=u-t,i[p++]=u-t-1)),u++}}return{position:o,normal:n,uv:s,faces:i}}(t&&t.densificationFactor||0),e,t)):(n.getLogger(Ze).error(".createCylinder()","expected location to be a Point instance"),null)}static createPlane(e,t){if(!(e instanceof y))return n.getLogger(Ze).error(".createPlane()","expected location to be a Point instance"),null;const r=t?.facing??"up",o=function(e,t){const r="number"==typeof t?t:null!=t?t.width:1,o="number"==typeof t?t:null!=t?t.height:1;switch(e){case"up":case"down":return{width:r,depth:o};case"north":case"south":return{width:r,height:o};case"east":case"west":return{depth:r,height:o}}}(r,t?.size);return new He(Le(function(e){const t=Fe.facingAxisOrderSwap[e],r=Fe.position,o=Fe.normal,n=new Float64Array(r.length),s=new Float32Array(o.length);let i=0;for(let e=0;e<4;e++){const e=i;for(let a=0;a<3;a++){const c=t[a],l=Math.abs(c)-1,p=c>=0?1:-1;n[i]=r[e+l]*p,s[i]=o[e+l]*p,i++}}return{position:n,normal:s,uv:new Float32Array(Fe.uv),faces:new Uint32Array(Fe.faces),isPlane:!0}}(r),e,{...t,size:o}))}static createFromPolygon(e,t){if(!(e instanceof v))return n.getLogger(Ze).error(".createFromPolygon()","expected polygon to be a Polygon instance"),null;const r=U(e);return new He({vertexAttributes:new R({position:r.position}),components:[new S({faces:r.faces,shading:"flat",material:t?.material??null})],spatialReference:e.spatialReference,vertexSpace:new F})}static async createFromGLTF(e,r,o){if(!(e instanceof y))throw n.getLogger(Ze).error(".createfromGLTF()","expected location to be a Point instance"),new t("invalid-input","Expected location to be a Point instance");const{loadGLTFMesh:s}=await i(import("../chunks/loadGLTFMesh.js"),o);return new He(await s(e,r,o))}static async createFromFiles(e,r,o){if(!(e instanceof y)){const e="Expected location to be a Point instance";throw n.getLogger(Ze).error(".createFromFiles()",e),new t("invalid-input",e)}const s=He.createWithExternalSource(e,r),i=o?.layer;if(!i){const e="A layer is needed to convert the files";throw n.getLogger(Ze).error(".createFromFiles()",e),new t("invalid-input",e)}const[a]=await i.uploadAssets([s],o);return a}static createWithExternalSource(e,t,r){const o=r?.extent??null,{x:n,y:s,z:i,spatialReference:a}=e,c=r?.transform?.clone()??new P,l=r?.vertexSpace??new L({origin:[n,s,i??0]}),p={source:t,extent:o},u=new Ae;return u.externalSources.push(p),new He({metadata:u,transform:c,vertexSpace:l,spatialReference:a})}static createIncomplete(e,r){const{x:o,y:n,z:s,spatialReference:i}=e,a=r?.transform?.clone()??new P,c=r?.vertexSpace??new L({origin:[o,n,s??0]}),l=new He({transform:a,vertexSpace:c,spatialReference:i});return l.addResolvingPromise(Promise.reject(new t("mesh-incomplete","Mesh resources are not complete"))),l}};e([m({type:[S],json:{write:!0}})],Ke.prototype,"components",void 0),e([m({nonNullable:!0,types:Je,constructOnly:!0,json:{write:!0}})],Ke.prototype,"vertexSpace",void 0),e([m({type:P,json:{write:!0}})],Ke.prototype,"transform",void 0),e([m({constructOnly:!0})],Ke.prototype,"metadata",void 0),e([m()],Ke.prototype,"hasExtent",null),e([m()],Ke.prototype,"_transformedExtent",null),e([m()],Ke.prototype,"_untransformedExtent",null),e([m()],Ke.prototype,"anchor",null),e([m()],Ke.prototype,"origin",null),e([m({readOnly:!0,json:{read:!1}})],Ke.prototype,"extent",null),e([m({readOnly:!0,json:{read:!1,write:!0,default:!0}})],Ke.prototype,"hasZ",void 0),e([m({readOnly:!0,json:{read:!1,write:!0,default:!1}})],Ke.prototype,"hasM",void 0),e([m({type:R,nonNullable:!0,json:{write:!0}})],Ke.prototype,"vertexAttributes",void 0),Ke=He=e([f(Ze)],Ke);const Qe=h(),Xe=w(),Ye=Ke;export{Ye as default};
