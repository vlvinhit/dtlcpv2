/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.27/esri/copyright.txt for details.
*/
import{_ as t}from"../../chunks/tslib.es6.js";import"../../geometry.js";import{rasterRendererTypes as e,websceneRasterRendererTypes as s,read as r}from"../../rasterRenderers.js";import i from"../../request.js";import o from"../../core/Error.js";import{L as n}from"../../chunks/Logger.js";import{property as a}from"../../core/accessorSupport/decorators/property.js";import{m as l}from"../../chunks/ensureType.js";import"../../chunks/typedArrayUtil.js";import{r as m}from"../../chunks/reader.js";import{subclass as c}from"../../core/accessorSupport/decorators/subclass.js";import{g as p,h as u}from"../../chunks/unitUtils.js";import{s as h}from"../../chunks/arcgisLayerUrl.js";import{u as d}from"../../chunks/commonProperties2.js";import f from"../support/DimensionalDefinition.js";import y from"../support/MultidimensionalSubset.js";import x from"../support/RasterFunction.js";import{R as g}from"../../chunks/RasterJobHandler.js";import b from"../support/TileInfo.js";import{JSONSupport as j}from"../../core/JSONSupport.js";import{u as k}from"../../chunks/maybe.js";import{EsriPromiseMixin as I}from"../../core/Promise.js";import{onAbort as R}from"../../core/promiseUtils.js";import S from"../support/LOD.js";import{R as w}from"../support/RasterInfo.js";import{b as v,c as T,d as M,e as F,a as _,h as P,f as D,g as C}from"../../chunks/multidimensionalUtils.js";import{g as J,a as H,p as B,d as O,b as U}from"../../chunks/RawBlockCache.js";import{c as z}from"../../chunks/pixelRangeUtils.js";import{d as E,R as L}from"../../chunks/RasterSymbolizer.js";import{m as A,h as N,j as W,k as V,u as q,d as G}from"../../chunks/vectorFieldUtils.js";import{l as $,g as Q,p as K,s as X,a as Y,b as Z,c as tt,d as et,e as st,f as rt,h as it}from"../../chunks/rasterProjectionHelper.js";import ot from"../../geometry/Extent.js";import nt from"../../geometry/Point.js";import at from"../../rest/support/FeatureSet.js";import lt from"../support/PixelBlock.js";import{c as mt}from"../../chunks/rasterFunctionHelper.js";import{f as ct}from"../../chunks/stretchUtils.js";import{n as pt,b as ut,d as ht,a as dt,c as ft}from"../../chunks/rasterRendererHelper.js";import yt from"../../rest/support/ImageHistogramParameters.js";import{c as xt}from"../../chunks/dataUtils.js";import gt from"../../geometry/SpatialReference.js";import"../../geometry/Geometry.js";import"../../core/Accessor.js";import"../../core/Handles.js";import"../../chunks/get.js";import"../../chunks/utils.js";import"../../core/lang.js";import"../../chunks/metadata.js";import"../../chunks/ObjectPool.js";import"../../chunks/ObservableBase.js";import"../../chunks/tracking.js";import"../../chunks/watch.js";import"../../chunks/ArrayPool.js";import"../../core/scheduling.js";import"../../chunks/nextTick.js";import"../../chunks/PooledArray.js";import"../../config.js";import"../../chunks/object.js";import"../../chunks/string.js";import"../../chunks/jsonMap.js";import"../../chunks/writer.js";import"../../geometry/Multipoint.js";import"../../chunks/zmUtils.js";import"../../geometry/support/webMercatorUtils.js";import"../../core/accessorSupport/decorators/cast.js";import"../../geometry/Polygon.js";import"../../chunks/extentUtils.js";import"../../chunks/aaBoundingRect.js";import"../../chunks/mathUtils.js";import"../../chunks/vec3.js";import"../../chunks/vec3f64.js";import"../../chunks/common.js";import"../../chunks/vec4.js";import"../../geometry/Polyline.js";import"../../chunks/typeUtils.js";import"../../geometry/support/jsonUtils.js";import"../../renderers/ClassBreaksRenderer.js";import"../../symbols.js";import"../../symbols/CIMSymbol.js";import"../../chunks/enumeration.js";import"../support/fieldUtils.js";import"../../chunks/arcadeOnDemand.js";import"../../symbols/Symbol.js";import"../../Color.js";import"../../chunks/colorUtils.js";import"../../symbols/ExtrudeSymbol3DLayer.js";import"../../symbols/Symbol3DLayer.js";import"../../chunks/utils2.js";import"../../symbols/edges/Edges3D.js";import"../../chunks/screenUtils.js";import"../../chunks/materialUtils.js";import"../../chunks/opacityUtils.js";import"../../symbols/edges/SketchEdges3D.js";import"../../symbols/edges/SolidEdges3D.js";import"../../chunks/Symbol3DMaterial.js";import"../../symbols/FillSymbol.js";import"../../symbols/SimpleLineSymbol.js";import"../../symbols/LineSymbol.js";import"../../symbols/LineSymbolMarker.js";import"../../chunks/lineMarkers.js";import"../../symbols/FillSymbol3DLayer.js";import"../../symbols/patterns/LineStylePattern3D.js";import"../../symbols/patterns/StylePattern3D.js";import"../../chunks/utils3.js";import"../../chunks/colors.js";import"../../chunks/symbolLayerUtils3D.js";import"../../chunks/aaBoundingBox.js";import"../../symbols/Font.js";import"../../symbols/IconSymbol3DLayer.js";import"../../core/urlUtils.js";import"../../chunks/persistableUrlUtils.js";import"../../symbols/LabelSymbol3D.js";import"../../core/Collection.js";import"../../core/Evented.js";import"../../chunks/shared.js";import"../../chunks/SimpleObservable.js";import"../../symbols/Symbol3D.js";import"../../chunks/collectionUtils.js";import"../../portal/Portal.js";import"../../kernel.js";import"../../core/Loadable.js";import"../../chunks/locale.js";import"../../portal/PortalQueryParams.js";import"../../portal/PortalQueryResult.js";import"../../portal/PortalUser.js";import"../../portal/PortalFolder.js";import"../../portal/PortalGroup.js";import"../../symbols/LineSymbol3DLayer.js";import"../../symbols/LineStyleMarker3D.js";import"../../core/Clonable.js";import"../../symbols/ObjectSymbol3DLayer.js";import"../../symbols/PathSymbol3DLayer.js";import"../../symbols/TextSymbol3DLayer.js";import"../../symbols/WaterSymbol3DLayer.js";import"../../symbols/support/StyleOrigin.js";import"../../chunks/Thumbnail.js";import"../../chunks/calloutUtils.js";import"../../symbols/callouts/Callout3D.js";import"../../symbols/callouts/LineCallout3D.js";import"../../symbols/support/Symbol3DVerticalOffset.js";import"../../symbols/LineSymbol3D.js";import"../../symbols/MarkerSymbol.js";import"../../symbols/MeshSymbol3D.js";import"../../symbols/PictureFillSymbol.js";import"../../chunks/urlUtils.js";import"../../symbols/PictureMarkerSymbol.js";import"../../symbols/PointSymbol3D.js";import"../../symbols/PolygonSymbol3D.js";import"../../symbols/SimpleFillSymbol.js";import"../../symbols/SimpleMarkerSymbol.js";import"../../symbols/TextSymbol.js";import"../../symbols/WebStyleSymbol.js";import"../../renderers/Renderer.js";import"../../renderers/support/AuthoringInfo.js";import"../../renderers/support/AuthoringInfoVisualVariable.js";import"../../chunks/colorRamps.js";import"../../rest/support/AlgorithmicColorRamp.js";import"../../rest/support/ColorRamp.js";import"../../rest/support/MultipartColorRamp.js";import"../../renderers/mixins/VisualVariablesMixin.js";import"../../renderers/visualVariables/ColorVariable.js";import"../../renderers/visualVariables/VisualVariable.js";import"../../chunks/LegendOptions.js";import"../../renderers/visualVariables/support/ColorStop.js";import"../../renderers/visualVariables/OpacityVariable.js";import"../../renderers/visualVariables/support/OpacityStop.js";import"../../renderers/visualVariables/RotationVariable.js";import"../../renderers/visualVariables/SizeVariable.js";import"../../renderers/visualVariables/support/SizeStop.js";import"../../chunks/visualVariableUtils.js";import"../../Graphic.js";import"../../PopupTemplate.js";import"../../popup/content.js";import"../../popup/content/AttachmentsContent.js";import"../../popup/content/Content.js";import"../../popup/content/CustomContent.js";import"../../popup/content/ExpressionContent.js";import"../../popup/ElementExpressionInfo.js";import"../../popup/content/FieldsContent.js";import"../../popup/FieldInfo.js";import"../../popup/support/FieldInfoFormat.js";import"../../chunks/date.js";import"../../chunks/datetime.js";import"../../chunks/number.js";import"../../popup/content/MediaContent.js";import"../../popup/content/BarChartMediaInfo.js";import"../../popup/content/mixins/ChartMediaInfo.js";import"../../popup/content/mixins/MediaInfo.js";import"../../popup/content/support/ChartMediaInfoValue.js";import"../../popup/content/support/ChartMediaInfoValueSeries.js";import"../../chunks/chartMediaInfoUtils.js";import"../../popup/content/ColumnChartMediaInfo.js";import"../../popup/content/ImageMediaInfo.js";import"../../popup/content/support/ImageMediaInfoValue.js";import"../../popup/content/LineChartMediaInfo.js";import"../../popup/content/PieChartMediaInfo.js";import"../../popup/content/RelationshipContent.js";import"../../popup/support/RelatedRecordsInfoFieldOrder.js";import"../../popup/content/TextContent.js";import"../../popup/ExpressionInfo.js";import"../../popup/LayerOptions.js";import"../../popup/RelatedRecordsInfo.js";import"../../support/actions/ActionBase.js";import"../../core/Identifiable.js";import"../../support/actions/ActionButton.js";import"../../support/actions/ActionToggle.js";import"../../chunks/compilerUtils.js";import"../../chunks/lengthUtils.js";import"../../renderers/support/ClassBreakInfo.js";import"../../chunks/commonProperties.js";import"../../symbols/support/jsonUtils.js";import"../../chunks/layerUtils.js";import"../../renderers/FlowRenderer.js";import"../../renderers/RasterColormapRenderer.js";import"../../renderers/support/ColormapInfo.js";import"../../chunks/colorRampUtils.js";import"../../chunks/colorUtils2.js";import"../../renderers/RasterShadedReliefRenderer.js";import"../../renderers/RasterStretchRenderer.js";import"../../chunks/stretchRendererUtils.js";import"../../renderers/UniqueValueRenderer.js";import"../../core/reactiveUtils.js";import"../../chunks/diffUtils.js";import"../../renderers/support/UniqueValue.js";import"../../renderers/support/UniqueValueClass.js";import"../../renderers/support/UniqueValueGroup.js";import"../../renderers/support/UniqueValueInfo.js";import"../../chunks/styleUtils.js";import"../../chunks/featureFlags.js";import"../../renderers/VectorFieldRenderer.js";import"../../geometry/support/normalizeUtils.js";import"../../chunks/normalizeUtilsCommon.js";import"../../chunks/simplify.js";import"../../chunks/utils4.js";import"../../chunks/utils5.js";import"../../chunks/utils6.js";import"../../chunks/asyncUtils.js";import"../../chunks/jsonUtils.js";import"../../chunks/parser.js";import"../../chunks/mat4.js";import"../../chunks/_commonjsHelpers.js";import"../../symbols/support/cimSymbolUtils.js";import"../../chunks/utils7.js";import"../../chunks/assets.js";import"../../chunks/LRUCache.js";import"../../chunks/MemCache.js";import"../../TimeExtent.js";import"../../chunks/timeUtils.js";import"../../support/timeUtils.js";import"../../chunks/ElevationInfo.js";import"../../chunks/unitConversionUtils.js";import"../../core/workers/workers.js";import"../../core/workers/Connection.js";import"../../chunks/Queue.js";import"../../core/workers/RemoteClient.js";import"../../intl.js";import"../../chunks/messages.js";import"../../chunks/TileKey.js";import"../support/RasterBandInfo.js";import"../support/RasterSensorInfo.js";import"../../chunks/rasterRendererChecks.js";import"../../chunks/pe.js";import"../../geometry/projection.js";import"../../chunks/geodesicConstants.js";import"../../geometry/support/GeographicTransformation.js";import"../../geometry/support/GeographicTransformationStep.js";import"../../chunks/zscale.js";import"../support/Field.js";import"../../chunks/domains.js";import"../support/CodedValueDomain.js";import"../support/Domain.js";import"../support/InheritedDomain.js";import"../support/RangeDomain.js";import"../../chunks/fieldType.js";import"../support/rasterFunctionConstants.js";import"../../chunks/generateRendererUtils.js";import"../../chunks/deprecate.js";import"../support/MosaicRule.js";let bt=class extends(I(j)){constructor(){super(...arguments),this.datasetName=null,this.datasetFormat=null,this.hasUniqueSourceStorageInfo=!0,this.rasterInfo=null,this.ioConfig={sampling:"closest"}}async init(){const t=$();this.addResolvingPromise(t),await this.when()}normalizeCtorArgs(t){return t&&t.ioConfig&&(t={...t,ioConfig:{resolution:null,bandIds:null,sampling:"closest",tileInfo:b.create(),...t.ioConfig}}),t}get _isGlobalWrappableSource(){const{rasterInfo:t}=this,e=Q(t.spatialReference);return null!=e&&t.extent.width>=e/2}get _hasNoneOrGCSShiftTransform(){const{transform:t}=this.rasterInfo;return null==t||"gcs-shift"===t.type}set rasterJobHandler(t){this._set("rasterJobHandler",t),"Function"===this.datasetFormat&&this.primaryRasters?.rasters?.forEach((e=>e.rasterJobHandler=t))}set url(t){this._set("url",h(t,n.getLogger(this)))}async open(t){throw new o("BaseRaster:open-not-implemented","open() is not implemented")}async fetchTile(t,e,s,r={}){const i=r.tileInfo||this.rasterInfo.storageInfo.tileInfo,o=this.getTileExtentFromTileInfo(t,e,s,i);return this.fetchPixels(o,i.size[0],i.size[1],r)}async identify(t,e={}){t=l(nt,t).clone().normalize();const{multidimensionalDefinition:s,timeExtent:r}=e,{rasterInfo:i}=this,{hasMultidimensionalTranspose:o,multidimensionalInfo:n}=i;let{transposedVariableName:a}=e;const m=null!=n&&o&&(null!=r||v(s));m&&!a&&(a=null!=s&&s.length>0?s[0].variableName??void 0:n.variables[0].name,e={...e,transposedVariableName:a}),e=this._getRequestOptionsWithSliceId(e);const{spatialReference:c,extent:p}=i,{datumTransformation:u}=e;let h=K(t,c,u);if(!p.intersects(h))return{location:h,value:null};if(null!=i.transform){const t=i.transform.inverseTransform(h);if(!i.nativeExtent.intersects(t))return{location:t,value:null};h=t}let d=0;const f=null!=a&&null!=n&&i.hasMultidimensionalTranspose;if("Function"===this.datasetFormat){const t=this.primaryRasters.rasters[0];if(f)return t.identify(h,e);const{pixelSize:s}=i,r=3,o=s.x*r/2,n=s.y*r/2,a=new ot({xmin:h.x-o,xmax:h.x+o,ymin:h.y-n,ymax:h.y+n,spatialReference:c}),l={interpolation:"nearest"},{pixelBlock:m}=await t.fetchPixels(a,r,r,l),{pixelBlock:p}=await this.fetchPixels(a,r,r,l);if(null==m)return{location:h,value:null};const u=Math.floor(r*r*.5),d=!m.mask||m.mask[u]?m.pixels.map((t=>t[u])):null;let y;return null!=p&&(y=!p.mask||p.mask[u]?p.pixels.map((t=>t[u])):void 0),{location:h,value:d,processedValue:y,pyramidLevel:0}}if(!f)if(e.srcResolution)d=X(e.srcResolution,i,this.ioConfig.sampling).pyramidLevel;else if(d=await this.computeBestPyramidLevelForLocation(t,e),null==d)return{location:h,value:null};const y=this.identifyPixelLocation(h,d,null,f);if(null===y)return{location:h,value:null};const{row:x,col:g,rowOffset:b,colOffset:j,blockWidth:k}=y,I=a??e.sliceId,R=J(this.url,I),S=`${d}/${x}/${g}`;let w=H(R,null,S);null==w&&(w=this.fetchRawTile(d,x,g,e),B(R,null,S,w));const T=await w;if(null==T||!T.pixels?.length)return{location:h,value:null};const M=b*k+j;return this._processIdentifyResult(T,{srcLocation:h,position:M,pyramidLevel:d,useTransposedTile:!!f,requestSomeSlices:m,identifyOptions:e})}async fetchPixels(t,e,s,r={}){t=Y(t),r=this._getRequestOptionsWithSliceId(r);const{_hasNoneOrGCSShiftTransform:i}=this;if(r.requestRawData&&i)return this._fetchPixels(t,e,s,r);const o=Q(t.spatialReference),n=Z(t);if(null==o||0===n||1===n&&this._isGlobalWrappableSource&&i)return this._fetchPixels(t,e,s,r);if(n>=3)return{extent:t,pixelBlock:null};const a=[],{xmin:l,xmax:m}=t,c=Math.round(o/(m-l)*e),p=c-Math.round((o/2-l)/(m-l)*e);let u=0;const h=[];for(let i=0;i<=n;i++){const d=new ot({xmin:0===i?l:-o/2,xmax:i===n?m-o*i:o/2,ymin:t.ymin,ymax:t.ymax,spatialReference:t.spatialReference}),f=0===i?c-p:i===n?e-u:c;u+=f,h.push(f);const y=r.disableWrapAround&&i>0?null:this._fetchPixels(d,f,s,r);a.push(y)}const d=(await Promise.all(a)).map((t=>t?.pixelBlock));let f=null;const y={width:e,height:s};return f=this.rasterJobHandler?(await this.rasterJobHandler.mosaicAndTransform({srcPixelBlocks:d,srcMosaicSize:y,destDimension:null,coefs:null,sampleSpacing:null,interpolation:"nearest",alignmentInfo:null,blockWidths:h},r)).pixelBlock:A(d,y,{blockWidths:h}),{extent:t,srcExtent:tt(t,this.rasterInfo.spatialReference,r.datumTransformation),pixelBlock:f}}async fetchRawPixels(t,e,s,r={}){e={x:Math.floor(e.x),y:Math.floor(e.y)};const i=await this._fetchRawTiles(t,e,s,r),{nativeExtent:o,nativePixelSize:n,storageInfo:a}=this.rasterInfo,l=2**t,m=n.x*l,c=n.y*l,p=new ot({xmin:o.xmin+m*e.x,xmax:o.xmin+m*(e.x+s.width-1),ymin:o.ymax-c*(e.y+s.height-1),ymax:o.ymax-c*e.y,spatialReference:o.spatialReference});if(!i)return{extent:p,srcExtent:p,pixelBlock:null};const{pixelBlocks:u,mosaicSize:h}=i;if(1===u.length&&null!=u[0]&&u[0].width===s.width&&u[0].height===s.height)return{extent:p,srcExtent:p,pixelBlock:i.pixelBlocks[0]};const d=t>0?a.pyramidBlockWidth:a.blockWidth,f=t>0?a.pyramidBlockHeight:a.blockHeight,y={x:e.x%d,y:e.y%f};let x;return x=this.rasterJobHandler?(await this.rasterJobHandler.mosaicAndTransform({srcPixelBlocks:u,srcMosaicSize:h,destDimension:s,clipOffset:y,clipSize:s,coefs:null,sampleSpacing:null,interpolation:r.interpolation,alignmentInfo:null,blockWidths:null},r)).pixelBlock:A(u,h,{clipOffset:y,clipSize:s}),{extent:p,srcExtent:p,pixelBlock:x}}fetchRawTile(t,e,s,r){throw new o("BaseRaster:read-not-implemented","fetchRawTile() is not implemented")}computeExtent(t){return tt(this.rasterInfo.extent,t)}decodePixelBlock(t,e){return!this.rasterJobHandler||e.useCanvas?E(t,e):this.rasterJobHandler.decode({data:t,options:e})}async request(t,e,s=0){const{customFetchParameters:r}=this.ioConfig,{range:o,query:n,headers:a}=e;s=s??e.retryCount??this.ioConfig.retryCount;const l=o?{Range:`bytes=${o.from}-${o.to}`}:null;try{return await i(t,{...e,query:{...n,...r},headers:{...a,...l}})}catch(r){if(s>0)return s--,this.request(t,e,s);throw r}}getSliceIndex(t){const{multidimensionalInfo:e}=this.rasterInfo;return null==e||null==t||0===t.length?null:T(t,e)}getTileExtentFromTileInfo(t,e,s,r){const i=k(r.lodAt(t));return this.getTileExtent({x:i.resolution,y:i.resolution},e,s,r.origin,r.spatialReference,r.size)}updateTileInfo(){const{storageInfo:t,spatialReference:e,extent:s,pixelSize:r}=this.rasterInfo;if(!t.tileInfo){const i=[],o=t.maximumPyramidLevel||0;let n=Math.max(r.x,r.y),a=1/.0254*96*n;for(let t=0;t<=o;t++)i.push(new S({level:o-t,resolution:n,scale:a})),n*=2,a*=2;const l=new nt({x:s.xmin,y:s.ymax,spatialReference:e});t.tileInfo=new b({origin:l,size:[t.blockWidth,t.blockHeight],spatialReference:e,lods:i}),t.isVirtualTileInfo=!0}}createRemoteDatasetStorageInfo(t,e=512,s=512,r){const{width:i,height:o,nativeExtent:n,pixelSize:a,spatialReference:l}=t,m=new nt({x:n.xmin,y:n.ymax,spatialReference:l});null==r&&(r=Math.max(0,Math.round(Math.log(Math.max(i,o))/Math.LN2-8)));const c=this.computeBlockBoundary(n,512,512,{x:n.xmin,y:n.ymax},[a],r);t.storageInfo=new w({blockWidth:e,blockHeight:s,pyramidBlockWidth:e,pyramidBlockHeight:s,origin:m,firstPyramidLevel:1,maximumPyramidLevel:r,blockBoundary:c})}async computeBestPyramidLevelForLocation(t,e={}){return 0}computeBlockBoundary(t,e,s,r,i,o=0,n=2){if(1===i.length&&o>0){i=[...i];let{x:t,y:e}=i[0];for(let s=0;s<o;s++)t*=n,e*=n,i.push({x:t,y:e})}const a=[],{x:l,y:m}=r;for(let r=0;r<i.length;r++){const{x:o,y:n}=i[r];a.push({minCol:Math.floor((t.xmin-l+.1*o)/e/o),maxCol:Math.floor((t.xmax-l-.1*o)/e/o),minRow:Math.floor((m-t.ymax+.1*n)/s/n),maxRow:Math.floor((m-t.ymin-.1*n)/s/n)})}return a}getPyramidPixelSize(t){const{nativePixelSize:e}=this.rasterInfo,{pyramidResolutions:s,pyramidScalingFactor:r}=this.rasterInfo.storageInfo;if(0===t)return e;if(null!=s&&s.length)return s[t-1];const i=r**t;return{x:e.x*i,y:e.y*i}}identifyPixelLocation(t,e,s,r){const{spatialReference:i,nativeExtent:o,storageInfo:n}=this.rasterInfo,{maximumPyramidLevel:a,origin:l,transposeInfo:m}=n,c=r&&null!=m?m.tileSize[0]:n.blockWidth,p=r&&null!=m?m.tileSize[1]:n.blockHeight,u=K(t,i,s);if(!o.intersects(u))return null;if(e<0||e>a)return null;const h=this.getPyramidPixelSize(e),{x:d,y:f}=h,y=(l.y-u.y)/f/p,x=(u.x-l.x)/d/c,g=Math.min(p-1,Math.floor((y-Math.floor(y))*p)),b=Math.min(c-1,Math.floor((x-Math.floor(x))*c));return{pyramidLevel:e,row:Math.floor(y),col:Math.floor(x),rowOffset:g,colOffset:b,blockWidth:c,srcLocation:u}}getTileExtent(t,e,s,r,i,o){const[n,a]=o,l=r.x+s*n*t.x,m=l+n*t.x,c=r.y-e*a*t.y,p=c-a*t.y;return new ot({xmin:l,xmax:m,ymin:p,ymax:c,spatialReference:i})}getBlockWidthHeight(t){return{blockWidth:t>0?this.rasterInfo.storageInfo.pyramidBlockWidth:this.rasterInfo.storageInfo.blockWidth,blockHeight:t>0?this.rasterInfo.storageInfo.pyramidBlockHeight:this.rasterInfo.storageInfo.blockHeight}}isBlockOutside(t,e,s){const r=this.rasterInfo.storageInfo.blockBoundary[t];return!r||r.maxRow<e||r.maxCol<s||r.minRow>e||r.minCol>s}async _fetchPixels(t,e,s,r={}){let i=Z(t);if(i>=2)return{extent:t,pixelBlock:null};const o=this._getSourceDataInfo(t,e,s,r),{pyramidLevel:n,srcResolution:a,srcExtent:l,srcWidth:m,srcHeight:c,ul:p}=o;if(0===m||0===c)return{extent:t,srcExtent:l,pixelBlock:null};const{rasterInfo:u}=this,h=u.transform,d="gcs-shift"===h?.type,f=null!=Q(t.spatialReference);!d&&f||(i=Z(o.srcExtent,d));const y=await this._fetchRawTiles(n,p,{width:m,height:c,wrapCount:i},r);if(!y)return{extent:t,srcExtent:l,pixelBlock:null};const x=u.storageInfo,g=n>0?x.pyramidBlockWidth:x.blockWidth,b=n>0?x.pyramidBlockHeight:x.blockHeight;let{x:j,y:k}=u.pixelSize;if(n>0){const{pyramidResolutions:t,pyramidScalingFactor:e}=x;if(null!=t&&t[n-1])({x:j,y:k}=t[n-1]);else{const t=e**n;j*=t,k*=t}}const I=u.spatialReference,R=new nt({x:j,y:k,spatialReference:I}),S=g===m&&b===c&&p.x%g==0&&p.y%b==0,w=new nt({x:(t.xmax-t.xmin)/e,y:(t.ymax-t.ymin)/s,spatialReference:t.spatialReference}),v=!t.spatialReference.equals(I),T=I.isGeographic?1e-9:1e-4,{datumTransformation:M}=r;if(!v&&S&&1===y.pixelBlocks.length&&g===e&&b===s&&this._isSameResolution(a,w,T))return{extent:t,srcExtent:l,srcTilePixelSize:R,pixelBlock:y.pixelBlocks[0]};const F=f&&null!=Q(l.spatialReference)&&this._hasNoneOrGCSShiftTransform,_=r.requestProjectedLocalDirections&&this.rasterInfo.dataType.startsWith("vector");_&&!this.rasterJobHandler&&await $();const P=this.rasterJobHandler?await this.rasterJobHandler.getProjectionOffsetGrid({projectedExtent:t,srcBufferExtent:y.extent,pixelSize:w.toJSON(),datumTransformation:M,rasterTransform:h,hasWrapAround:i>0||F,isAdaptive:!1!==this.ioConfig.optimizeProjectionAccuracy,includeGCSGrid:_},r):et({projectedExtent:t,srcBufferExtent:y.extent,pixelSize:w,datumTransformation:M,rasterTransform:h,hasWrapAround:i>0||F,isAdaptive:!1,includeGCSGrid:_});let D;const C=!r.requestRawData,J={rows:P.spacing[0],cols:P.spacing[1]},H=this._hasNoneOrGCSShiftTransform?this._getRasterTileAlignmentInfo(n,y.extent.xmin):void 0,{pixelBlocks:B,mosaicSize:O,isPartiallyFilled:U}=y;let z=null;if(this.rasterJobHandler){const t=await this.rasterJobHandler.mosaicAndTransform({srcPixelBlocks:B,srcMosaicSize:O,destDimension:C?{width:e,height:s}:null,coefs:C?P.coefficients:null,sampleSpacing:C?J:null,projectDirections:_,gcsGrid:_?P.gcsGrid:null,isUV:"vector-uv"===this.rasterInfo.dataType,interpolation:r.interpolation,alignmentInfo:H,blockWidths:null},r);({pixelBlock:D,localNorthDirections:z}=t)}else{const t=A(B,O,{alignmentInfo:H});D=C?N(t,{width:e,height:s},P.coefficients,J,r.interpolation):t,_&&P.gcsGrid&&(z=W({width:e,height:s},P.gcsGrid),D=V(D,this.rasterInfo.dataType,z))}return r.requestRawData||_?{extent:t,srcExtent:l,srcTilePixelSize:R,pixelBlock:D,transformGrid:P,localNorthDirections:z,isPartiallyFilled:U}:{extent:t,srcExtent:l,srcTilePixelSize:R,pixelBlock:D}}async _fetchRawTiles(t,e,s,r){const{origin:i,blockBoundary:o}=this.rasterInfo.storageInfo,{blockWidth:n,blockHeight:a}=this.getBlockWidthHeight(t);let{x:l,y:m}=e,{width:c,height:p,wrapCount:u}=s;const h=this._getRasterTileAlignmentInfo(t,0);r.buffer&&(l-=r.buffer.cols,m-=r.buffer.rows,c+=2*r.buffer.cols,p+=2*r.buffer.rows);let d=0,f=0,y=0;u&&null!=h&&(({worldColumnCountFromOrigin:f,originColumnOffset:y,rightPadding:d}=h),f*h.blockWidth-d>=l+c&&(d=0));const x=Math.floor(l/n),g=Math.floor(m/a),b=Math.floor((l+c+d-1)/n),j=Math.floor((m+p+d-1)/a),k=o[t];if(!k)return null;const{minRow:I,minCol:R,maxCol:S,maxRow:w}=k;if(0===u&&(j<I||b<R||g>w||x>S))return null;const v=new Array;let T=!1;const M=null==this.ioConfig.allowPartialFill?r.allowPartialFill:this.ioConfig.allowPartialFill;for(let e=g;e<=j;e++)for(let s=x;s<=b;s++){let i=s;if(!r.disableWrapAround&&u&&null!=h&&f<=s&&(i=s-f-y),e>=I&&i>=R&&w>=e&&S>=i){const s=this._fetchRawTile(t,e,i,r);M?v.push(new Promise((t=>{s.then((e=>t(e))).catch((()=>{T=!0,t(null)}))}))):v.push(s)}else v.push(Promise.resolve(null))}if(0===v.length)return null;const F=await Promise.all(v),_={height:(j-g+1)*a,width:(b-x+1)*n},{spatialReference:P}=this.rasterInfo,D=this.getPyramidPixelSize(t),{x:C,y:J}=D;return{extent:new ot({xmin:i.x+x*n*C,xmax:i.x+(b+1)*n*C,ymin:i.y-(j+1)*a*J,ymax:i.y-g*a*J,spatialReference:P}),pixelBlocks:F,mosaicSize:_,isPartiallyFilled:T}}_isSameResolution(t,e,s){return Math.abs(t.x-e.x)<s&&Math.abs(t.y-e.y)<s}_fetchRawTile(t,e,s,r){const i=this.rasterInfo.storageInfo.blockBoundary[t];if(!i)return Promise.resolve(null);const{minRow:o,minCol:n,maxCol:a,maxRow:l}=i;if(e<o||s<n||e>l||s>a)return Promise.resolve(null);const m=J(this.url,r.sliceId),c=`${t}/${e}/${s}`;let p=H(m,r.registryId,c);if(null==p){const i=new AbortController;p=this.fetchRawTile(t,e,s,{...r,signal:i.signal}),B(m,r.registryId,c,p,i),p.catch((()=>O(m,r.registryId,c)))}return r.signal&&R(r,(()=>{U(m,r.registryId,c)})),p}_computeMagDirValues(t){const{bandCount:e,dataType:s}=this.rasterInfo;if((2!==e||"vector-magdir"!==s)&&"vector-uv"!==s||2!==t?.length||!t[0]?.length)return null;const r=t[0].length;if("vector-magdir"===s){const e=t[1].map((t=>(t+360)%360));return[t[0],e]}const[i,o]=t,n=[],a=[];for(let t=0;t<r;t++){const[e,s]=q([i[t],o[t]]);n.push(e),a.push(s)}return[n,a]}_getRasterTileAlignmentInfo(t,e){return null==this._rasterTileAlighmentInfo&&(this._rasterTileAlighmentInfo=st(this.rasterInfo)),null==this._rasterTileAlighmentInfo.pyramidsInfo?null:{startX:e,halfWorldWidth:this._rasterTileAlighmentInfo.halfWorldWidth,hasGCSSShiftTransform:this._rasterTileAlighmentInfo.hasGCSSShiftTransform,...this._rasterTileAlighmentInfo.pyramidsInfo[t]}}_getSourceDataInfo(t,e,s,r={}){const i={datumTransformation:r.datumTransformation,pyramidLevel:0,pyramidResolution:null,srcExtent:null,srcHeight:0,srcResolution:null,srcWidth:0,ul:{x:0,y:0}};r.srcResolution&&(i.srcResolution=r.srcResolution,this._updateSourceDataInfo(t,i));const o=this.rasterInfo.storageInfo.maximumPyramidLevel||0,{srcWidth:n,srcHeight:a,pyramidLevel:l}=i,m=n/e,c=a/s,p=l<o&&m*c>=16,u=l===o&&this._requireTooManySrcTiles(n,a,e,s);if(p||u||0===n||0===a){const n=new nt({x:(t.xmax-t.xmin)/e,y:(t.ymax-t.ymin)/s,spatialReference:t.spatialReference});let a=rt(n,this.rasterInfo.spatialReference,t,i.datumTransformation);const u=!a||r.srcResolution&&a.x+a.y<r.srcResolution.x+r.srcResolution.y;if(p&&r.srcResolution&&u){const t=Math.round(Math.log(Math.max(m,c))/Math.LN2)-1;if(o-l+3>=t){const e=2**t;a={x:r.srcResolution.x*e,y:r.srcResolution.y*e}}}a&&(i.srcResolution=a,this._updateSourceDataInfo(t,i))}return this._requireTooManySrcTiles(i.srcWidth,i.srcHeight,e,s)&&(i.srcWidth=0,i.srcHeight=0),i}_requireTooManySrcTiles(t,e,s,r){const{tileInfo:i}=this.rasterInfo.storageInfo;return Math.ceil(t/i.size[0])*Math.ceil(e/i.size[1])>=256||t/s>8||e/r>8}_updateSourceDataInfo(t,e){e.srcWidth=0,e.srcHeight=0;const{rasterInfo:s}=this,r=s.spatialReference,{srcResolution:i,datumTransformation:o}=e,{pyramidLevel:n,pyramidResolution:a,excessiveReading:l}=X(i,s,this.ioConfig.sampling);if(l)return;let m=e.srcExtent||tt(t,r,o);if(null==m)return;const c=s.transform;c&&(m=c.inverseTransform(m)),e.srcExtent=m;const{x:p,y:u}=s.storageInfo.origin,h=Math.floor((m.xmin-p)/a.x+.1),d=Math.floor((u-m.ymax)/a.y+.1),f=Math.floor((m.xmax-p)/a.x-.1),y=Math.floor((u-m.ymin)/a.y-.1),x=m.width<.1*a.x?0:f-h+1,g=m.height<.1*a.y?0:y-d+1;e.pyramidLevel=n,e.pyramidResolution=a,e.srcWidth=x,e.srcHeight=g,e.ul={x:h,y:d}}_getRequestOptionsWithSliceId(t){return null!=this.rasterInfo.multidimensionalInfo&&null==t.sliceId&&(t={...t,sliceId:this.getSliceIndex(t.multidimensionalDefinition)}),t}_processIdentifyResult(t,e){const{srcLocation:s,position:r,pyramidLevel:i,useTransposedTile:o}=e,n=t.pixels[0].length/t.width/t.height;if(t.mask&&!t.mask[r])return{location:s,value:null};const{multidimensionalInfo:a}=this.rasterInfo;if(null==a||!o){const e=t.pixels.map((t=>t[r])),o={location:s,value:e,pyramidLevel:i},n=this._computeMagDirValues(e.map((t=>[t])));return n?.length&&(o.magdirValue=n.map((t=>t[0]))),o}let l=t.pixels.map((t=>t.slice(r*n,r*n+n))),m=this._computeMagDirValues(l);const{requestSomeSlices:c,identifyOptions:p}=e;let u=M(a,p.transposedVariableName);if(c){const t=F(u,p.multidimensionalDefinition,p.timeExtent);l=l.map((e=>t.map((t=>e[t])))),m=m?.map((e=>t.map((t=>e[t])))),u=t.map((t=>u[t]))}const h=t.noDataValues||this.rasterInfo.noDataValue,d={pixels:l,pixelType:t.pixelType};let y;return null!=h&&(z(d,h),y=d.mask),{location:s,value:null,dataSeries:u.map(((t,e)=>{const s={value:0===y?.[e]?null:l.map((t=>t[e])),multidimensionalDefinition:t.multidimensionalDefinition.map((t=>new f({...t,isSlice:!0})))};return m?.length&&(s.magdirValue=[m[0][e],m[1][e]]),s})),pyramidLevel:i}}};t([a()],bt.prototype,"_rasterTileAlighmentInfo",void 0),t([a({readOnly:!0})],bt.prototype,"_isGlobalWrappableSource",null),t([a({readOnly:!0})],bt.prototype,"_hasNoneOrGCSShiftTransform",null),t([a()],bt.prototype,"rasterJobHandler",null),t([a(d)],bt.prototype,"url",null),t([a({type:String,json:{write:!0}})],bt.prototype,"datasetName",void 0),t([a({type:String,json:{write:!0}})],bt.prototype,"datasetFormat",void 0),t([a()],bt.prototype,"hasUniqueSourceStorageInfo",void 0),t([a()],bt.prototype,"rasterInfo",void 0),t([a()],bt.prototype,"ioConfig",void 0),t([a()],bt.prototype,"sourceJSON",void 0),bt=t([c("esri.layers.support.rasterDatasets.BaseRaster")],bt);const jt=bt;let kt=class extends jt{constructor(){super(...arguments),this.datasetFormat="Function",this.tileType="Raster",this.rasterFunction=null}async open(t){await this.init();const{rasterFunction:e}=this;this.primaryRasters?.rasters?.length?e.sourceRasters=this.primaryRasters.rasters:(this.primaryRasters=e.getPrimaryRasters(),this.rasterJobHandler&&this.primaryRasters.rasters?.forEach((t=>t.rasterJobHandler=this.rasterJobHandler)));const{rasters:s,rasterIds:r}=this.primaryRasters,i=s.map((e=>e.rasterInfo?void 0:e.open(t)));await Promise.all(i);const n=s.map((({rasterInfo:t})=>t)),a=e.bind({rasterInfos:n,rasterIds:r});if(!a.success||0===n.length)throw new o("raster-function:open",`cannot bind the function: ${a.error??""}`);const l="Table"===e.functionName?e:e.functionArguments?.raster;"Table"===l?.functionName&&(e.rasterInfo.attributeTable=at.fromJSON(l.functionArguments.attributeTableAsRecordSet)),await this.syncJobHandler();const m=n[0];this.hasUniqueSourceStorageInfo=1===n.length||n.slice(1).every((t=>this._hasSameStorageInfo(t,m))),this.set("sourceJSON",s[0].sourceJSON),this.set("rasterInfo",e.rasterInfo)}async syncJobHandler(){return this.rasterJobHandler?.updateRasterFunction(this.rasterFunction)}async fetchPixels(t,e,s,r={}){const{rasters:i,rasterIds:o}=this.primaryRasters;let n=!1;const{interpolation:a}=r,l=this.rasterFunction.flatWebGLFunctionChain?.hasSurfaceFunction;!r.requestRawData&&"bilinear"!==a&&l&&(n=1===i.length&&!r.skipRasterFunction,r={...r,interpolation:"bilinear",requestRawData:n});const m=i.map((i=>i.fetchPixels(t,e,s,r))),c=await Promise.all(m),p=c.map((t=>t.pixelBlock)),u=n||r.requestRawData?c.map((t=>t.srcTilePixelSize)):null;if(r.skipRasterFunction||p.every((t=>null==t)))return c[0];const h=c.find((t=>null!=t.pixelBlock))?.extent??t,d=this.rasterJobHandler?await this.rasterJobHandler.process({extent:h,primaryPixelBlocks:p,primaryPixelSizes:u,primaryRasterIds:o}):this.rasterFunction.process({extent:h,primaryPixelBlocks:p,primaryPixelSizes:u,primaryRasterIds:o}),{transformGrid:f}=c[0];if(!n||null==d||null==f)return{...c[0],pixelBlock:d};const y={rows:f.spacing[0],cols:f.spacing[1]};let x;return x=this.rasterJobHandler?(await this.rasterJobHandler.mosaicAndTransform({srcPixelBlocks:[d],srcMosaicSize:{width:d.width,height:d.height},destDimension:{width:e,height:s},coefs:f.coefficients,sampleSpacing:y,projectDirections:!1,gcsGrid:null,isUV:!1,interpolation:a,alignmentInfo:void 0,blockWidths:null},r)).pixelBlock:N(d,{width:e,height:s},f.coefficients,y,a),{extent:t,srcExtent:c[0].srcExtent,pixelBlock:x}}_hasSameStorageInfo(t,e){const{storageInfo:s,pixelSize:r,spatialReference:i,extent:o}=t,{storageInfo:n,pixelSize:a,spatialReference:l,extent:m}=e;return r.x===a.x&&r.y===a.y&&i.equals(l)&&o.equals(m)&&s.blockHeight===n.blockHeight&&s.blockWidth===n.blockWidth&&s.maximumPyramidLevel===n.maximumPyramidLevel}};t([a({type:String,json:{write:!0}})],kt.prototype,"datasetFormat",void 0),t([a()],kt.prototype,"tileType",void 0),t([a()],kt.prototype,"rasterFunction",void 0),t([a()],kt.prototype,"primaryRasters",void 0),kt=t([c("esri.layers.support.rasterDatasets.FunctionRaster")],kt);const It=kt,Rt=n.getLogger("esri.layers.mixins.ImageryTileMixin"),St=n=>{let j=class extends n{constructor(...t){super(...t),this._isConstructedFromFunctionRaster=!1,this._rasterJobHandler={instance:null,refCount:0,connectionPromise:null},this.bandIds=null,this.copyright=null,this.interpolation="nearest",this.multidimensionalSubset=null,this.raster=null,this.rasterInfo=null,this.sourceJSON=null,this.spatialReference=null,this.symbolizer=null,this._isConstructedFromFunctionRaster="Function"===t[0]?.raster?.datasetFormat}get fullExtent(){return this.rasterInfo?.extent}set multidimensionalDefinition(t){this._set("multidimensionalDefinition",t),this.updateRenderer()}set rasterFunction(t){"none"===t?.functionName?.toLowerCase()&&(t=void 0),this._set("rasterFunction",t),this.updateRasterFunction()}set url(t){this._set("url",h(t,Rt))}set renderer(t){null==t&&null==this.rasterFunction?this._configDefaultRenderer("override"):(this._set("renderer",t),this.updateRenderer())}readRenderer(t,e,s){const i=e?.layerDefinition?.drawingInfo?.renderer;return r(i,s)||void 0}async convertVectorFieldData(t,e){if(null==t||!this.rasterInfo)return null;const s=this._rasterJobHandler.instance,r=this.rasterInfo.dataType;return s?s.convertVectorFieldData({pixelBlock:t,dataType:r},e):G(t,r)}async computeStatisticsHistograms(t,e){t=l(yt,t).clone();const{rasterInfo:s}=this,{geometry:r}=t;if(null==r)throw new o("imagery-tile-mixin:compute-statistics-histograms","geometry must be specified");let i=r;const{spatialReference:n}=s;r.spatialReference.equals(n)||(await $(),i="extent"===r.type?tt(r,n):it(r,n));const a=t.pixelSize??new nt({x:s.pixelSize.x,y:s.pixelSize.y,spatialReference:n}),{extent:m,width:c,height:u}=function(t,e,s,r=!0){const{spatialReference:i}=t,{x:o,y:n}=function(t,e){if(t.spatialReference.equals(e))return t;const s=p(t.spatialReference),r=p(e);if(s===r)return t;const i=s/r;return{x:t.x*i,y:t.y*i}}(s,i);let a,l,m;const c="extent"===e.type?e:e.extent;let{xmin:u,xmax:h,ymax:d,ymin:f}=c;const{xmin:y,ymax:x}=t.extent;return r?(u=y+(u>y?o*Math.round((u-y)/o):0),d=x-(d<x?n*Math.round((x-d)/n):0),h=y+(h>y?o*Math.round((h-y)/o):0),f=x-(f<x?n*Math.round((x-f)/n):0),a=new ot({xmin:u,ymax:d,xmax:h,ymin:f,spatialReference:i}),l=Math.round(a.width/o),m=Math.round(a.height/n)):(l=Math.floor((h-u)/o+.8),m=Math.floor((d-f)/n+.8),u=y+(u>y?o*Math.floor((u-y)/o+.1):0),d=x-(d<x?n*Math.floor((x-d)/n+.1):0),h=u+l*o,f=d-m*n,a=new ot({xmin:u,ymax:d,xmax:h,ymin:f,spatialReference:i})),{extent:a,width:l,height:m}}(s,i,a),h=await this.fetchPixels(m,c,u,{...e,interpolation:"nearest"});if(null==h.pixelBlock)throw new o("imagery-tile-mixin:compute-statistics-histograms","failed to fetch pixels");const d=await async function(t,e,s){if("extent"===s.type)return function(t,e,s){const{width:r,height:i}=t,o=new Uint8Array(r*i),n=e.width/r,a=e.height/i;if(s.width/n<.5||s.height/a<.5)return new lt({pixelType:t.pixelType,width:r,height:i,mask:o,pixels:[...t.pixels]});const{xmin:l,xmax:m,ymin:c,ymax:p}=e,{xmin:u,xmax:h,ymin:d,ymax:f}=s,y=Math.max(l,u),x=Math.min(m,h),g=Math.max(c,d),b=Math.min(p,f),j=.5*n,k=.5*a;if(x-y<j||b-g<k||x<l+j||y>m-j||g>p-k||b<c+k)return new lt({pixelType:t.pixelType,width:r,height:i,mask:o,pixels:[...t.pixels]});const I=Math.max(0,(y-l)/n),R=Math.min(r,Math.max(0,(x-l)/n)),S=Math.max(0,(p-b)/a),w=Math.min(i,Math.max(0,(p-g)/a)),v=Math.round(I),T=Math.round(R)-1,M=Math.round(S),F=Math.round(w)-1;if(v===T&&I%1>.5&&R%1<.5||M===F&&S%1>.5&&w%1<.5)return new lt({pixelType:t.pixelType,width:r,height:i,mask:o,pixels:[...t.pixels]});if(0===v&&0===M&&T===r&&F===i)return t;const _=t.mask;for(let t=M;t<=F;t++)for(let e=v;e<=T;e++){const s=t*r+e;o[s]=_?_[s]:255}return new lt({pixelType:t.pixelType,width:r,height:i,mask:o,pixels:[...t.pixels]})}(t,e,s);const{width:r,height:i}=t,o=new Uint8Array(r*i),{contains:n,intersects:a}=await import("../../geometry/geometryEngine.js");return a(e,s)?"polyline"===s.type?function(t,e,s){const{width:r,height:i}=t,o=new Uint8Array(r*i),n=e.width/r,a=e.height/i,{xmin:l,ymax:m}=e,{paths:c}=s,p=t.mask;for(let t=0;t<c.length;t++){const e=c[t];for(let t=0;t<e.length-1;t++){const[s,c]=e[t],[u,h]=e[t+1];let d=Math.floor((m-c)/a),f=Math.floor((m-h)/a);if(f<d){const t=d;d=f,f=t}d=Math.max(0,d),f=Math.min(i-1,f);const y=(u-s)/(h-c);for(let t=d;t<=f;t++){const e=t===d?Math.max(c,h):(i+1-t)*a,m=t===f?Math.min(c,h):e-a;let x=h===c?Math.floor((s-l)/n):Math.floor((y*(e-c)+s-l)/n),g=h===c?Math.floor((u-l)/n):Math.floor((y*(m-c)+s-l)/n);if(g<x){const t=x;x=g,g=t}const b=t*r;x=Math.max(0,x),g=Math.min(r-1,g);for(let t=b+x;t<=b+g;t++)o[t]=p?p[t]:255}}}return new lt({pixelType:t.pixelType,width:r,height:i,mask:o,pixels:[...t.pixels]})}(t,e,s):n(s,e)?t:function(t,e,s){if(!t)return t;const{width:r,height:i}=t,o=e.width/r,n=e.height/i,{xmin:a,ymax:l}=e;let m;if("extent"===s.type){const t=(s.xmin-a)/o,e=(s.xmax-a)/o,r=(l-s.ymax)/n,i=(l-s.ymin)/n;m=[[[t,r],[t,i],[e,i],[e,r],[t,r]]]}else m=s.rings.map((t=>t.map((([t,e])=>[(t-a)/o,(l-e)/n]))));const c=document.createElement("canvas");c.width=r,c.height=i;const p=c.getContext("2d");p.fillStyle="#f00",m.forEach((t=>{p.beginPath(),p.moveTo(t[0][0],t[0][1]);for(let e=0;e<t.length;e++)p.lineTo(t[e][0],t[e][1]);p.closePath(),p.fill()}));const u=p.getImageData(0,0,r,i).data,h=t.mask,d=r*i,f=new Uint8Array(d);for(let t=0;t<d;t++)h&&!h[t]||(f[t]=u[4*t+3]>127?255:0);return new lt({pixelType:t.pixelType,width:r,height:i,mask:f,maskIsAlpha:!1,pixels:[...t.pixels]})}(t,e,s):new lt({pixelType:t.pixelType,width:r,height:i,mask:o,maskIsAlpha:!1,pixels:[...t.pixels]})}(h.pixelBlock,m,i),f=this._rasterJobHandler.instance;return f?f.computeStatisticsHistograms({pixelBlock:d},e):ct(d)}async createFlowMesh(t,e){const s=this._rasterJobHandler.instance;return s?s.createFlowMesh(t,e):xt(t.meshType,t.simulationSettings,t.flowData,null!=e.signal?e.signal:(new AbortController).signal)}normalizeRasterFetchOptions(t){const{multidimensionalInfo:e}=this.rasterInfo??{};if(null==e)return t;let s=t.multidimensionalDefinition||this.multidimensionalDefinition;null!=s&&s.length||(s=_(this.raster.rasterInfo,{multidimensionalSubset:this.multidimensionalSubset}));const r=t.timeExtent||this.timeExtent;if(null!=s&&null!=r&&(null!=r.start||null!=r.end)){s=s.map((t=>t.clone()));const i=e.variables.find((({name:t})=>t===s[0].variableName))?.dimensions?.find((({name:t})=>"StdTime"===t)),o=s.find((({dimensionName:t})=>"StdTime"===t));if(!i||!o)return{...t,multidimensionalDefinition:null};const{start:n,end:a}=r,l=null==n?null:n.getTime(),m=null==a?null:a.getTime(),c=l??m,p=m??l;if(null!=i.values){const t=i.values.filter((t=>{if(Array.isArray(t)){if(c===p)return t[0]<=c&&t[1]>=c;const e=t[0]<=c&&t[1]>c||t[0]<p&&t[1]>=p,s=t[0]>=c&&t[1]<=p||t[0]<c&&t[1]>p;return e||s}return c===p?t===c:t>=c&&t<=p}));if(t.length){const e=t.sort(((t,e)=>{const s=Array.isArray(t)?t[0]:t,r=Array.isArray(t)?t[1]:t,i=Array.isArray(e)?e[0]:e,o=Array.isArray(e)?e[1]:e;return c===p?s-i:Math.abs(r-p)-Math.abs(o-p)}))[0];o.values=[e]}else s=null}else if(i.hasRegularIntervals&&i.extent){const[t,e]=i.extent;c>e||p<t?s=null:o.values=c===p?[c]:[Math.max(t,c),Math.min(e,p)]}}return null!=s&&P(s,this.multidimensionalSubset)?{...t,multidimensionalDefinition:null}:{...t,multidimensionalDefinition:s}}async updateRasterFunction(){if(!this.loaded||"imagery-tile"!==this.type||!this.rasterFunction&&!this._cachedRasterFunctionJson||JSON.stringify(this.rasterFunction)===JSON.stringify(this._cachedRasterFunctionJson))return;if(this._isConstructedFromFunctionRaster&&"Function"===this.raster.datasetFormat){const t=this.raster.rasterFunction.toJSON();return!this.rasterFunction&&t&&this._set("rasterFunction",x.fromJSON(t)),void(this._cachedRasterFunctionJson=this.rasterFunction?.toJSON())}let t,e=this.raster,s=!1;"Function"===e.datasetFormat?(t=e.primaryRasters.rasters,e=t[0],s=!0):t=[e];const{rasterFunction:r}=this;if(r){const s={raster:e};t.length>1&&t.forEach((t=>s[t.url]=t));const i=mt(r.functionDefinition?.toJSON()??r.toJSON(),s),o=new It({rasterFunction:i});o.rasterJobHandler=this._rasterJobHandler.instance,await o.open(),this._cachedRasterFunctionJson=this.rasterFunction?.toJSON(),this.raster=o}else this.raster=e,this._cachedRasterFunctionJson=null,await e.when();if(this._cachedRendererJson=null,!s&&!r)return;const{bandIds:i}=this,{bandCount:o}=this.raster.rasterInfo,n=i?.length?i.some((t=>t>=o)):o>=3;i&&(n||this.renderer&&"raster-stretch"!==this.renderer.type)&&this._set("bandIds",null),this._configDefaultRenderer("auto")}async updateRenderer(){const{loaded:t,symbolizer:e}=this;if(!t||!e||!this.renderer)return;const{rasterInfo:s}=this.raster,r=D(s,{multidimensionalDefinition:this.multidimensionalDefinition,multidimensionalSubset:this.multidimensionalSubset}),i=r?.name,o=pt({...this.renderer.toJSON(),variableName:i});if(JSON.stringify(this._cachedRendererJson)===JSON.stringify(o))return;const n=this._rasterJobHandler.instance;n&&(e.rasterInfo=ut(s,i),e.rendererJSON=o,e.bind(),await n.updateSymbolizer(e),this._cachedRendererJson=o)}async applyRenderer(t,e){const s=t&&t.pixelBlock;if(!(null!=s&&s.pixels&&s.pixels.length>0))return null;let r;await this.updateRenderer();const i=this._rasterJobHandler.instance,o=this.bandIds??[];return r=i?await i.symbolize({...t,simpleStretchParams:e,bandIds:o}):this.symbolizer.symbolize({...t,simpleStretchParams:e,bandIds:o}),r}getTileUrl(t,e,s){return"RasterTileServer"===this.raster.datasetFormat?`${this.url}/tile/${t}/${e}/${s}`:""}getCompatibleTileInfo(t,e,s=!1){if(!this.loaded||null==e)return null;if(s&&t.equals(this.spatialReference))return this.tileInfo;const r=u(t);return b.create({size:256,spatialReference:t,origin:r?{x:r.origin[0],y:r.origin[1]}:{x:e.xmin,y:e.ymax}})}getCompatibleFullExtent(t){return this.loaded?(this._compatibleFullExtent&&this._compatibleFullExtent.spatialReference.equals(t)||(this._compatibleFullExtent=this.raster.computeExtent(t)),this._compatibleFullExtent):null}async fetchTile(t,e,s,r={}){if(k(this),r.requestAsImageElement){const o=this.getTileUrl(t,e,s);return i(o,{responseType:"image",query:{...this.refreshParameters,...this.raster.ioConfig.customFetchParameters},signal:r.signal}).then((t=>t.data))}const{rasterInfo:o}=this;if(null!=o.multidimensionalInfo&&null==(r=this.normalizeRasterFetchOptions(r)).multidimensionalDefinition){const i=r.tileInfo||o.storageInfo.tileInfo;return{extent:this.raster.getTileExtentFromTileInfo(t,e,s,i),pixelBlock:null}}return await this._initJobHandler(),await this.updateRasterFunction(),"raster-shaded-relief"===this.renderer?.type&&(r={...r,buffer:{cols:1,rows:1}}),this.raster.fetchTile(t,e,s,r)}async fetchPixels(t,e,s,r={}){return null!=this.rasterInfo.multidimensionalInfo&&null==(r=this.normalizeRasterFetchOptions(r)).multidimensionalDefinition?{extent:t,pixelBlock:null}:(await this._initJobHandler(),await this.updateRasterFunction(),e=Math.round(e),s=Math.round(s),this.raster.fetchPixels(t,e,s,r))}async identify(t,e={}){const{raster:s,rasterInfo:r}=this;if(null!=r.multidimensionalInfo&&!(r.hasMultidimensionalTranspose&&(v(e.multidimensionalDefinition)||e.transposedVariableName||e.timeExtent)||null!=(e=this.normalizeRasterFetchOptions(e)).multidimensionalDefinition))return{location:t,value:null};const i=this.multidimensionalSubset?.areaOfInterest;if(i&&!i.contains(t))throw new o("imagery-tile-mixin:identify","the request cannot be fulfilled when falling outside of the multidimensional subset");return s.identify(t,e)}increaseRasterJobHandlerUsage(){this._rasterJobHandler.refCount++}decreaseRasterJobHandlerUsage(){this._rasterJobHandler.refCount--,this._rasterJobHandler.refCount<=0&&this._shutdownJobHandler()}hasStandardTime(){const t=this.rasterInfo?.multidimensionalInfo;if(null==t||"standard-time"!==this.rasterInfo?.dataType)return!1;const e=this.multidimensionalDefinition,s=e?.[0]?.variableName;return t.variables.some((t=>t.name===s&&(!e?.[0].dimensionName||t.dimensions.some((t=>"StdTime"===t.name)))))}getStandardTimeValue(t){return new Date(24*(t-25569)*3600*1e3).toString()}getMultidimensionalSubsetVariables(t){const e=t??this.rasterInfo?.multidimensionalInfo;return C(this.multidimensionalSubset,e)}_configDefaultSettings(){this._configDefaultInterpolation(),this.multidimensionalDefinition||(this.multidimensionalDefinition=_(this.raster.rasterInfo,{multidimensionalSubset:this.multidimensionalSubset})),this.rasterFunction&&"Function"===this.raster.datasetFormat&&(this._cachedRasterFunctionJson=this.rasterFunction.toJSON()),this._configDefaultRenderer()}_initJobHandler(){if(null!=this._rasterJobHandler.connectionPromise)return this._rasterJobHandler.connectionPromise;const t=new g;return this._rasterJobHandler.connectionPromise=t.initialize().then((async()=>{k(this),this._rasterJobHandler.instance=t,this.raster.rasterJobHandler=t,"Function"===this.raster.datasetFormat&&this.raster.syncJobHandler(),this.rasterFunction&&await this.updateRasterFunction().catch((()=>{})),this.renderer&&this.updateRenderer()})).catch((()=>{})),this._rasterJobHandler.connectionPromise}_shutdownJobHandler(){this._rasterJobHandler.instance&&this._rasterJobHandler.instance.destroy(),this._rasterJobHandler.instance=null,this._rasterJobHandler.connectionPromise=null,this._rasterJobHandler.refCount=0,this._cachedRendererJson=null,this.raster&&(this.raster.rasterJobHandler=null)}_configDefaultInterpolation(){if(null==this.interpolation){k(this);const{raster:t}=this,e=ht(t.rasterInfo,t.tileType,this.sourceJSON?.defaultResamplingMethod);this._set("interpolation",e)}}_configDefaultRenderer(t="no"){k(this);const{rasterInfo:e}=this.raster;!this.bandIds&&e.bandCount>1&&(this.bandIds=dt(e));const s=D(e,{multidimensionalDefinition:this.multidimensionalDefinition,multidimensionalSubset:this.multidimensionalSubset}),r=s?.name;if(!this.renderer||"override"===t){const t=ft(e,{bandIds:this.bandIds,variableName:r}),s=e.statistics,i=s&&s.length>0?s[0]:null,o=i?.max??0,n=i?.min??0;"WCSServer"===this.raster.datasetFormat&&"raster-stretch"===t.type&&(o>1e24||n<-1e24)&&(t.dynamicRangeAdjustment=!0,t.statistics=null,"none"===t.stretchType&&(t.stretchType="min-max")),this.renderer=t}const i=pt({...this.renderer.toJSON(),variableName:r}),o=ut(e,r);this.symbolizer?(this.symbolizer.rendererJSON=i,this.symbolizer.rasterInfo=o):this.symbolizer=new L({rendererJSON:i,rasterInfo:o});const n=this.symbolizer.bind();if(n.success){if("auto"===t){const{colormap:t}=this.raster.rasterInfo,e=this.renderer;if(null!=t&&"raster-colormap"===e.type){const t=ft(this.raster.rasterInfo);JSON.stringify(t)!==JSON.stringify(e)&&this._configDefaultRenderer("override")}else if("raster-stretch"===e.type){const t=this.bandIds?.length,s=e.statistics?.length;!e.dynamicRangeAdjustment&&s&&t&&s!==t&&this._configDefaultRenderer("override")}}}else Rt.warn("imagery-tile-mixin",n.error||"The given renderer is not supported by the layer."),"auto"===t&&this._configDefaultRenderer("override")}};function k(t){if(!t.raster||!t.rasterInfo)throw new o("imagery-tile","no raster")}return t([a()],j.prototype,"_cachedRendererJson",void 0),t([a()],j.prototype,"_cachedRasterFunctionJson",void 0),t([a()],j.prototype,"_compatibleFullExtent",void 0),t([a()],j.prototype,"_isConstructedFromFunctionRaster",void 0),t([a()],j.prototype,"_rasterJobHandler",void 0),t([a()],j.prototype,"bandIds",void 0),t([a({json:{origins:{service:{read:{source:"copyrightText"}}}}})],j.prototype,"copyright",void 0),t([a({json:{read:!1}})],j.prototype,"fullExtent",null),t([a()],j.prototype,"interpolation",void 0),t([a()],j.prototype,"ioConfig",void 0),t([a({type:[f],json:{write:!0}})],j.prototype,"multidimensionalDefinition",null),t([a({type:y,json:{write:!0}})],j.prototype,"multidimensionalSubset",void 0),t([a()],j.prototype,"raster",void 0),t([a({type:x,json:{name:"renderingRule",write:!0}})],j.prototype,"rasterFunction",null),t([a()],j.prototype,"rasterInfo",void 0),t([a()],j.prototype,"sourceJSON",void 0),t([a({readOnly:!0,type:gt,json:{read:!1}})],j.prototype,"spatialReference",void 0),t([a({type:b})],j.prototype,"tileInfo",void 0),t([a(d)],j.prototype,"url",null),t([a({types:e,json:{name:"layerDefinition.drawingInfo.renderer",write:{overridePolicy(){const t="raster-stretch"===this.renderer?.type&&"none"===this.renderer.stretchType&&!this.renderer.useGamma;return{enabled:!this.loaded||"Raster"===this.raster.tileType||!t}}},origins:{"web-scene":{types:s,name:"layerDefinition.drawingInfo.renderer",write:{overridePolicy:t=>({enabled:t&&"vector-field"!==t.type&&"flow"!==t.type})}}}}})],j.prototype,"renderer",null),t([m("renderer")],j.prototype,"readRenderer",null),t([a()],j.prototype,"symbolizer",void 0),j=t([c("esri.layers.ImageryTileMixin")],j),j};export{jt as B,It as F,St as ImageryTileMixin};
