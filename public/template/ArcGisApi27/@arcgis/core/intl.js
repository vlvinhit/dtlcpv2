/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.27/esri/copyright.txt for details.
*/
import{f as t}from"./chunks/date.js";export{c as convertDateFormatToIntlOptions}from"./chunks/date.js";import{f as e}from"./chunks/number.js";export{c as convertNumberFormatToIntlOptions}from"./chunks/number.js";import{L as n}from"./chunks/Logger.js";import{g as r}from"./chunks/object.js";import{r as i}from"./chunks/string.js";export{g as getLocale,o as onLocaleChange,p as prefersRTL,s as setLocale}from"./chunks/locale.js";import{n as a,r as u}from"./chunks/messages.js";export{f as fetchMessageBundle}from"./chunks/messages.js";import m from"./request.js";import l from"./core/Error.js";import{g as h}from"./chunks/assets.js";import"./chunks/jsonMap.js";import"./chunks/datetime.js";import"./chunks/maybe.js";import"./config.js";import"./chunks/typedArrayUtil.js";import"./core/lang.js";import"./core/promiseUtils.js";import"./kernel.js";import"./core/urlUtils.js";const d=n.getLogger("esri.intl.substitute");function w(n,s,o={}){const{format:a={}}=o;return i(n,(n=>function(n,s,o){let i,a;const c=n.indexOf(":");if(-1===c?i=n.trim():(i=n.slice(0,c).trim(),a=n.slice(c+1).trim()),!i)return"";const u=r(i,s);if(null==u)return"";const m=(a?o?.[a]:null)??o?.[i];return m?function(n,r){switch(r.type){case"date":return t(n,r.intlOptions);case"number":return e(n,r.intlOptions);default:return d.warn("missing format descriptor for key {key}"),j(n)}}(u,m):a?function(n,r){switch(r.toLowerCase()){case"dateformat":return t(n);case"numberformat":return e(n);default:return d.warn(`inline format is unsupported since 4.12: ${r}`),/^(dateformat|datestring)/i.test(r)?t(n):/^numberformat/i.test(r)?e(n):j(n)}}(u,a):j(u)}(n,s,a)))}function j(n){switch(typeof n){case"string":return n;case"number":return e(n);case"boolean":return""+n;default:return n instanceof Date?t(n):""}}async function k(t){if(null!=$.fetchBundleAsset)return $.fetchBundleAsset(t);const e=await m(t,{responseType:"text"});return JSON.parse(e.data)}class b{constructor({base:t="",pattern:e,location:n=new URL(window.location.href)}){let r;r="string"==typeof n?t=>new URL(t,new URL(n,window.location.href)).href:n instanceof URL?t=>new URL(t,n).href:n,this.pattern="string"==typeof e?new RegExp(`^${e}`):e,this.getAssetUrl=r,t=t?t.endsWith("/")?t:t+"/":"",this.matcher=new RegExp(`^${t}(?:(.*)/)?(.*)$`)}fetchMessageBundle(t,e){return async function(t,e,n,r){const s=e.exec(n);if(!s)throw new l("esri-intl:invalid-bundle",`Bundle id "${n}" is not compatible with the pattern "${e}"`);const o=s[1]?`${s[1]}/`:"",i=s[2],c=a(r),u=`${o}${i}.json`,m=c?`${o}${i}_${c}.json`:u;let f;try{f=await k(t(m))}catch(e){if(m===u)throw new l("intl:unknown-bundle",`Bundle "${n}" cannot be loaded`,{error:e});try{f=await k(t(u))}catch(t){throw new l("intl:unknown-bundle",`Bundle "${n}" cannot be loaded`,{error:t})}}return f}(this.getAssetUrl,this.matcher,t,e)}}function y(t){return new b(t)}const $={};u(y({pattern:"esri/",location:h}));export{y as createJSONLoader,t as formatDate,e as formatNumber,a as normalizeMessageBundleLocale,u as registerMessageBundleLoader,w as substitute};
