/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.27/esri/copyright.txt for details.
*/
import{h as t}from"./unitUtils.js";import{T as o}from"./TileKey2.js";import{O as e}from"./ObjectPool.js";function l(t,o){return[t,o]}function s(t,o,e){return t[0]=o,t[1]=e,t}const i=new o("0/0/0/0");class r{static create(o,e,i=null){const n=t(o.spatialReference),a=e.origin||l(o.origin.x,o.origin.y),h=l(o.size[0]*e.resolution,o.size[1]*e.resolution),c=l(-1/0,-1/0),u=l(1/0,1/0),f=l(1/0,1/0);null!=i&&(s(c,Math.max(0,Math.floor((i.xmin-a[0])/h[0])),Math.max(0,Math.floor((a[1]-i.ymax)/h[1]))),s(u,Math.max(0,Math.floor((i.xmax-a[0])/h[0])),Math.max(0,Math.floor((a[1]-i.ymin)/h[1]))),s(f,u[0]-c[0]+1,u[1]-c[1]+1));const{cols:m,rows:g}=e;let d,w,M,v;return!i&&m&&g&&(s(c,m[0],g[0]),s(u,m[1],g[1]),s(f,m[1]-m[0]+1,g[1]-g[0]+1)),o.isWrappable?(d=l(Math.ceil(Math.round((n.valid[1]-n.valid[0])/e.resolution)/o.size[0]),f[1]),w=l(Math.floor((n.origin[0]-a[0])/h[0]),c[1]),M=l(d[0]+w[0]-1,u[1]),v=!0):(w=c,M=u,d=f,v=!1),new r(e.level,e.resolution,e.scale,a,c,u,f,h,w,M,d,v)}constructor(t,o,e,l,s,i,r,n,a,h,c,u){this.level=t,this.resolution=o,this.scale=e,this.origin=l,this.first=s,this.last=i,this.size=r,this.norm=n,this.worldStart=a,this.worldEnd=h,this.worldSize=c,this.wrap=u}normalizeCol(t){if(!this.wrap)return t;const o=this.worldSize[0];return t<0?o-1-Math.abs((t+1)%o):t%o}denormalizeCol(t,o){return this.wrap?this.worldSize[0]*o+t:t}getWorldForColumn(t){return this.wrap?Math.floor(t/this.worldSize[0]):0}getFirstColumnForWorld(t){return t*this.worldSize[0]+this.first[0]}getLastColumnForWorld(t){return t*this.worldSize[0]+this.first[0]+this.size[0]-1}getColumnForX(t){return(t-this.origin[0])/this.norm[0]}getXForColumn(t){return this.origin[0]+t*this.norm[0]}getRowForY(t){return(this.origin[1]-t)/this.norm[1]}getYForRow(t){return this.origin[1]-t*this.norm[1]}getTileBounds(t,o,e=!1){i.set(o);const l=e?i.col:this.denormalizeCol(i.col,i.world),s=i.row;return function(t,o,e,l,s){t[0]=o,t[1]=e,t[2]=l,t[3]=s}(t,this.getXForColumn(l),this.getYForRow(s+1),this.getXForColumn(l+1),this.getYForRow(s)),t}getTileCoords(t,o,e=!1){i.set(o);const l=e?i.col:this.denormalizeCol(i.col,i.world);return Array.isArray(t)?s(t,this.getXForColumn(l),this.getYForRow(i.row)):(t.x=this.getXForColumn(l),t.y=this.getYForRow(i.row)),t}}class n{constructor(){this.spans=[]}acquire(t){this.lodInfo=t}release(){this.lodInfo=null,this.spans.length=0}forEach(t,o){const{spans:e,lodInfo:l}=this,{level:s}=l;if(0!==e.length)for(const{row:i,colFrom:r,colTo:n}of e)for(let e=r;e<=n;e++)t.call(o,s,i,l.normalizeCol(e),l.getWorldForColumn(e))}}n.pool=new e(n);class a{constructor(t,o,e){this.row=t,this.colFrom=o,this.colTo=e}}const h=new o("0/0/0/0");class c{static create(t,o){t[1]>o[1]&&([t,o]=[o,t]);const[e,l]=t,[s,i]=o,r=s-e,n=i-l,a=0!==n?r/n:0,h=(Math.ceil(l)-l)*a,u=(Math.floor(l)-l)*a;return new c(e,Math.floor(l),Math.ceil(i),a,r<0?h:u,r<0?u:h,r<0?s:e,r<0?e:s)}constructor(t,o,e,l,s,i,r,n){this.x=t,this.ymin=o,this.ymax=e,this.invM=l,this.leftAdjust=s,this.rightAdjust=i,this.leftBound=r,this.rightBound=n}incrRow(){this.x+=this.invM}getLeftCol(){return Math.max(this.x+this.leftAdjust,this.leftBound)}getRightCol(){return Math.min(this.x+this.rightAdjust,this.rightBound)}}const u=[[0,0],[0,0],[0,0],[0,0]];class f{constructor(t,o=null,e=t.lods[0].level,l=t.lods[t.lods.length-1].level){this.tileInfo=t,this.fullExtent=o,this.scales=[],this._infoByScale={},this._infoByLevel={};const s=t.lods.filter((t=>t.level>=e&&t.level<=l));this.minScale=s[0].scale,this.maxScale=s[s.length-1].scale;const i=this._lodInfos=s.map((e=>r.create(t,e,o)));s.forEach(((t,o)=>{this._infoByLevel[t.level]=i[o],this._infoByScale[t.scale]=i[o],this.scales[o]=t.scale}),this),this._wrap=t.isWrappable}get spatialReference(){return this.tileInfo.spatialReference}getLODInfoAt(t){return this._infoByLevel["number"==typeof t?t:t.level]}getTileBounds(t,o,e=!1){h.set(o);const l=this._infoByLevel[h.level];return l?l.getTileBounds(t,h,e):t}getTileCoords(t,o,e=!1){h.set(o);const l=this._infoByLevel[h.level];return l?l.getTileCoords(t,h,e):t}getTileCoverage(t,o=192,e=!0,l="closest"){if(!e&&(t.scale>this.minScale||t.scale<this.maxScale))return null;const s="closest"===l?this.getClosestInfoForScale(t.scale):this.getSmallestInfoForScale(t.scale),i=n.pool.acquire(s),r=this._wrap;let h,f,m,g=1/0,d=-1/0;const w=i.spans;u[0][0]=u[0][1]=u[1][1]=u[3][0]=-o,u[1][0]=u[2][0]=t.size[0]+o,u[2][1]=u[3][1]=t.size[1]+o;for(const o of u)t.toMap(o,o),o[0]=s.getColumnForX(o[0]),o[1]=s.getRowForY(o[1]);const M=[];let v=3;for(let t=0;t<4;t++){if(u[t][1]===u[v][1]){v=t;continue}const o=c.create(u[t],u[v]);g=Math.min(o.ymin,g),d=Math.max(o.ymax,d),void 0===M[o.ymin]&&(M[o.ymin]=[]),M[o.ymin].push(o),v=t}if(null==g||null==d||d-g>100)return null;let y=[];for(h=g;h<d;){null!=M[h]&&(y=y.concat(M[h])),f=1/0,m=-1/0;for(let t=y.length-1;t>=0;t--){const o=y[t];f=Math.min(f,o.getLeftCol()),m=Math.max(m,o.getRightCol())}if(f=Math.floor(f),m=Math.floor(m),h>=s.first[1]&&h<=s.last[1])if(r)if(s.size[0]<s.worldSize[0]){const t=Math.floor(m/s.worldSize[0]);for(let o=Math.floor(f/s.worldSize[0]);o<=t;o++)w.push(new a(h,Math.max(s.getFirstColumnForWorld(o),f),Math.min(s.getLastColumnForWorld(o),m)))}else w.push(new a(h,f,m));else f>s.last[0]||m<s.first[0]||(f=Math.max(f,s.first[0]),m=Math.min(m,s.last[0]),w.push(new a(h,f,m)));h+=1;for(let t=y.length-1;t>=0;t--){const o=y[t];o.ymax>=h?o.incrRow():y.splice(t,1)}}return i}getTileParentId(t){h.set(t);const o=this._infoByLevel[h.level],e=this._lodInfos.indexOf(o)-1;return e<0?null:(this._getTileIdAtLOD(h,this._lodInfos[e],h),h.id)}getTileResolution(t){const o=this._infoByLevel["object"==typeof t?t.level:t];return o?o.resolution:-1}getTileScale(t){const o=this._infoByLevel[t.level];return o?o.scale:-1}intersects(t,o){h.set(o);const e=this._infoByLevel[h.level],l=t.lodInfo;if(l.resolution>e.resolution){this._getTileIdAtLOD(h,l,h);const o=l.denormalizeCol(h.col,h.world);for(const e of t.spans)if(e.row===h.row&&e.colFrom<=o&&e.colTo>=o)return!0}if(l.resolution<e.resolution){const[o,s,i,r]=t.spans.reduce(((t,o)=>(t[0]=Math.min(t[0],o.row),t[1]=Math.max(t[1],o.row),t[2]=Math.min(t[2],o.colFrom),t[3]=Math.max(t[3],o.colTo),t)),[1/0,-1/0,1/0,-1/0]),n=e.denormalizeCol(h.col,h.world),a=l.getColumnForX(e.getXForColumn(n)),c=l.getRowForY(e.getYForRow(h.row)),u=l.getColumnForX(e.getXForColumn(n+1))-1,f=l.getRowForY(e.getYForRow(h.row+1))-1;return!(a>r||u<i||c>s||f<o)}const s=l.denormalizeCol(h.col,h.world);return t.spans.some((t=>t.row===h.row&&t.colFrom<=s&&t.colTo>=s))}normalizeBounds(o,e,l){if(o[0]=e[0],o[1]=e[1],o[2]=e[2],o[3]=e[3],this._wrap){const e=t(this.tileInfo.spatialReference),s=-l*(e.valid[1]-e.valid[0]);o[0]+=s,o[2]+=s}return o}getSmallestInfoForScale(t){const o=this.scales;if(this._infoByScale[t])return this._infoByScale[t];if(t>o[0])return this._infoByScale[o[0]];for(let e=1;e<o.length-1;e++)if(t>o[e]+1e-6)return this._infoByScale[o[e-1]];return this._infoByScale[o[o.length-1]]}getClosestInfoForScale(t){const o=this.scales;return this._infoByScale[t]||(t=o.reduce(((o,e)=>Math.abs(e-t)<Math.abs(o-t)?e:o),o[0])),this._infoByScale[t]}scaleToLevel(t){const o=this.scales;if(this._infoByScale[t])return this._infoByScale[t].level;for(let e=o.length-1;e>=0;e--)if(t<o[e])return e===o.length-1?this._infoByScale[o[o.length-1]].level:this._infoByScale[o[e]].level+(o[e]-t)/(o[e]-o[e+1]);return this._infoByScale[o[0]].level}scaleToZoom(t){return this.tileInfo.scaleToZoom(t)}_getTileIdAtLOD(t,o,e){const l=this._infoByLevel[e.level];return t.set(e),o.resolution<l.resolution?null:(o.resolution===l.resolution||(t.level=o.level,t.col=Math.floor(e.col*l.resolution/o.resolution+.01),t.row=Math.floor(e.row*l.resolution/o.resolution+.01)),t)}}export{f as T,n as a};
