/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.27/esri/copyright.txt for details.
*/
import{_ as e}from"./tslib.es6.js";import t from"../core/Evented.js";import{HandleOwner as i}from"../core/HandleOwner.js";import{eachAlwaysValues as s,throwIfAborted as n,isAborted as r}from"../core/promiseUtils.js";import{sync as o,watch as a,syncAndInitial as d}from"../core/reactiveUtils.js";import{property as c}from"../core/accessorSupport/decorators/property.js";import{s as h}from"./ensureType.js";import"./typedArrayUtil.js";import{subclass as l}from"../core/accessorSupport/decorators/subclass.js";import{project as p,initializeProjection as u}from"../geometry/projection.js";import{f as g}from"./elevationInfoUtils.js";import{d as f}from"./Settings2.js";import{a as S,L as y}from"./LineSnappingHint.js";import m from"../core/Handles.js";import{a as _,c as v,g as w,u as E,q as x,d as T,l as C}from"./vec2.js";import{C as P,c as R,b as L,a as V,h as F,s as I,r as M,x as j}from"./vec3.js";import{c as O,e as N,f as D}from"./vec3f64.js";import{g as q}from"./common.js";import{S as H,V as b,F as A,E as z,a as G,p as k,b as U,I as Z}from"./EdgeSnappingCandidate.js";import{L as W,b as X,d as B,e as J,f as K,g as Q,h as Y,p as $,i as ee}from"./snappingUtils.js";import{D as te}from"./DrapedEdgeSnappingCandidate.js";import{R as ie,P as se,I as ne}from"./RightAngleSnappingHint.js";import{a as re}from"./viewUtils.js";import oe from"../core/Accessor.js";import ae from"../core/Collection.js";import{L as de,p as ce,a as he}from"./geometry2dUtils.js";import{a as le}from"./vec2f64.js";import pe from"../views/interactive/snapping/SnappingOptions.js";class ue extends H{constructor({targetPoint:e,constraint:t,previousVertex:i,otherVertex:s,otherVertexType:n,objectId:r,isDraped:o}){super(e,t,o,S.SELF),this.previousVertex=i,this.otherVertex=s,this.otherVertexType=n,this.objectId=r}get hints(){const e=this.previousVertex,t=this.otherVertexType===ge.CENTER?this.otherVertex:this.targetPoint,i=this.otherVertexType===ge.CENTER?this.targetPoint:this.otherVertex;return[new y(W.TARGET,t,i,this.isDraped,this.domain),new y(W.REFERENCE,e,t,this.isDraped,this.domain),new ie(this.previousVertex,t,i,this.isDraped,this.domain)]}}var ge;!function(e){e[e.NEXT=0]="NEXT",e[e.CENTER=1]="CENTER"}(ge||(ge={}));let fe=class extends i{get updating(){return h(this.snappingSources,(({snappingSource:e})=>e.updating))||this.updatingHandles.updating}get snappingSources(){const e=this._get("snappingSources")||new Map,t=new Map;if(null!=this.options&&null!=this.options.featureSources)for(const i of this.options.featureSources.items){const s=i.layer.uid,n=e.get(s);if(n){e.delete(s),t.set(s,n);continue}if(!i.layer.loaded){this.updatingHandles.addPromise(i.layer.load());continue}const r=this._createSourceInfo(i);null!=r&&t.set(s,r)}for(const[,t]of e)t.destroy();return t}constructor(e){super(e),this.options=null,this._domain=S.FEATURE,this._sourceModules={featureService:{module:null,loader:null},featureCollection:{module:null,loader:null},graphics:{module:null,loader:null},notes:{module:null,loader:null},scene:{module:null,loader:null}}}initialize(){this.updatingHandles.add((()=>this.snappingSources),(()=>this.notifyChange("updating")),o),null!=this.view&&this.handles.add([this.view.on("layerview-create",(e=>this._updateLayerView(e.layer,e.layerView))),this.view.on("layerview-destroy",(e=>this._updateLayerView(e.layer,null)))])}_updateLayerView(e,t){for(const[,i]of this.snappingSources)i.snappingSource.layerSource.layer===e&&(i.layerView=t)}destroy(){this._set("options",null);for(const[,e]of this.snappingSources)e.destroy()}async fetchCandidates(e,t,i,r){if(!(t&this._domain&&null!=this.options&&this.options.effectiveFeatureEnabled))return[];const o=[],a=this._computeScreenSizeDistanceParameters(e,i),d={distance:a,mode:this.view?.type??"2d",point:e,coordinateHelper:i.coordinateHelper,...this._types};for(const[,{snappingSource:e,layerView:t}]of this.snappingSources)!e.layerSource.enabled||null!=t&&t.suspended||o.push(e.fetchCandidates(d,r).then((t=>t.filter((t=>!this._candidateIsExcluded(e,t,i.excludeFeature))))));const c=(await s(o)).flat();return this._addRightAngleCandidates(c,e,a,i),n(r),X(e,c),c}_addRightAngleCandidates(e,t,i,s){const n=null!=s.vertexHandle?s.vertexHandle.rightEdge?.rightVertex?.pos:null!=s.editGeometryOperations&&"polygon"===s.editGeometryOperations.data.type?s.editGeometryOperations.data.components[0]?.getFirstVertex()?.pos:null,r=null!=s.vertexHandle?s.vertexHandle.leftEdge?.leftVertex?.pos:null!=s.editGeometryOperations?s.editGeometryOperations.data.components[0]?.getLastVertex()?.pos:null,{view:o}=this,a=B(n,o,s),d=B(r,o,s),c=e.length;for(let s=0;s<c;s++)this._addRightAngleCandidate(e[s],d,t,i,e),this._addRightAngleCandidate(e[s],a,t,i,e)}_addRightAngleCandidate(e,t,i,s,n){if(null==t||!function(e){return(e instanceof z||e instanceof te)&&!function({constraint:{start:e,end:t}}){const i=P(e,t),s=_(e,t);return i<q()||s/i<ve}(e)}(e))return;const r=e.constraint.closestTo(t),o=(r[0]-i[0])/s.x,a=(r[1]-i[1])/s.y,{start:d,end:c}=e.constraint;if(o*o+a*a<=1){const i=new ue({targetPoint:r,otherVertex:t,otherVertexType:ge.NEXT,previousVertex:_(r,d)>_(r,c)?d:c,constraint:new b(t,r),objectId:e.objectId,isDraped:e.isDraped});n.push(i)}}_computeScreenSizeDistanceParameters(e,t){let i=null!=this.options?this.options.distance*("touch"===t.pointer?this.options.touchSensitivityMultiplier:1):0;return null==this.view?{x:i,y:i,z:i,distance:i}:"2d"===this.view.type?(i*=this.view.resolution,{x:i,y:i,z:i,distance:i}):this._computeScreenSizeDistanceParameters3D(e,i,this.view,t)}_computeScreenSizeDistanceParameters3D(e,t,i,s){const{spatialReference:n}=s;i.renderCoordsHelper.toRenderCoords(e,n,me);const r=i.state.camera.computeScreenPixelSizeAt(me),o=r*i.renderCoordsHelper.unitInMeters/i.mapCoordsHelper.unitInMeters,a=t*o,d=re(e,n,g,i),c=d?ye(d,e,o,0,0,i,s):0,h=d?ye(d,e,0,o,0,i,s):0,l=d?ye(d,e,0,0,o,i,s):0;return{x:0===c?0:a/c,y:0===h?0:a/h,z:0===l?0:a/l,distance:r*t}}get _types(){return{returnEdge:!0,returnVertex:!0}}_candidateIsExcluded(e,t,i){if(null==i)return!1;const s=this._getCandidateObjectId(t);if(null==s)return!1;const n=e.layerSource.layer;return"graphics"===n.type?i.uid===s:i.sourceLayer===n&&!(!i.attributes||!("objectIdField"in n))&&i.attributes[n.objectIdField]===s}_getCandidateObjectId(e){return e instanceof A?e.objectId:null}_createSourceInfo(e){const t=this._createFeatureSnappingSourceType(e);if(null==t)return null;if("loading"in t)return this.updatingHandles.addPromise(t.loading.then((()=>{this.destroyed||this.notifyChange("snappingSources")}))),null;const i=null!=this.view?this.view.allLayerViews.find((t=>t.layer===e.layer)):null;return new Se(t.source,i)}_createFeatureSnappingSourceType(e){switch(e.layer.type){case"feature":case"geojson":case"csv":case"oriented-imagery":case"subtype-group":case"wfs":return this._createFeatureSnappingSourceFeatureLayer(e);case"graphics":return this._createFeatureSnappingSourceGraphicsLayer(e);case"map-notes":return this._createFeatureSnappingSourceMapNotesLayer(e);case"scene":case"building-scene":return this._createFeatureSnappingSourceSceneLayer(e)}return null}_createFeatureSnappingSourceSceneLayer(e){const{view:t}=this;if(null==t||"3d"!==t.type)return null;const i=this._getSourceModule("scene");return null!=i.module?{source:new i.module.SceneLayerSnappingSource({layerSource:e,view:t})}:{loading:i.loader}}_createFeatureSnappingSourceFeatureLayer(e){switch(e.layer.source?.type){case"feature-layer":case"oriented-imagery":{const t=this._getSourceModule("featureService");return null!=t.module?{source:new t.module.FeatureServiceSnappingSource({spatialReference:this.spatialReference,view:this.view,layerSource:e})}:{loading:t.loader}}case"memory":case"csv":case"geojson":case"wfs":{if("mesh"===e.layer.geometryType)return null;const t=this._getSourceModule("featureCollection");return null!=t.module?{source:new t.module.FeatureCollectionSnappingSource({layerSource:e,view:this.view})}:{loading:t.loader}}}return null}_createFeatureSnappingSourceGraphicsLayer(e){const t=this._getSourceModule("graphics");return null!=t.module?{source:new t.module.GraphicsSnappingSource({getGraphicsLayers:()=>[e.layer],spatialReference:this.spatialReference,view:this.view,layerSource:e})}:{loading:t.loader}}_createFeatureSnappingSourceMapNotesLayer(e){const t=this._getSourceModule("notes");return null!=t.module?{source:new t.module.GraphicsSnappingSource({getGraphicsLayers:()=>null!=e.layer.sublayers?e.layer.sublayers.toArray():[],spatialReference:this.spatialReference,view:this.view,layerSource:e})}:{loading:t.loader}}_getSourceModule(e){const t=this._sourceModules[e];if(null==t.loader){const i=this._loadSourceModule(e).then((e=>{t.module=e}));return t.loader=i,{module:t.module,loader:i}}return{module:t.module,loader:t.loader}}_loadSourceModule(e){const t=this.updatingHandles;switch(e){case"featureService":return t.addPromise(import("./FeatureServiceSnappingSource.js"));case"featureCollection":return t.addPromise(import("./FeatureCollectionSnappingSource.js"));case"graphics":case"notes":return t.addPromise(import("./GraphicsSnappingSource.js"));case"scene":return t.addPromise(import("./SceneLayerSnappingSource.js"))}}};e([c({constructOnly:!0})],fe.prototype,"spatialReference",void 0),e([c({constructOnly:!0})],fe.prototype,"view",void 0),e([c()],fe.prototype,"options",void 0),e([c({readOnly:!0})],fe.prototype,"updating",null),e([c({readOnly:!0})],fe.prototype,"snappingSources",null),fe=e([l("esri.views.interactive.snapping.FeatureSnappingEngine")],fe);class Se{constructor(e,t){this.snappingSource=e,this.layerView=t,this.handles=new m;const i=this.snappingSource.layerSource.layer;if("refresh"in i){const t=i;this.handles.add(t.on("refresh",(()=>e.refresh())))}this.handles.add([a((()=>e.updating),(t=>e.layerSource.updating=t),d),a((()=>e.availability),(t=>e.layerSource.availability=t),d)])}destroy(){this.snappingSource.destroy(),this.handles.destroy()}}function ye(e,t,i,s,n,r,{spatialReference:o}){const a=R(_e,t);a[0]+=i,a[1]+=s,a[2]+=n;const d=re(a,o,g,r);return d?J(d,e):1/0}const me=O(),_e=O(),ve=1e-4;class we{constructor(e,t){this.view=e,this.options=t,this.squaredShortLineThreshold=f.shortLineThreshold*f.shortLineThreshold}snap(e,t){return null!=t.vertexHandle?"vertex"!==t.vertexHandle.type?[]:this.snapExistingVertex(e,t):this.snapNewVertex(e,t)}edgeExceedsShortLineThreshold(e,t){return this.exceedsShortLineThreshold(B(e.leftVertex.pos,this.view,t),B(e.rightVertex.pos,this.view,t),t)}exceedsShortLineThreshold(e,t,{spatialReference:i}){return 0===this.squaredShortLineThreshold||K(re(t,i,g,this.view),re(e,i,g,this.view))>this.squaredShortLineThreshold}isVertical(e,t){return _(e,t)<f.verticalLineThreshold}squaredProximityThreshold(e){return"touch"===e?this._squaredTouchProximityThreshold:this._squaredMouseProximityThreshold}get _squaredMouseProximityThreshold(){return this.options.distance*this.options.distance}get _squaredTouchProximityThreshold(){const{distance:e,touchSensitivityMultiplier:t}=this.options,i=e*t;return i*i}}class Ee extends H{constructor({lineStart:e,lineEnd:t,targetPoint:i,isDraped:s}){super(i,new G(e,t),s,S.SELF),this._referenceLineHint=new y(W.REFERENCE_EXTENSION,e,t,s,this.domain)}get hints(){return[this._referenceLineHint,new y(W.TARGET,this._lineEndClosestToTarget(),this.targetPoint,this.isDraped,this.domain)]}_lineEndClosestToTarget(){return this.constraint.closestEndTo(this.targetPoint)}}class xe extends we{snapNewVertex(e,t){const i=t.editGeometryOperations.data.components[0],s=i.edges.length,n=[];if(s<1)return n;const{spatialReference:r}=t,o=re(e,r,g,this.view),{view:a}=this,d=i.edges[s-1];let c=d;do{if(this.edgeExceedsShortLineThreshold(c,t)){const i=Q(c,a,t);this._processCandidateProposal(i.left,i.right,e,o,t,n)}c=c.leftVertex.leftEdge}while(c&&c!==d);return n}snapExistingVertex(e,t){const i=[],s=t.vertexHandle,n=s.component;if(n.edges.length<2)return i;const{view:r}=this,{spatialReference:o}=t,a=re(e,o,g,r),d=s.leftEdge,c=s.rightEdge;d&&c&&this.edgeExceedsShortLineThreshold(d,t)&&this.edgeExceedsShortLineThreshold(c,t)&&this._processCandidateProposal(B(d.leftVertex.pos,r,t),B(c.rightVertex.pos,r,t),e,a,t,i);const h=n.edges[0];let l=h;do{if(l!==s.leftEdge&&l!==s.rightEdge&&this.edgeExceedsShortLineThreshold(l,t)){const s=Q(l,r,t);this._processCandidateProposal(s.left,s.right,e,a,t,i)}l=l.rightVertex.rightEdge}while(l&&l!==h);return i}_processCandidateProposal(e,t,i,s,n,r){const{spatialReference:o,pointer:a}=n,d=Y(k(i,{start:e,end:t,type:de.LINE}));K(s,re(d,o,g,this.view))<this.squaredProximityThreshold(a)&&r.push(new Ee({lineStart:e,lineEnd:t,targetPoint:d,isDraped:"on-the-ground"===n.elevationInfo?.mode}))}}class Te extends H{constructor({referenceLine:e,lineStart:t,targetPoint:i,isDraped:s}){const n=N(t),{left:r,right:o}=e;L(n,V(n,n,o),r),super(i,new G(t,Y(n)),s,S.SELF),this._referenceLines=[{edge:e,fadeLeft:!0,fadeRight:!0}]}get hints(){return[new y(W.TARGET,this.constraint.start,this.targetPoint,this.isDraped,this.domain),new se(this.constraint.start,this.targetPoint,this.isDraped,this.domain),...this._referenceLines.map((e=>new y(W.REFERENCE,e.edge.left,e.edge.right,this.isDraped,this.domain,e.fadeLeft,e.fadeRight)))]}addReferenceLine(e){const t={edge:e,fadeLeft:!0,fadeRight:!0};this._referenceLines.forEach((i=>{F(e.right,i.edge.left)&&(i.fadeLeft=!1,t.fadeRight=!1),F(e.right,i.edge.right)&&(i.fadeRight=!1,t.fadeRight=!1),F(e.left,i.edge.right)&&(i.fadeRight=!1,t.fadeLeft=!1),F(e.left,i.edge.left)&&(i.fadeLeft=!1,t.fadeLeft=!1)})),this._referenceLines.push(t)}}class Ce extends we{snapNewVertex(e,t){const i=t.editGeometryOperations.data.components[0],s=i.edges.length,n=i.vertices.length,r=[];if(s<2)return r;const{view:o}=this,a=re(e,t.spatialReference,g,o),d=B(i.vertices[n-1].pos,o,t),c=B(i.vertices[0].pos,o,t),h=i.edges[s-1];let l=h;do{if(this.edgeExceedsShortLineThreshold(l,t)){const i=Q(l,o,t);this._checkEdgeForParallelLines(i,d,e,a,t,r),this._checkEdgeForParallelLines(i,c,e,a,t,r)}l=l.leftVertex.leftEdge}while(l&&l!==h);return r}snapExistingVertex(e,t){const i=[],s=t.vertexHandle,n=s.component;if(n.edges.length<3)return i;const{view:r}=this,o=re(e,t.spatialReference,g,r),a=s.leftEdge,d=s.rightEdge,c=n.vertices[0],h=B(c.pos,r,t),l=n.vertices.length,p=n.vertices[l-1],u=B(p.pos,r,t),f=n.edges[0];let S=f;do{if(S!==a&&S!==d&&this.edgeExceedsShortLineThreshold(S,t)){const n=Q(S,r,t);a&&this._checkEdgeForParallelLines(n,B(a.leftVertex.pos,r,t),e,o,t,i),d&&this._checkEdgeForParallelLines(n,B(d.rightVertex.pos,r,t),e,o,t,i),s===c?this._checkEdgeForParallelLines(n,u,e,o,t,i):s===p&&this._checkEdgeForParallelLines(n,h,e,o,t,i)}S=S.rightVertex.rightEdge}while(S&&S!==f);return i}_checkEdgeForParallelLines(e,t,i,s,n,r){const o=e.left,a=e.right;if(ce(Pe,t,o,a),_(Pe,t)<f.parallelLineThreshold)return;ce(Pe,i,o,a,t);const{spatialReference:d,pointer:c}=n,h=Y(D(Pe[0],Pe[1],i[2]));if(K(s,re(h,d,g,this.view))<this.squaredProximityThreshold(c)){if(this.isVertical(h,t)||this.isVertical(o,a))return;if(this._parallelToPreviousCandidate(e,r))return;r.push(new Te({referenceLine:e,lineStart:t,targetPoint:h,isDraped:"on-the-ground"===n.elevationInfo?.mode}))}}_parallelToPreviousCandidate(e,t){const i=e.left,s=e.right;for(const n of t)if(ce(Pe,s,n.constraint.start,n.constraint.end,i),_(Pe,s)<f.parallelLineThreshold)return n.addReferenceLine(e),!0;return!1}}const Pe=le();class Re extends we{snapNewVertex(e,t){const i=t.editGeometryOperations.data.components[0],s=i.vertices.length,n=[];if(s<2)return n;const{view:r}=this,o=re(e,t.spatialReference,g,r),a=i.vertices[s-1];if(this.edgeExceedsShortLineThreshold(a.leftEdge,t)){const i=B(a.pos,r,t),s=B(a.leftEdge.leftVertex.pos,r,t);this._checkForSnappingCandidate(n,s,i,e,o,t)}const d=i.vertices[0];if(this.edgeExceedsShortLineThreshold(d.rightEdge,t)){const i=B(d.pos,r,t),s=B(d.rightEdge.rightVertex.pos,r,t);this._checkForSnappingCandidate(n,s,i,e,o,t)}return n}snapExistingVertex(e,t){const i=[],s=t.vertexHandle;if(s.component.vertices.length<3)return i;const{view:n}=this,r=re(e,t.spatialReference,g,n),o=s.leftEdge,a=s.rightEdge;if(o&&o.leftVertex.leftEdge){const s=o.leftVertex.leftEdge;if(this.edgeExceedsShortLineThreshold(s,t)){const o=B(s.rightVertex.pos,n,t),a=B(s.leftVertex.pos,n,t);this._checkForSnappingCandidate(i,a,o,e,r,t)}}if(a&&a.rightVertex.rightEdge){const s=a.rightVertex.rightEdge;if(this.edgeExceedsShortLineThreshold(s,t)){const o=B(s.leftVertex.pos,n,t),a=B(s.rightVertex.pos,n,t);this._checkForSnappingCandidate(i,a,o,e,r,t)}}return i}_checkForSnappingCandidate(e,t,i,s,n,r){const{spatialReference:o,pointer:a}=r;v(Le,i,t);const d=I(Ve,Le[1],-Le[0],0),c=w(d,v(Le,s,i))/E(d),h=Y(x(N(s),i,d,c));if(K(n,re(h,o,g,this.view))<this.squaredProximityThreshold(a)){if(this.isVertical(h,i)||this.isVertical(i,t))return;const s=M(O(),i,d,Math.sign(c));e.push(new ue({targetPoint:h,constraint:new b(i,Y(s)),previousVertex:t,otherVertex:i,otherVertexType:ge.CENTER,isDraped:"on-the-ground"===r.elevationInfo?.mode}))}}}const Le=le(),Ve=O();class Fe extends H{constructor({targetPoint:e,point1:t,point2:i,isDraped:s}){super(e,new U(Y(j(O(),t,i,.5)),.5*T(t,i)),s,S.SELF),this._p1=t,this._p2=i}get hints(){return[new y(W.REFERENCE,this.targetPoint,this._p1,this.isDraped,this.domain),new y(W.REFERENCE,this.targetPoint,this._p2,this.isDraped,this.domain),new ie(this._p1,this.targetPoint,this._p2,this.isDraped,this.domain)]}}class Ie extends we{snapNewVertex(e,t){const i=t.editGeometryOperations.data.components[0],s=[],n=i.vertices.length;if("polygon"!==t.editGeometryOperations.data.type||n<2)return s;const{view:r}=this,o=i.vertices[0],a=i.vertices[n-1],d=B(o.pos,r,t),c=B(a.pos,r,t);return this._processCandidateProposal(d,c,e,t,s),s}snapExistingVertex(e,t){const i=[],s=t.vertexHandle,n=s.component;if(n.edges.length<2)return i;if("polyline"===t.editGeometryOperations.data.type&&(0===s.index||s.index===n.vertices.length-1))return i;const{view:r}=this,o=B(s.leftEdge.leftVertex.pos,r,t),a=B(s.rightEdge.rightVertex.pos,r,t);return this._processCandidateProposal(o,a,e,t,i),i}_processCandidateProposal(e,t,i,s,n){if(!this.exceedsShortLineThreshold(e,t,s))return;const r=C(Me,e,t,.5),o=.5*T(e,t),a=O();he(a,i,r,o),a[2]=i[2];const d=Y(a),{spatialReference:c,pointer:h}=s,l=re(i,c,g,this.view);if(K(l,re(d,c,g,this.view))<this.squaredProximityThreshold(h)){if(this.isVertical(e,d)||this.isVertical(d,t))return;n.push(new Fe({targetPoint:d,point1:e,point2:t,isDraped:"on-the-ground"===s.elevationInfo?.mode}))}}}const Me=le();let je=class extends oe{constructor(e){super(e),this.updating=!1,this._snappers=new ae,this._domain=S.SELF}initialize(){this._snappers.push(new Ce(this.view,this.options),new xe(this.view,this.options),new Re(this.view,this.options),new Ie(this.view,this.options))}set options(e){this._set("options",e);for(const t of this._snappers)t.options=e}async fetchCandidates(e,t,i){if(!(t&this._domain&&this.options.effectiveSelfEnabled))return[];const s=[];for(const t of this._snappers.items)for(const n of t.snap(e,i))s.push(n);return X(e,s),s}};function Oe(e,t){return[new je({view:e,options:t}),new fe({view:e,options:t,spatialReference:e.spatialReference})]}e([c({readOnly:!0})],je.prototype,"updating",void 0),e([c({constructOnly:!0})],je.prototype,"view",void 0),e([c()],je.prototype,"options",null),je=e([l("esri.views.interactive.snapping.SelfSnappingEngine")],je);class Ne extends H{constructor(e,t,i,s){super(e,new Z(e,t.constraint,i.constraint),s,S.ALL),this.first=t,this.second=i}get hints(){return this.first.targetPoint=this.targetPoint,this.second.targetPoint=this.targetPoint,[...this.first.hints,...this.second.hints,new ne(this.targetPoint,this.isDraped,this.domain)]}}let De=class extends(t.EventedMixin(i)){constructor(e){super(e),this.options=new pe,this.snappingEnginesFactory=Oe,this._engines=[],this._currentMainCandidate=null,this._currentOtherActiveCandidates=[],this._currentSnappedType=qe.MAIN}initialize(){this.handles.add([a((()=>{const{effectiveFeatureEnabled:e,effectiveSelfEnabled:t,touchSensitivityMultiplier:i,distance:s}=this.options;return{effectiveFeatureEnabled:e,effectiveSelfEnabled:t,touchSensitivityMultiplier:i,distance:s}}),(()=>{this.doneSnapping(),this.emit("changed")}),o),a((()=>this.options),(e=>{for(const t of this._engines)t.options=e}),o),a((()=>({viewReady:this.view.ready,viewSpatialReference:this.view.spatialReference,snappingEnginesFactory:this.snappingEnginesFactory})),(({viewReady:e,snappingEnginesFactory:t})=>this._recreateEngines(e,t)),d)])}destroy(){this._destroyEngines()}get updating(){return this._engines.some((e=>e.updating))}_recreateEngines(e,t){if(this._destroyEngines(),!e)return;const{view:i,options:s}=this;this._engines=t(i,s)}_destroyEngines(){for(const e of this._engines)e.destroy();this._engines=[]}get _squaredMouseProximityTreshold(){return this.options.distance*this.options.distance}get _squaredTouchProximityThreshold(){const{distance:e,touchSensitivityMultiplier:t}=this.options,i=e*t;return i*i}get _squaredSatisfiesConstraintThreshold(){return f.satisfiesConstraintScreenThreshold*f.satisfiesConstraintScreenThreshold}async snap(e){return function(e){return null!=e.scenePoint}(e)?this._snapMultiPoint(e):this._snapSinglePoint(e)}update(e){const{point:t,context:i}=e;this._removeVisualization();const s=this._currentMainCandidate;if(null==s)return t;const n=this._selectUpdateInput(e);if(null==n)return t;const{spatialReference:r}=i,o=p(n,r);if(null==o)return t;const{view:a}=this,{elevationInfo:d,visualizer:c}=i,h=[],l=$(o,a,i),u=s.constraint.closestTo(l);if(!this._arePointsWithinScreenThreshold(l,u,i))return this._resetSnappingState(),t;s.targetPoint=u,h.push(...s.hints);for(const e of this._currentOtherActiveCandidates)e.targetPoint=u,h.push(...e.hints);return null!=c&&this.handles.add(c.draw(h,{spatialReference:r,elevationInfo:be(i),view:a,selfSnappingZ:i.selfSnappingZ}),He),ee(u,a,{z:t.z,m:t.m,spatialReference:t.spatialReference,elevationInfo:d})}doneSnapping(){this._removeVisualization(),this._resetSnappingState()}_selectUpdateInput({point:e,scenePoint:t}){switch(this._currentSnappedType){case qe.MAIN:return e;case qe.SCENE:return t}}_resetSnappingState(){this._currentMainCandidate=null,this._currentOtherActiveCandidates=[],this._currentSnappedType=qe.MAIN}_removeVisualization(){this.handles.remove(He)}async _snapSinglePoint({point:e,context:t,signal:i}){const{view:s}=this,n=$(e,s,t),r=await this._fetchCandidates(n,S.ALL,t,i);return this._createSnapResult(n,qe.MAIN,r,s,t,{z:e.z,m:e.m,spatialReference:e.spatialReference,elevationInfo:t.elevationInfo},i)}async _snapMultiPoint({point:e,scenePoint:t,context:i,signal:s}){const{view:n}=this,{coordinateHelper:r,spatialReference:o}=i;await u(t.spatialReference,o);const a=p(t,o),d=$(a,n,i),c=await this._fetchCandidates(d,S.FEATURE,i,s);if(c.length>0){const e=await this._fetchCandidates(d,S.SELF,i,s);return this._createSnapResult(d,qe.SCENE,[...c,...e],n,i,{z:a.z,m:a.m,spatialReference:a.spatialReference,elevationInfo:i.elevationInfo},s)}const h=$(e,n,i),l=await this._fetchCandidates(h,S.SELF,i,s);return this._createSnapResult(h,qe.MAIN,l,n,i,{z:r.hasZ()&&e.hasZ?e.z??0:void 0,m:r.hasM()&&e.hasM?e.m??0:void 0,spatialReference:e.spatialReference,elevationInfo:i.elevationInfo},s)}async _fetchCandidates(e,t,i,s){return(await Promise.all(this._engines.map((n=>n.fetchCandidates(e,t,i,s))))).flat()}_createSnapResult(e,t,i,s,n,o,a){return{get valid(){return!r(a)},apply:()=>{const{spatialReference:r}=n,{snappedPoint:a,hints:d}=this._processCandidates(e,t,i,n);return this._removeVisualization(),null!=n.visualizer&&this.handles.add(n.visualizer.draw(d,{spatialReference:r,elevationInfo:g,view:s,selfSnappingZ:n.selfSnappingZ}),He),ee(a,s,o)}}}_processCandidates(e,t,i,s){if(i.length<1)return this.doneSnapping(),{snappedPoint:e,hints:[]};this._currentSnappedType!==t&&this._resetSnappingState(),X(e,i);const n=this._currentMainCandidate;if(null!=n){const r=this._findOldConstraintInNewCandidates(n,i);if(r>=0){if(!(i[r]instanceof Ne))return this._intersectWithOtherCandidates(r,i,e,t,s);if(this._arePointsWithinScreenThreshold(e,n.targetPoint,s))return this._updateSnappingCandidate(n,t,i,s)}}return this._intersectWithOtherCandidates(0,i,e,t,s)}_findOldConstraintInNewCandidates(e,t){return e instanceof Ne?this._findOldCandidateIndex(t,e.first)>=0&&this._findOldCandidateIndex(t,e.second)>=0?0:-1:this._findOldCandidateIndex(t,e)}_intersectWithOtherCandidates(e,t,i,s,n){const{coordinateHelper:r}=n,o=t[e],a=[];for(let s=0;s<t.length;++s){if(s===e)continue;const n=t[s];for(const e of o.constraint.intersect(n.constraint)){const t=e.closestTo(o.targetPoint);a.push([new Ne(t,o,n,n.isDraped),this._squaredScreenDistance(i,t,r)])}}return a.length>0&&(a.sort(((e,t)=>e[1]-t[1])),a[0][1]<this._squaredPointProximityThreshold(n.pointer))?this._updateSnappingCandidate(a[0][0],s,t,n):this._updateSnappingCandidate(o,s,t,n)}_updateSnappingCandidate(e,t,i,s){this.doneSnapping(),this._currentMainCandidate=e,this._currentSnappedType=t;const n=this._currentMainCandidate.targetPoint,r=[];r.push(...e.hints);for(const t of i){if(e instanceof Ne){if(t.constraint.equals(e.first.constraint)||t.constraint.equals(e.second.constraint))continue}else if(t.constraint.equals(e.constraint))continue;const i=t.constraint.closestTo(n);this._squaredScreenDistance(i,n,s.coordinateHelper)<this._squaredSatisfiesConstraintThreshold&&(t.targetPoint=n,this._currentOtherActiveCandidates.push(t),r.push(...t.hints))}return{snappedPoint:n,hints:r}}_squaredPointProximityThreshold(e){return"touch"===e?this._squaredTouchProximityThreshold:this._squaredMouseProximityTreshold}_arePointsWithinScreenThreshold(e,t,i){return this._squaredScreenDistance(e,t,i.coordinateHelper)<this._squaredPointProximityThreshold(i.pointer)}_squaredScreenDistance(e,t,i){return K(this._toScreen(e,i),this._toScreen(t,i))}_toScreen(e,t){return re(e,t.spatialReference,g,this.view)}_findOldCandidateIndex(e,t){let i=-1;for(let s=0;s<e.length;++s)if(t.constraint.equals(e[s].constraint)){i=s;break}return i}get test(){return{visualizationsActive:this.handles.has(He),engines:this._engines}}};var qe;e([c({constructOnly:!0})],De.prototype,"view",void 0),e([c()],De.prototype,"options",void 0),e([c({readOnly:!0})],De.prototype,"updating",null),e([c()],De.prototype,"snappingEnginesFactory",void 0),e([c()],De.prototype,"_engines",void 0),e([c()],De.prototype,"_squaredMouseProximityTreshold",null),e([c()],De.prototype,"_squaredTouchProximityThreshold",null),e([c()],De.prototype,"_squaredSatisfiesConstraintThreshold",null),De=e([l("esri.views.interactive.snapping.SnappingManager")],De),function(e){e[e.MAIN=0]="MAIN",e[e.SCENE=1]="SCENE"}(qe||(qe={}));const He="visualization-handle";function be({coordinateHelper:e,elevationInfo:t}){return e.hasZ()?g:t}export{fe as F,De as S};
