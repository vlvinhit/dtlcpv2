/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.27/esri/copyright.txt for details.
*/
import"../geometry.js";import e from"../core/Error.js";import{a as n}from"./screenUtils.js";import t from"../geometry/SpatialReference.js";import{q as s}from"./quantizationUtils.js";import{d as i,h as r}from"./unitUtils.js";import{isNumericField as o,numericTypes as l}from"../layers/support/fieldUtils.js";import{c as a,e as u}from"./heatmapUtils.js";import{p as f,g as c}from"./utils9.js";import{l as m}from"./arcadeOnDemand.js";import d from"../geometry/Point.js";let p=null;function h(e,n,t,o){const l=i(t)?r(t):null,a=l?Math.round((l.valid[1]-l.valid[0])/n.scale[0]):null;return e.map((e=>{const t=new d(e.geometry);return s(n,t,t,t.hasZ,t.hasM),e.geometry=l?function(e,n,t){return e.x<0?e.x+=n:e.x>t&&(e.x-=n),e}(t,a??0,o[0]):t,e}))}function $(e,t=18,s,i,r,o){const l=new Float64Array(r*o);t=Math.round(n(t));let f=Number.POSITIVE_INFINITY,c=Number.NEGATIVE_INFINITY,m=0,d=0,p=0,h=0;const $=a(i,s);for(const{geometry:n,attributes:s}of e){const{x:e,y:i}=n,a=Math.max(0,e-t),y=Math.max(0,i-t),I=Math.min(o,i+t),g=Math.min(r,e+t),j=+$(s);for(let n=y;n<I;n++)for(let s=a;s<g;s++){const o=n*r+s,a=u(s-e,n-i,t),$=l[o];m=l[o]+=a*j;const y=m-$;d+=y,p+=y*y,m<f&&(f=m),m>c&&(c=m),h++}}if(!h)return{mean:0,stddev:0,min:0,max:0,mid:0,count:0};const y=(c-f)/2;return{mean:d/h,stdDev:Math.sqrt((p-d*d/h)/h),min:f,max:c,mid:y,count:h}}async function y(e,n){if(!n)return[];const{field:s,field2:i,field3:r,fieldDelimiter:o}=e,l=e.valueExpression,a=e.normalizationType,u=e.normalizationField,d=e.normalizationTotal,h=[],$=e.viewInfoParams;let y=null,I=null;if(l){if(!p){const{arcadeUtils:e}=await m();p=e}p.hasGeometryOperations(l)&&await p.enableGeometryOperations(),y=p.createFunction(l),I=$&&p.getViewInfo({viewingMode:$.viewingMode,scale:$.scale,spatialReference:new t($.spatialReference)})}const g=e.fieldInfos,j=n[0]&&"declaredClass"in n[0]&&"esri.Graphic"===n[0].declaredClass||!g?null:{fields:g};return n.forEach((e=>{const n=e.attributes;let t;if(l){const n=j?{...e,layer:j}:e,s=p.createExecContext(n,I);t=p.executeFunction(y,s)}else n&&(t=n[s],i&&(t=`${f(t)}${o}${f(n[i])}`,r&&(t=`${t}${o}${f(n[r])}`)));if(a&&"number"==typeof t&&isFinite(t)){const e=n&&parseFloat(n[u]);t=c(t,a,e,d)}h.push(t)})),h}function I(e){const n=e.field,t=e.normalizationType,s=e.normalizationField;let i;return"field"===t?i="(NOT "+s+" = 0)":"log"!==t&&"natural-log"!==t&&"square-root"!==t||(i=`(${n} > 0)`),i}function g(e,n,t){const s=null!=n?e+" >= "+n:"",i=null!=t?e+" <= "+t:"";let r="";return r=s&&i?w(s,i):s||i,r?"("+r+")":""}function j(n,t,s,i){let r;return t?t.name!==n.objectIdField&&i.includes(t.type)||(r=new e(s,"'field' should be one of these types: "+i.join(","))):r=new e(s,"'field' is not defined in the layer schema"),r}function x(n,t,s){let i;return t?t.name!==n.objectIdField&&o(t)||(i=new e(s,"'field' should be one of these numeric types: "+l.join(","))):i=new e(s,"'field' is not defined in the layer schema"),i}function w(e,n){let t=null!=e?e:"";return null!=n&&n&&(t=t?"("+t+") AND ("+n+")":n),t}function F(n,t){if(n&&"intersects"!==n.spatialRelationship)return new e(t,"Only 'intersects' spatialRelationship is supported for featureFilter")}function b(n,t,s){const i=function(e){const n=e.layer;return e.fields.filter((e=>!n.getField(e)))}({layer:n,fields:t});if(i.length)return new e(s,"Unknown fields: "+i.join(", ")+". You can only use fields defined in the layer schema");const r=function(e){const n=e.layer;return e.fields.filter((e=>{const t=n.getFieldUsageInfo(e);return!t||!t.supportsStatistics}))}({layer:n,fields:t});return r.length?new e(s,"Unsupported fields: "+r.join(", ")+". You can only use fields that can be fetched i.e. AdapterFieldUsageInfo.supportsStatistics must be true"):void 0}function v(e,n,t){const s=[],i=[],r=[],o=[],l=[];e.forEach(((e,n)=>{const a=e.field?"field":"expression",u=e.field||e.valueExpression;e.field?(l.push(u),i.push(`var ${a}${n} = Number($feature["${u}"]);`)):(s.push(`function getValueForExpr${n}() {\n  ${u} \n}`),i.push(`var ${a}${n} = Number(getValueForExpr${n}());`)),t||r.push(`${a}${n} = IIf(${a}${n} < 0, 0, ${a}${n});`),o.push(`${a}${n}`)}));let a="return sum;";const u=s.length?null:l.reduce(((e,n)=>`${e} + ${n}`));let f=null;return n||t?n?t||(a="return IIf(sum >= 0, sum, null);",u&&(f=`(( ${u} ) >= 0)`)):(a="return IIf(sum != 0, sum, null);",u&&(f=`(( ${u} ) <> 0)`)):(a="return IIf(sum > 0, sum, null);",u&&(f=`(( ${u} ) > 0)`)),{valueExpression:[s.length?s.join("\n"):"",i.join("\n"),r.join("\n"),`var sum = ${o.join(" + ")};`,a].filter(Boolean).join("\n\n"),sqlExpression:u,sqlWhere:f}}export{g as a,y as b,$ as c,x as d,F as e,j as f,I as g,v as h,w as m,h as q,b as v};
