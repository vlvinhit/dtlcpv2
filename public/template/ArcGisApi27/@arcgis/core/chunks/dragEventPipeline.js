/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.27/esri/copyright.txt for details.
*/
import{_ as t}from"./tslib.es6.js";import e from"../core/Accessor.js";import{L as n}from"./Logger.js";import{createResolver as a}from"../core/promiseUtils.js";import{property as r}from"../core/accessorSupport/decorators/property.js";import"./ensureType.js";import{i}from"./typedArrayUtil.js";import{subclass as o}from"../core/accessorSupport/decorators/subclass.js";import{E as s}from"./interfaces4.js";import l from"../core/Collection.js";import"../geometry.js";import{clone as c}from"../core/lang.js";import{c as u}from"./mathUtils.js";import{c as p}from"./screenUtils.js";import{e as h}from"./vec3f64.js";import{project as d}from"../geometry/projection.js";import{h as m,c as f}from"./hydratedFeatures.js";import{M as y}from"./interfaces5.js";import{d as v}from"./elevationInfoUtils.js";import{V as g}from"./ViewingMode.js";import{m as E}from"./drawUtils.js";import b from"../geometry/Point.js";var _;!function(t){t[t.WhenToolEditable=0]="WhenToolEditable",t[t.WhenToolNotEditable=1]="WhenToolNotEditable",t[t.Always=2]="Always"}(_||(_={}));class M{constructor(){this._isToolEditable=!0,this._manipulators=new l,this._resourceContexts={manipulator3D:{}},this._attached=!1}set isToolEditable(t){this._isToolEditable=t}get length(){return this._manipulators.length}add(t,e=_.WhenToolEditable){this.addMany([t],e)}addMany(t,e=_.WhenToolEditable){for(const n of t){const t={manipulator:n,visibilityPredicate:e,attached:!1};this._manipulators.add(t),this._attached&&this._updateManipulatorAttachment(t)}}remove(t){for(let e=0;e<this._manipulators.length;e++)if(this._manipulators.at(e).manipulator===t){const t=this._manipulators.splice(e,1)[0];this._detachManipulator(t);break}}removeAll(){this._manipulators.forEach((t=>{this._detachManipulator(t)})),this._manipulators.removeAll()}attach(){this._manipulators.forEach((t=>{this._updateManipulatorAttachment(t)})),this._attached=!0}detach(){this._manipulators.forEach((t=>{this._detachManipulator(t)})),this._attached=!1}destroy(){this.detach(),this._manipulators.forEach((({manipulator:t})=>{t.destroy&&t.destroy()})),this._manipulators.destroy(),this._resourceContexts=null}on(t,e){return this._manipulators.on(t,(t=>{e(t)}))}forEach(t){for(const e of this._manipulators.items)t(e)}some(t){return this._manipulators.items.some(t)}toArray(){const t=[];return this.forEach((e=>t.push(e.manipulator))),t}intersect(t,e){let n=null,a=Number.MAX_VALUE;return this._manipulators.forEach((({manipulator:r,attached:i})=>{if(!i||!r.interactive)return;const o=r.intersectionDistance(t,e);null!=o&&o<a&&(a=o,n=r)})),n}_updateManipulatorAttachment(t){this._isManipulatorItemVisible(t)?this._attachManipulator(t):this._detachManipulator(t)}_attachManipulator(t){t.attached||(t.manipulator.attach&&t.manipulator.attach(this._resourceContexts),t.attached=!0)}_detachManipulator(t){if(!t.attached)return;const e=t.manipulator;e.grabbing=!1,e.dragging=!1,e.hovering=!1,e.selected=!1,e.detach&&e.detach(this._resourceContexts),t.attached=!1}_isManipulatorItemVisible(t){return t.visibilityPredicate===_.Always||(this._isToolEditable?t.visibilityPredicate===_.WhenToolEditable:t.visibilityPredicate===_.WhenToolNotEditable)}}let S=class extends e{constructor(t){super(t),this.manipulators=new M,this.automaticManipulatorSelection=!0,this.hasGrabbedManipulators=!1,this.hasHoveredManipulators=!1,this.firstGrabbedManipulator=null,this.created=!1,this.removeIncompleteOnCancel=!0,this._editableFlags=new Map([[s.MANAGER,!0],[s.USER,!0]]),this._creationFinishedResolver=a()}get active(){return null!=this.view&&this.view.activeTool===this}set visible(t){this._get("visible")!==t&&(this._set("visible",t),this._syncVisible())}get editable(){return this.getEditableFlag(s.USER)}set editable(t){this.setEditableFlag(s.USER,t)}get updating(){return!1}get cursor(){return null}get hasFocusedManipulators(){return this.hasGrabbedManipulators||this.hasHoveredManipulators}destroy(){this.manipulators.destroy(),this._set("view",null)}onAdd(){this._syncVisible()}activate(){null!=this.view?(this.view.focus(),this.onActivate()):n.getLogger(this).error("Can't activate tool if view is not defined.")}deactivate(){this.onDeactivate()}handleInputEvent(t){this.onInputEvent(t)}handleInputEventAfter(t){this.onInputEventAfter(t)}setEditableFlag(t,e){this._editableFlags.set(t,e),this.manipulators.isToolEditable=this.internallyEditable,this._updateManipulatorAttachment(),t===s.USER&&this.notifyChange("editable"),this.onEditableChange(),this.onManipulatorSelectionChanged()}getEditableFlag(t){return this._editableFlags.get(t)??!1}whenCreated(){return this._creationFinishedResolver.promise}onManipulatorSelectionChanged(){}onActivate(){}onDeactivate(){}onShow(){}onHide(){}onEditableChange(){}onInputEvent(t){}onInputEventAfter(t){}get internallyEditable(){return this.getEditableFlag(s.USER)&&this.getEditableFlag(s.MANAGER)}finishToolCreation(){this.created||this._creationFinishedResolver.resolve(this),this._set("created",!0)}_syncVisible(){if(this.initialized)if(this.visible)this._show();else if(this._hide(),this.active)return void(this.view.activeTool=null)}_show(){this._updateManipulatorAttachment(),this.onShow()}_hide(){this._updateManipulatorAttachment(),this.onHide()}_updateManipulatorAttachment(){this.visible?this.manipulators.attach():this.manipulators.detach()}};function x(t,e){return t.events.on("drag",function(t,e){let n=null,a=null;return r=>{if("cancel"===r.action)return void(null!=a&&(a.execute({action:"cancel"}),n=null,a=null));const i={action:r.action,screenStart:r.start,screenEnd:r.screenPoint};"start"===r.action&&null==n&&(n=new U,a=new U,e(t,n,a,r.pointerType,i)),null!=n&&n.execute(i),"end"===r.action&&null!=n&&(n=null,a=null)}}(t,e))}function A(t,e){const n=[t.x,t.y,t.z??0],a=e,r=[Math.cos(a),Math.sin(a)],i=Math.sqrt(r[0]*r[0]+r[1]*r[1]);if(0===i)return null;r[0]/=i,r[1]/=i;const o=t=>{const e=(t.x-n[0])*r[0]+(t.y-n[1])*r[1];t.x=n[0]+e*r[0],t.y=n[1]+e*r[1]};return t=>(o(t.mapStart),o(t.mapEnd),{...t,axis:r})}function w(t,e){let n=null;return a=>{if("start"===a.action&&(n=function(t,e,n){const a=t.geometry,r=m(e);if(null==a)return null;if("mesh"===a.type)return function(t,e,n,a){if(e.vertexSpace.isRelative)return function(t,e,n,a){const r=R(n.getOriginPoint(e.spatialReference),a),i=e.spatialReference;return null==r?null:{move:(e,a,o,s)=>{const l=E(r.clone(),e,a,o);if(l.spatialReference.equals(i))n.setOriginFormPoint(l);else{const t=d(l,i);null!=t&&n.setOriginFormPoint(t)}if(n.isGeoreferenced)t.notifyGeometryChanged();else{const e="end"===s;t.notifyMeshTransformChanged(e?{action:y.UpdateFastLocalOrigin}:{})}}}}(t,e,e.vertexSpace,n);if(!e.spatialReference.equals(n))return null;let r=0,i=0,o=0;return{move:(n,s,l)=>{const c=n-r,u=s-i,p=l-o;if(c||u||p){const h=new b(e.origin.x+c,e.origin.y+u,(e.origin.z??0)+p,e.origin.spatialReference);e.centerAt(h,{geographic:e.vertexSpace.isRelative?void 0:a===g.Global}),t.notifyGeometryChanged(),r=n,i=s,o=l}}}}(t,a,r,n);const i=R(a,r),o=a.spatialReference;return null==i?null:{move:(e,n,a)=>{const r=E(i.clone(),e,n,a);r.spatialReference.equals(o)?t.geometry=r:t.geometry=d(r,o)}}}(t,a.mapStart.spatialReference,e)),null==n)return null;const r=a.mapEnd.x-a.mapStart.x,i=a.mapEnd.y-a.mapStart.y,o=a.mapEnd.z-a.mapStart.z;return n.move(r,i,o,a.action),{...a,translationX:r,translationY:i,translationZ:o}}}function R(t,e){return null==t?null:t.spatialReference.equals(e)?t.clone():d(t,e)}function j(t,e=null,n){let a=null;const r=null==e||t.spatialReference?.equals(e)?t=>t:t=>null!=t?d(t,e):t,i={exclude:[],...n};return e=>{if("start"===e.action&&(a=r(t.toMap(e.screenStart,i))),null==a)return null;const n=r(t.toMap(e.screenEnd,i));return null!=n?{...e,mapStart:a,mapEnd:n}:null}}function T(t,e){const n=t.map((t=>w(t,e))).filter(i);return t=>{const e=t.mapEnd.x-t.mapStart.x,a=t.mapEnd.y-t.mapStart.y,r=t.mapEnd.z-t.mapStart.z;return n.forEach((e=>e(t))),{...t,translationX:e,translationY:a,translationZ:r}}}function C(t,e){const n=new Map;for(const a of e)n.set(a,c(t[a]));return e=>(n.forEach(((e,n)=>{t[n]=e})),e)}function F(t){return null!=t.geometry&&"mesh"===t.geometry.type?function(t,e){const{vertexSpace:n}=e;if(n.isGeoreferenced){const n=e.vertexAttributes.clonePositional();return a=>(e.vertexAttributes=n,t.notifyGeometryChanged(),a)}const a=h(n.origin),r=e.transform?.clone();return n=>(e.transform=r,e.vertexSpace.origin=a,t.notifyMeshTransformChanged(),n)}(t,t.geometry):C(t,["geometry"])}function z(t){const e=t.map((t=>F(t))).filter((t=>null!=t));return t=>(e.forEach((e=>e(t))),t)}function G(){let t=0,e=0,n=0;return a=>{"start"===a.action&&(t=a.mapStart.x,e=a.mapStart.y,n=a.mapStart.z);const r=a.mapEnd.x-t,i=a.mapEnd.y-e,o=a.mapEnd.z-n;return t=a.mapEnd.x,e=a.mapEnd.y,n=a.mapEnd.z,{...a,mapDeltaX:r,mapDeltaY:i,mapDeltaZ:o,mapDeltaSpatialReference:a.mapStart.spatialReference}}}function I(){let t=0,e=0;return n=>{"start"===n.action&&(t=n.screenStart.x,e=n.screenStart.y);const a=n.screenEnd.x-t,r=n.screenEnd.y-e;return t=n.screenEnd.x,e=n.screenEnd.y,{...n,screenDeltaX:a,screenDeltaY:r}}}function O(t,e){let n=null,a=0,r=0;return i=>{if("start"===i.action&&(n=t.toScreen?.(e),null!=n&&(n.x<0||n.x>t.width||n.y<0||n.y>t.height?n=null:(a=i.screenStart.x-n.x,r=i.screenStart.y-n.y))),null==n)return null;const o=u(i.screenEnd.x-a,0,t.width),s=u(i.screenEnd.y-r,0,t.height),l=p(o,s);return i.screenStart=n,i.screenEnd=l,i}}t([r({constructOnly:!0})],S.prototype,"view",void 0),t([r({readOnly:!0})],S.prototype,"active",null),t([r({value:!0})],S.prototype,"visible",null),t([r({value:!0})],S.prototype,"editable",null),t([r({readOnly:!0})],S.prototype,"manipulators",void 0),t([r({readOnly:!0})],S.prototype,"updating",null),t([r()],S.prototype,"cursor",null),t([r({readOnly:!0})],S.prototype,"automaticManipulatorSelection",void 0),t([r()],S.prototype,"hasFocusedManipulators",null),t([r()],S.prototype,"hasGrabbedManipulators",void 0),t([r()],S.prototype,"hasHoveredManipulators",void 0),t([r()],S.prototype,"firstGrabbedManipulator",void 0),t([r({readOnly:!0})],S.prototype,"created",void 0),t([r({readOnly:!0})],S.prototype,"removeIncompleteOnCancel",void 0),S=t([o("esri.views.interactive.InteractiveToolBase")],S);const P=()=>{};class U{constructor(){this.execute=P}next(t,e=new U){return null!=t&&(this.execute=n=>{const a=t(n);null!=a&&e.execute(a)}),e}}function D(t,e,n=[]){if("2d"===t.type)return t=>t;let a=null;return r=>{"start"===r.action&&(a=t.toMap(r.screenStart,{exclude:n}),null!=a&&(a.z=v(a,t,e)));const i=t.toMap(r.screenEnd,{exclude:n});null!=i&&(i.z=v(i,t,e));const o=null!=a&&null!=i?{sceneStart:a,sceneEnd:i}:null;return{...r,scenePoints:o}}}function V(t,e,n){const a=e.elevationProvider.getElevation(t.x,t.y,t.z??0,t.spatialReference,"scene")??0,r=f(t);return r.z=a,r.hasZ=!0,r.z=v(r,e,n),r}function W(t,e){if("2d"===t.type)return t=>t;let n=null;return a=>{"start"===a.action&&(n=V(a.mapStart,t,e));const r=V(a.mapEnd,t,e),i=null!=n&&null!=r?{sceneStart:n,sceneEnd:r}:null;return{...a,scenePoints:i}}}export{U as E,S as I,M,j as a,F as b,x as c,w as d,O as e,A as f,I as g,G as h,T as i,z as j,W as k,C as r,D as s};
