/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.27/esri/copyright.txt for details.
*/
import{_ as t}from"./tslib.es6.js";import{throwIfAborted as e}from"../core/promiseUtils.js";import"./Logger.js";import"./ensureType.js";import"./typedArrayUtil.js";import"../core/Error.js";import{subclass as s}from"../core/accessorSupport/decorators/subclass.js";import{r as o,z as i,a as r}from"./vec3.js";import{c as n,e as d}from"./vec3f64.js";import{c,f as a,i as m}from"./lineSegment.js";import{c as p,b as u,l as j}from"./sphere.js";import{O as h}from"./Octree.js";import{e as l}from"./edgeProcessing.js";import"./maybe.js";import"../core/lang.js";import"./object.js";import"../config.js";import"./string.js";import"./metadata.js";import"./utils.js";import"./tracking.js";import"./common.js";import"./mathUtils.js";import"./vec4.js";import"./ray.js";import"./nextTick.js";import"./ByteSizeUnit.js";import"./mat3f64.js";import"./mat4f64.js";import"./quatf64.js";import"./vec2f64.js";import"./vec4f64.js";import"./mat4.js";import"./vector.js";import"./ObjectPool.js";import"./PooledArray.js";import"./frustum.js";import"./plane.js";import"./mathUtils2.js";import"./Util2.js";import"./deduplicate.js";import"./Indices.js";import"./InterleavedLayout.js";import"./BufferView.js";import"./vec2.js";import"./types.js";import"./VertexAttribute.js";import"./glUtil.js";import"./enums3.js";import"./VertexElementDescriptor.js";function g(t,e,s){const n=p(),d=u(n);return o(d,d,t,.5),o(d,d,e,.5),n[3]=i(d,t),r(d,d,s),n}let f=class{constructor(){this._idToComponent=new Map,this._components=new h((t=>t.bounds)),this._edges=new h((t=>t.bounds)),this._tmpLineSegment=c(),this._tmpP1=n(),this._tmpP2=n(),this._tmpP3=n(),this.remoteClient=null}async fetchCandidates(t,s){await Promise.resolve(),e(s),await this._ensureEdgeLocations(t,s);const o=[];return this._edges.forEachNeighbor((e=>(this._addCandidates(t,e,o),o.length<1e3)),t.bounds),{result:{candidates:o}}}async _ensureEdgeLocations(t,e){const s=[];if(this._components.forEachNeighbor((t=>{if(null==t.info){const{id:e,uid:o}=t;s.push({id:e,uid:o})}return!0}),t.bounds),!s.length)return;const o={components:s},i=await this.remoteClient.invoke("fetchAllEdgeLocations",o,e??{});for(const t of i.components)this._setFetchEdgeLocations(t)}async add(t){const e=new b(t.id,t.bounds);return this._idToComponent.set(e.id,e),this._components.add([e]),{result:{}}}async remove(t){const e=this._idToComponent.get(t.id);if(e){const t=[];this._edges.forEachNeighbor((s=>(s.component===e&&t.push(s),!0)),e.bounds),this._edges.remove(t),this._components.remove([e]),this._idToComponent.delete(e.id)}return{result:{}}}_setFetchEdgeLocations(t){const e=this._idToComponent.get(t.id);if(null==e||t.uid!==e.uid)return;const s=l.createView(t.locations),o=new Array(s.count),i=n(),r=n();for(let n=0;n<s.count;n++){s.position0.getVec(n,i),s.position1.getVec(n,r);const d=g(i,r,t.origin),c=new y(e,n,d);o[n]=c}this._edges.add(o);const{objectIds:d,origin:c}=t;e.info={locations:s,objectIds:d,origin:c}}_addCandidates(t,e,s){const{info:o}=e.component,{origin:i,objectIds:n}=o,d=o.locations,c=d.position0.getVec(e.index,this._tmpP1),a=d.position1.getVec(e.index,this._tmpP2);r(c,c,i),r(a,a,i);const m=n[d.componentIndex.get(e.index)];this._addEdgeCandidate(t,m,c,a,s),this._addVertexCandidate(t,m,c,s),this._addVertexCandidate(t,m,a,s)}_addEdgeCandidate(t,e,s,o,r){if(!t.returnEdge)return;const n=u(t.bounds),c=a(s,o,this._tmpLineSegment),p=m(c,n,this._tmpP3);j(t.bounds,p)&&r.push({type:"edge",objectId:e,target:d(p),distance:i(n,p),start:d(s),end:d(o)})}_addVertexCandidate(t,e,s,o){if(!t.returnVertex)return;const r=u(t.bounds);j(t.bounds,s)&&o.push({type:"vertex",objectId:e,target:d(s),distance:i(r,s)})}};f=t([s("esri.views.interactive.snapping.featureSources.sceneLayerSource.SceneLayerSnappingSourceWorker")],f);const _=f;class b{constructor(t,e){this.id=t,this.bounds=e,this.info=null,this.uid=++b.uid}}b.uid=0;class y{constructor(t,e,s){this.component=t,this.index=e,this.bounds=s}}export{_ as default};
