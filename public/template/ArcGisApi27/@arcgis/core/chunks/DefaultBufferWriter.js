/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.27/esri/copyright.txt for details.
*/
import{N as t,p as e,e as i}from"./typedArrayUtil.js";import{I as s,b as r}from"./mat4f64.js";import{x as n,C as o,s as a,a as f,e as u,E as l,d as c}from"./vec3.js";import{a as h,c as d}from"./Indices.js";import{O as m,R as g,S as p}from"./basicInterfaces.js";import{P as A}from"./PooledArray.js";import{c as _,f as b,e as E}from"./vec3f64.js";import{a as y}from"./Util2.js";import{a as I,C as P}from"./Material.js";import{b as v}from"./triangle.js";import{g as O}from"./watch.js";import{V as x}from"./VertexAttribute.js";import{e as L}from"./doublePrecisionUtils.js";import{g as T,h as M}from"./enums3.js";import{k as B,l as S}from"./mat4.js";import{b as w,c as z,d as R,e as N,f as k,B as F}from"./BufferView.js";class C{constructor(t){this.channel=t,this.id=O()}}function j(t,e){return null==t&&(t=[]),t.push(e),t}function q(t,e){if(null==t)return null;const i=t.filter((t=>t!==e));return 0===i.length?null:i}function U(t,e,i,s,r){K[0]=t.get(e,0),K[1]=t.get(e,1),K[2]=t.get(e,2),L(K,V,3),i.set(r,0,V[0]),s.set(r,0,V[1]),i.set(r,1,V[2]),s.set(r,1,V[3]),i.set(r,2,V[4]),s.set(r,2,V[5])}const K=_(),V=new Float32Array(6);function $(e,i=!1){return e<=t?i?new Array(e).fill(0):new Array(e):new Float32Array(e)}function D(i){return e(i)?i.length<t?i:new Float32Array(i):i.length<t?Array.from(i):i}function Y(i){return(e(i)?i.length:i.byteLength/8)<=t?Array.from(i):new Float32Array(i)}function H(t,e,i){return Array.isArray(t)?t.slice(e,e+i):t.subarray(e,e+i)}function W(s){if(s.length<t)return Array.from(s);if(e(s))return Float64Array.from(s);if(!("BYTES_PER_ELEMENT"in s))return Array.from(s);switch(s.BYTES_PER_ELEMENT){case 1:return Uint8Array.from(s);case 2:return i(s)?Uint16Array.from(s):Int16Array.from(s);case 4:return Float32Array.from(s);default:return Float64Array.from(s)}}class G{constructor(t,e,i,s){this.primitiveIndices=t,this._numIndexPerPrimitive=e,this.indices=i,this.position=s,this._children=void 0,y(t.length>=1),y(i.length%this._numIndexPerPrimitive==0),y(i.length>=t.length*this._numIndexPerPrimitive),y(3===s.size||4===s.size);const{data:r,size:o}=s,a=t.length;let f=o*i[this._numIndexPerPrimitive*t[0]];Q.clear(),Q.push(f);const u=b(r[f],r[f+1],r[f+2]),l=E(u);for(let e=0;e<a;++e){const s=this._numIndexPerPrimitive*t[e];for(let t=0;t<this._numIndexPerPrimitive;++t){f=o*i[s+t],Q.push(f);let e=r[f];u[0]=Math.min(e,u[0]),l[0]=Math.max(e,l[0]),e=r[f+1],u[1]=Math.min(e,u[1]),l[1]=Math.max(e,l[1]),e=r[f+2],u[2]=Math.min(e,u[2]),l[2]=Math.max(e,l[2])}}this.bbMin=u,this.bbMax=l;const c=n(_(),this.bbMin,this.bbMax,.5);this.radius=.5*Math.max(Math.max(l[0]-u[0],l[1]-u[1]),l[2]-u[2]);let h=this.radius*this.radius;for(let t=0;t<Q.length;++t){f=Q.at(t);const e=r[f]-c[0],i=r[f+1]-c[1],s=r[f+2]-c[2],n=e*e+i*i+s*s;if(n<=h)continue;const o=Math.sqrt(n),a=.5*(o-this.radius);this.radius=this.radius+a,h=this.radius*this.radius;const u=a/o;c[0]+=e*u,c[1]+=i*u,c[2]+=s*u}this.center=c,Q.clear()}getChildren(){if(this._children||o(this.bbMin,this.bbMax)<=1)return this._children;const t=n(_(),this.bbMin,this.bbMax,.5),e=this.primitiveIndices.length,i=new Uint8Array(e),s=new Array(8);for(let t=0;t<8;++t)s[t]=0;const{data:r,size:a}=this.position;for(let n=0;n<e;++n){let e=0;const o=this._numIndexPerPrimitive*this.primitiveIndices[n];let f=a*this.indices[o],u=r[f],l=r[f+1],c=r[f+2];for(let t=1;t<this._numIndexPerPrimitive;++t){f=a*this.indices[o+t];const e=r[f],i=r[f+1],s=r[f+2];e<u&&(u=e),i<l&&(l=i),s<c&&(c=s)}u<t[0]&&(e|=1),l<t[1]&&(e|=2),c<t[2]&&(e|=4),i[n]=e,++s[e]}let f=0;for(let t=0;t<8;++t)s[t]>0&&++f;if(f<2)return;const u=new Array(8);for(let t=0;t<8;++t)u[t]=s[t]>0?new Uint32Array(s[t]):void 0;for(let t=0;t<8;++t)s[t]=0;for(let t=0;t<e;++t){const e=i[t];u[e][s[e]++]=this.primitiveIndices[t]}this._children=new Array;for(let t=0;t<8;++t)void 0!==u[t]&&this._children.push(new G(u[t],this._numIndexPerPrimitive,this.indices,this.position));return this._children}static prune(){Q.prune()}}const Q=new A({deallocator:null}),J=_(),X=_(),Z=_(),tt=_();class et extends I{constructor(t,e,i=[],s=null,r=P.Mesh,n=null,o=-1){super(),this.material=t,this.mapPositions=s,this.type=r,this.objectAndLayerIdColor=n,this.edgeIndicesLength=o,this.visible=!0,this._vertexAttributes=new Map,this._indices=new Map,this._boundingInfo=null;for(const[t,i]of e)i&&this._vertexAttributes.set(t,{...i});if(null==i||0===i.length){const t=function(t){const e=t.values().next().value;return null==e?0:e.data.length/e.size}(this._vertexAttributes),e=h(t);this.edgeIndicesLength=this.edgeIndicesLength<0?t:this.edgeIndicesLength;for(const t of this._vertexAttributes.keys())this._indices.set(t,e)}else for(const[t,e]of i)e&&(this._indices.set(t,d(e)),t===x.POSITION&&(this.edgeIndicesLength=this.edgeIndicesLength<0?this._indices.get(t).length:this.edgeIndicesLength))}instantiate(t={}){const e=new et(t.material||this.material,[],void 0,this.mapPositions,this.type,this.objectAndLayerIdColor,this.edgeIndicesLength);return this._vertexAttributes.forEach(((t,i)=>{t.exclusive=!1,e._vertexAttributes.set(i,t)})),this._indices.forEach(((t,i)=>e._indices.set(i,t))),e._boundingInfo=this._boundingInfo,e.transformation=t.transformation||this.transformation,e}get vertexAttributes(){return this._vertexAttributes}getMutableAttribute(t){let e=this._vertexAttributes.get(t);return e&&!e.exclusive&&(e={...e,exclusive:!0,data:W(e.data)},this._vertexAttributes.set(t,e)),e}setAttributeData(t,e){const i=this._vertexAttributes.get(t);i&&this._vertexAttributes.set(t,{...i,exclusive:!0,data:e})}get indices(){return this._indices}get indexCount(){const t=this._indices.values().next().value;return t?t.length:0}get faceCount(){return this.indexCount/3}get boundingInfo(){return null==this._boundingInfo&&(this._boundingInfo=this._calculateBoundingInfo()),this._boundingInfo}computeAttachmentOrigin(t){return!!(this.type===P.Mesh?this._computeAttachmentOriginTriangles(t):this.type===P.Line?this._computeAttachmentOriginLines(t):this._computeAttachmentOriginPoints(t))&&(null!=this._transformation&&c(t,t,this._transformation),!0)}_computeAttachmentOriginTriangles(t){const e=this.indices.get(x.POSITION);return function(t,e,i){if(!t||!e)return!1;const{size:s,data:r}=t;a(i,0,0,0),a(tt,0,0,0);let n=0,o=0;for(let t=0;t<e.length-2;t+=3){const l=e[t]*s,c=e[t+1]*s,h=e[t+2]*s;a(J,r[l],r[l+1],r[l+2]),a(X,r[c],r[c+1],r[c+2]),a(Z,r[h],r[h+1],r[h+2]);const d=v(J,X,Z);d?(f(J,J,X),f(J,J,Z),u(J,J,1/3*d),f(i,i,J),n+=d):(f(tt,tt,J),f(tt,tt,X),f(tt,tt,Z),o+=3)}return!(0===o&&0===n||(0!==n?(u(i,i,1/n),0):0===o||(u(i,tt,1/o),0)))}(this.vertexAttributes.get(x.POSITION),e,t)}_computeAttachmentOriginLines(t){const e=this.vertexAttributes.get(x.POSITION),i=this.indices.get(x.POSITION);return function(t,e,i,s){if(!t)return!1;a(s,0,0,0),a(tt,0,0,0);let r=0,n=0;const{size:o,data:c}=t,h=e?e.length-1:c.length/o-1,d=h+(i?2:0);for(let t=0;t<d;t+=2){const i=t<h?t:h,a=t<h?t+1:0,d=(e?e[i]:i)*o,m=(e?e[a]:a)*o;J[0]=c[d],J[1]=c[d+1],J[2]=c[d+2],X[0]=c[m],X[1]=c[m+1],X[2]=c[m+2],u(J,f(J,J,X),.5);const g=l(J,X);g>0?(f(s,s,u(J,J,g)),r+=g):0===r&&(f(tt,tt,J),n++)}return 0!==r?(u(s,s,1/r),!0):0!==n&&(u(s,tt,1/n),!0)}(e,i,i&&function(t,e,i){return!(!("isClosed"in t)||!t.isClosed)&&(i?i.length>2:e.data.length>6)}(this.material.parameters,e,i),t)}_computeAttachmentOriginPoints(t){const e=this.indices.get(x.POSITION);return function(t,e,i){if(!t||!e)return!1;const{size:s,data:r}=t;a(i,0,0,0);let n=-1,o=0;for(let t=0;t<e.length;t++){const a=e[t]*s;n!==a&&(i[0]+=r[a],i[1]+=r[a+1],i[2]+=r[a+2],o++),n=a}return o>1&&u(i,i,1/o),o>0}(this.vertexAttributes.get(x.POSITION),e,t)}invalidateBoundingInfo(){this._boundingInfo=null}_calculateBoundingInfo(){const t=this.indices.get(x.POSITION),e=this.vertexAttributes.get(x.POSITION);if(!t||0===t.length||!e)return null;const i=this.type===P.Mesh?3:1;y(t.length%i==0,"Indexing error: "+t.length+" not divisible by "+i);const s=h(t.length/i);return new G(s,i,t,e)}get transformation(){return this._transformation??s}set transformation(t){this._transformation=t&&t!==s?r(t):null}get shaderTransformation(){return null!=this._shaderTransformer?this._shaderTransformer(this.transformation):this.transformation}get shaderTransformer(){return this._shaderTransformer}set shaderTransformer(t){this._shaderTransformer=t}get hasVolatileTransformation(){return null!=this._shaderTransformer}addHighlight(){const t=new C(m.Highlight);return this.highlights=j(this.highlights,t),t}removeHighlight(t){this.highlights=q(this.highlights,t)}}class it{constructor(t){this._material=t.material,this._techniqueRepository=t.techniqueRep,this._output=t.output}dispose(){this._techniqueRepository.release(this._technique)}get technique(){return this._technique}get _stippleTextureRepository(){return this._techniqueRepository.constructionContext.stippleTextureRepository}get _markerTextureRepository(){return this._techniqueRepository.constructionContext.markerTextureRepository}ensureTechnique(t,e){return this._technique=this._techniqueRepository.releaseAndAcquire(t,this._material.getConfiguration(this._output,e),this._technique),this._technique}ensureResources(t){return g.LOADED}}const st={func:T.LESS},rt={func:T.ALWAYS},nt={mask:255},ot={mask:0},at=t=>({function:{func:T.NOTEQUAL,ref:t,mask:t},operation:{fail:M.KEEP,zFail:M.KEEP,zPass:M.KEEP}}),ft=t=>({function:{func:T.ALWAYS,ref:t,mask:t},operation:{fail:M.KEEP,zFail:M.KEEP,zPass:M.REPLACE}}),ut={function:{func:T.ALWAYS,ref:p.OutlineVisualElementMask,mask:p.OutlineVisualElementMask},operation:{fail:M.KEEP,zFail:M.KEEP,zPass:M.ZERO}},lt={function:{func:T.ALWAYS,ref:p.OutlineVisualElementMask,mask:p.OutlineVisualElementMask},operation:{fail:M.KEEP,zFail:M.KEEP,zPass:M.REPLACE}},ct={function:{func:T.EQUAL,ref:p.OutlineVisualElementMask,mask:p.OutlineVisualElementMask},operation:{fail:M.KEEP,zFail:M.KEEP,zPass:M.KEEP}},ht={function:{func:T.NOTEQUAL,ref:p.OutlineVisualElementMask,mask:p.OutlineVisualElementMask},operation:{fail:M.KEEP,zFail:M.KEEP,zPass:M.KEEP}};function dt(t,e,i,s,r=1){const n=i.typedBuffer,o=i.typedBufferStride,a=t.length;if(s*=o,1===r)for(let i=0;i<a;++i)n[s]=e[t[i]],s+=o;else for(let i=0;i<a;++i){const a=e[t[i]];for(let t=0;t<r;t++)n[s]=a,s+=o}}function mt(t,e,i,s){const r=i.typedBuffer,n=i.typedBufferStride,o=t.length;s*=n;for(let i=0;i<o;++i){const o=2*t[i];r[s]=e[o],r[s+1]=e[o+1],s+=n}}function gt(t,e,i,s,r){const n=i.typedBuffer,o=i.typedBufferStride,a=t.length;if(s*=o,null==r||1===r)for(let i=0;i<a;++i){const r=3*t[i];n[s]=e[r],n[s+1]=e[r+1],n[s+2]=e[r+2],s+=o}else for(let i=0;i<a;++i){const a=3*t[i];for(let t=0;t<r;++t)n[s]=e[a],n[s+1]=e[a+1],n[s+2]=e[a+2],s+=o}}function pt(t,e,i,s,r=1){const n=i.typedBuffer,o=i.typedBufferStride,a=t.length;if(s*=o,1===r)for(let i=0;i<a;++i){const r=4*t[i];n[s]=e[r],n[s+1]=e[r+1],n[s+2]=e[r+2],n[s+3]=e[r+3],s+=o}else for(let i=0;i<a;++i){const a=4*t[i];for(let t=0;t<r;++t)n[s]=e[a],n[s+1]=e[a+1],n[s+2]=e[a+2],n[s+3]=e[a+3],s+=o}}function At(t,e,i){const s=t.typedBuffer,r=t.typedBufferStride;e*=r;for(let t=0;t<i;++t)s[e]=0,s[e+1]=0,s[e+2]=0,s[e+3]=0,e+=r}function _t(t,e,i,s,r,n=1){if(!i)return void gt(t,e,s,r,n);const o=s.typedBuffer,a=s.typedBufferStride,f=t.length,u=i[0],l=i[1],c=i[2],h=i[4],d=i[5],m=i[6],g=i[8],p=i[9],A=i[10],_=i[12],b=i[13],E=i[14];r*=a;let y=0,I=0,P=0;const v=B(i)?t=>{y=e[t]+_,I=e[t+1]+b,P=e[t+2]+E}:t=>{const i=e[t],s=e[t+1],r=e[t+2];y=u*i+h*s+g*r+_,I=l*i+d*s+p*r+b,P=c*i+m*s+A*r+E};if(1===n)for(let e=0;e<f;++e)v(3*t[e]),o[r]=y,o[r+1]=I,o[r+2]=P,r+=a;else for(let e=0;e<f;++e){v(3*t[e]);for(let t=0;t<n;++t)o[r]=y,o[r+1]=I,o[r+2]=P,r+=a}}function bt(t,e,i,s,r,n=1){if(!i)return void gt(t,e,s,r,n);const o=i,a=s.typedBuffer,f=s.typedBufferStride,u=t.length,l=o[0],c=o[1],h=o[2],d=o[4],m=o[5],g=o[6],p=o[8],A=o[9],_=o[10],b=!S(o),E=1e-6,y=.999999;r*=f;let I=0,P=0,v=0;const O=B(o)?t=>{I=e[t],P=e[t+1],v=e[t+2]}:t=>{const i=e[t],s=e[t+1],r=e[t+2];I=l*i+d*s+p*r,P=c*i+m*s+A*r,v=h*i+g*s+_*r};if(1===n)if(b)for(let e=0;e<u;++e){O(3*t[e]);const i=I*I+P*P+v*v;if(i<y&&i>E){const t=1/Math.sqrt(i);a[r]=I*t,a[r+1]=P*t,a[r+2]=v*t}else a[r]=I,a[r+1]=P,a[r+2]=v;r+=f}else for(let e=0;e<u;++e)O(3*t[e]),a[r]=I,a[r+1]=P,a[r+2]=v,r+=f;else for(let e=0;e<u;++e){if(O(3*t[e]),b){const t=I*I+P*P+v*v;if(t<y&&t>E){const e=1/Math.sqrt(t);I*=e,P*=e,v*=e}}for(let t=0;t<n;++t)a[r]=I,a[r+1]=P,a[r+2]=v,r+=f}}function Et(t,e,i,s,r,n=1){const o=s.typedBuffer,a=s.typedBufferStride,f=t.length;if(r*=a,i!==e.length||4!==i)if(1!==n)if(4!==i)for(let i=0;i<f;++i){const s=3*t[i];for(let t=0;t<n;++t)o[r]=e[s],o[r+1]=e[s+1],o[r+2]=e[s+2],o[r+3]=255,r+=a}else for(let i=0;i<f;++i){const s=4*t[i];for(let t=0;t<n;++t)o[r]=e[s],o[r+1]=e[s+1],o[r+2]=e[s+2],o[r+3]=e[s+3],r+=a}else{if(4===i){for(let i=0;i<f;++i){const s=4*t[i];o[r]=e[s],o[r+1]=e[s+1],o[r+2]=e[s+2],o[r+3]=e[s+3],r+=a}return}for(let i=0;i<f;++i){const s=3*t[i];o[r]=e[s],o[r+1]=e[s+1],o[r+2]=e[s+2],o[r+3]=255,r+=a}}else{o[r]=e[0],o[r+1]=e[1],o[r+2]=e[2],o[r+3]=e[3];const t=new Uint32Array(s.typedBuffer.buffer,s.start),i=a/4,u=t[r/=4];r+=i;const l=f*n;for(let e=1;e<l;++e)t[r]=u,r+=i}}function yt(t,e,i,s,r=1){const n=e.typedBuffer,o=e.typedBufferStride;if(s*=o,1===r)for(let e=0;e<i;++e)n[s]=t[0],n[s+1]=t[1],n[s+2]=t[2],n[s+3]=t[3],s+=o;else for(let e=0;e<i;++e)for(let e=0;e<r;++e)n[s]=t[0],n[s+1]=t[1],n[s+2]=t[2],n[s+3]=t[3],s+=o}function It(t,e,i,s,r,n){for(const o of e.fields.keys()){const e=t.vertexAttributes.get(o),a=t.indices.get(o);if(e&&a)Pt(o,e,a,i,s,r,n);else if(o===x.OBJECTANDLAYERIDCOLOR&&null!=t.objectAndLayerIdColor){const e=t.indices.get(x.POSITION);if(y(!!e,`No buffer view for ${o}`),e){const i=e.length,s=r.getField(o,w);yt(t.objectAndLayerIdColor,s,i,n)}}}}function Pt(t,e,i,s,r,n,o){switch(t){case x.POSITION:{y(3===e.size);const r=n.getField(t,F);y(!!r,`No buffer view for ${t}`),r&&_t(i,e.data,s,r,o);break}case x.NORMAL:{y(3===e.size);const s=n.getField(t,F);y(!!s,`No buffer view for ${t}`),s&&bt(i,e.data,r,s,o);break}case x.NORMALCOMPRESSED:{y(2===e.size);const s=n.getField(t,k);y(!!s,`No buffer view for ${t}`),s&&mt(i,e.data,s,o);break}case x.UV0:{y(2===e.size);const s=n.getField(t,N);y(!!s,`No buffer view for ${t}`),s&&mt(i,e.data,s,o);break}case x.COLOR:case x.SYMBOLCOLOR:{const s=n.getField(t,w);y(!!s,`No buffer view for ${t}`),y(3===e.size||4===e.size),!s||3!==e.size&&4!==e.size||Et(i,e.data,e.size,s,o);break}case x.COLORFEATUREATTRIBUTE:{const s=n.getField(t,R);y(!!s,`No buffer view for ${t}`),y(1===e.size),s&&1===e.size&&function(t,e,i,s){const r=i.typedBuffer,n=i.typedBufferStride,o=t.length,a=e[0];s*=n;for(let t=0;t<o;++t)r[s]=a,s+=n}(i,e.data,s,o);break}case x.TANGENT:{y(4===e.size);const s=n.getField(t,z);y(!!s,`No buffer view for ${t}`),s&&function(t,e,i,s,r,n=1){if(!i)return void pt(t,e,s,r,n);const o=i,a=s.typedBuffer,f=s.typedBufferStride,u=t.length,l=o[0],c=o[1],h=o[2],d=o[4],m=o[5],g=o[6],p=o[8],A=o[9],_=o[10],b=!S(o),E=1e-6,y=.999999;if(r*=f,1===n)for(let i=0;i<u;++i){const s=4*t[i],n=e[s],o=e[s+1],u=e[s+2],I=e[s+3];let P=l*n+d*o+p*u,v=c*n+m*o+A*u,O=h*n+g*o+_*u;if(b){const t=P*P+v*v+O*O;if(t<y&&t>E){const e=1/Math.sqrt(t);P*=e,v*=e,O*=e}}a[r]=P,a[r+1]=v,a[r+2]=O,a[r+3]=I,r+=f}else for(let i=0;i<u;++i){const s=4*t[i],o=e[s],u=e[s+1],I=e[s+2],P=e[s+3];let v=l*o+d*u+p*I,O=c*o+m*u+A*I,x=h*o+g*u+_*I;if(b){const t=v*v+O*O+x*x;if(t<y&&t>E){const e=1/Math.sqrt(t);v*=e,O*=e,x*=e}}for(let t=0;t<n;++t)a[r]=v,a[r+1]=O,a[r+2]=x,a[r+3]=P,r+=f}}(i,e.data,r,s,o);break}case x.PROFILERIGHT:case x.PROFILEUP:case x.PROFILEVERTEXANDNORMAL:case x.FEATUREVALUE:{y(4===e.size);const s=n.getField(t,z);y(!!s,`No buffer view for ${t}`),s&&pt(i,e.data,s,o)}}}class vt{constructor(t){this.vertexBufferLayout=t}elementCount(t){return t.indices.get(x.POSITION).length}write(t,e,i,s,r){It(i,this.vertexBufferLayout,t,e,s,r)}}export{dt as A,G as B,vt as D,it as G,C as O,et as a,j as b,lt as c,ut as d,rt as e,ht as f,ot as g,ct as h,st as i,Y as j,_t as k,bt as l,Et as m,$ as n,pt as o,At as p,yt as q,q as r,nt as s,at as t,ft as u,U as v,It as w,H as x,Pt as y,D as z};
