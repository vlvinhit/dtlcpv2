/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.27/esri/copyright.txt for details.
*/
import e from"../request.js";import t from"../core/Error.js";import{L as s}from"./Logger.js";import{throwIfAborted as a,throwIfAbortError as r,after as o}from"../core/promiseUtils.js";import{join as n,parseData as i}from"../core/urlUtils.js";import{a as l}from"./uuid.js";import{a as p,d as c,c as u,S as d,f}from"./External.js";import{i as m}from"./arcgisLayerUrl.js";import{c as y,a as w,g as h}from"./infoFor3D.js";import"../config.js";import"./typedArrayUtil.js";import"./object.js";import"../core/lang.js";import"../kernel.js";import"./string.js";import"./maybe.js";import"./persistableUrlUtils.js";const g=1e6,j=20*g,T=2e9,b=3;async function E(s,r,i){return s.length?Promise.all(s.map((s=>async function(s,{layer:r,ongoingUploads:i},c){const f=i.get(s);if(f)return f;if(!function(e){return!!e.infoFor3D&&!!e.url}(r))throw new t(`${r.type}-layer:upload-failure`,"Layer does not support asset uploads.",new Error);if(function(e,t){const{parsedUrl:s}=t;return null!=s&&e.metadata.externalSources.some((e=>p(e,s)))}(s,r))return s;const m=async function(s,r,i){const{metadata:p}=s,{displaySource:c}=p,f=F(c?.source,r),m=!!f,y=p.externalSources.length>0,h=m?async function(e,t,s){return{source:await $(e,t,s),original:!0}}(f,r,i):y?async function(s,a,r){const i=x(a),{externalSources:l}=s.metadata,p=function(e,t){for(const s of e){const e=F(s.source,t);if(e)return e}return null}(l,a);if(!p)throw new t(`${a.type}-layer:upload-failure`,"Could not find an external source that is supported by the service.",new Error);const c=await $(p,a,r);s.addExternalSources([{source:c,original:!0}]);const f=await async function(s,a,r){const i=s.map((({assetName:e,parts:t})=>({assetName:e,assetHash:t[0].partHash}))),l=a.capabilities?.operations.supportsAsyncConvert3D,p={query:{f:"json",assets:JSON.stringify(i),transportType:"esriTransportTypeUrl",targetFormat:r,async:l},responseType:"json",timeout:0},c=n(a.parsedUrl.path,"convert3D"),f=(l?await async function(s,a){const r=(await e(s,a)).data.statusUrl;for(;;){const s=(await e(r,{query:{f:"json"},responseType:"json"})).data;switch(s.status){case"Completed":return e(s.resultUrl,{query:{f:"json"},responseType:"json"});case"CompletedWithErrors":throw new t("async-convert3D-failed","asynchronous convert3D call failed.");case"Failed ImportChanges":case"InProgress":case"Pending":case"ExportAttachments":case"ExportChanges":case"ExportingData":case"ExportingSnapshot":case"ImportAttachments":case"ProvisioningReplica":case"UnRegisteringReplica":break;default:throw new t("async-convert3D-failed","asynchronous convert3D call failed (undefined response status)")}await o(v)}}(c,p):await e(c,p)).data,{infoFor3D:{supportedFormats:m}}=a;return f.assets.map((e=>{const s=w(e.contentType,m);if(!s)throw new t(`${a.type}-layer:upload-failure`,`The service allowed us to upload an asset of FormatID ${s}, but it does not list it in its supported formats.`,new Error);return new u(e.assetName,e.contentType,[new d(e.assetURL,e.assetHash)])}))}(c,a,i);return{source:f}}(s,r,i):async function(e,t,s){const r=async function(e,t,s){const r=x(t),o=await e.load(s),n=await o.toBinaryGLTF({ignoreLocalTransform:!0});a(s);const i=await n.buffer();return a(s),{blob:new Blob([i.data],{type:i.type}),assetName:`${l()}.glb`,assetType:r}}(e,t,s);return{source:await D([r],t,s),extent:e.extent.clone(),original:!0}}(s,r,i),g=await h;return a(i),s.addExternalSources([g]),s}(s,r,c);i.set(s,m);try{await m}finally{i.delete(s)}return s}(s,r,i)))):[]}function F(e,t){if(!e)return null;const{infoFor3D:{supportedFormats:s,editFormats:a}}=t,r=f(e),o=new Array;let n=!1;for(let e=0;e<r.length;++e){const t=U(r[e],s);if(!t)return null;a.includes(t.assetType)&&(n=!0),o.push(t)}return n?o:null}function U(e,t){const s=c(e,t);return s?{asset:e,assetType:s}:null}async function $(e,t,s){const r=e.map((e=>async function(e,t){const{asset:s,assetType:r}=e;if(s instanceof File)return{blob:s,assetName:s.name,assetType:r};const o=await s.toBlob(t);return a(t),{blob:o,assetName:s.assetName,assetType:r}}(e,s)));return D(r,t,s)}async function D(o,l,p){const c=await Promise.all(o.map((async o=>{const c=async function(o,l,p){const{blob:c,assetType:u,assetName:d}=o;let f=null;try{const t=await async function({data:t,name:s,description:r},o,i){let l=null;try{const p=n(o,"uploads"),c=n(p,"info"),{data:u}=await e(c,{query:{f:"json"},responseType:"json"});a(i);const d=m(o),f=u.maxUploadFileSize*g,y=d?T:f,w=d?Math.min(j,f):j;if(t.size>y)throw new Error("Data too large");const h=n(p,"register"),{data:E}=await e(h,{query:{f:"json",itemName:s,description:r},responseType:"json",method:"post"});if(a(i),!E.success)throw new Error("Registration failed");const{itemID:F}=E.item;l=n(p,F);const U=n(l,"uploadPart"),$=Math.ceil(t.size/w),D=new Array;for(let e=0;e<$;++e)D.push(t.slice(e*w,Math.min((e+1)*w,t.size)));const x=D.slice().reverse(),v=new Array,A=async()=>{for(;0!==x.length;){const t=D.length-x.length,s=x.pop(),r=new FormData;r.append("f","json"),r.append("file",s),r.append("partId",`${t}`);const{data:o}=await e(U,{timeout:0,body:r,responseType:"json",method:"post"});if(a(i),!o.success)throw new Error("Part upload failed")}};for(let e=0;e<b&&0!==x.length;++e)v.push(A());await Promise.all(v);const N=n(l,"commit"),{data:S}=await e(N,{query:{f:"json",parts:D.map(((e,t)=>t)).join(",")},responseType:"json",method:"post"});if(a(i),!S.success)throw new Error("Commit failed");return S.item}catch(t){if(null!=l){const t=n(l,"delete");await e(t,{query:{f:"json"},responseType:"json",method:"post"})}throw t}}({data:c,name:d},l.url,p);a(p),f={assetType:u,assetUploadId:t.itemID}}catch(e){r(e),s.getLogger("esri.layers.graphics.sources.support.uploadAssets").warnOnce(`Service ${l.url} does not support the REST Uploads API.`)}if(!f){const e=await i(c);if(a(p),!e.isBase64)throw new t(`${l.type}-layer:uploadAssets-failure`,"Expected gltf data in base64 format after conversion.",new Error);f={assetType:u,assetData:e.data}}if(!f)throw new t(`${l.type}-layer:uploadAssets-failure`,"Unable to prepare uploadAsset request options.",new Error);return{item:f,assetName:d}}(await o,l,p);return a(p),c})));a(p);const{uploadResults:f}=await async function(s,r,o){const i=await e(n(r.parsedUrl.path,"uploadAssets"),{timeout:0,query:{f:"json",assets:JSON.stringify(s)},method:"post",responseType:"json"});if(a(o),i.data.uploadResults.length!==s.length)throw new t(`${r.type}-layer:uploadAssets-failure`,`Bad response. Uploaded ${s.length} items and received ${i.data.uploadResults.length} results.`,new Error);return i.data}(c.map((({item:e})=>e)),l,p);return a(p),o.map(((e,s)=>function(e,s,a){const{success:r}=s;if(!r){const{error:r}=s;throw new t(`${a.type}-layer:upload-failure`,`Failed to upload mesh file ${e.assetName}. Error code: ${r.code}. Error message: ${r.messages}`,new Error)}const{assetHash:o}=s,{assetName:n,item:{assetType:i}}=e,{infoFor3D:{supportedFormats:l}}=a,p=y(i,l);if(!p)throw new t(`${a.type}-layer:upload-failure`,`The service allowed us to upload an asset of FormatID ${i}, but it does not list it in its supported formats.`,new Error);return new u(n,p,[new d(`${a.parsedUrl.path}/assets/${o}`,o)])}(c[s],f[s],l)))}function x(e){const{infoFor3D:s}=e,a=w("model/gltf-binary",s.supportedFormats)??h("glb",s.supportedFormats);if(!a)throw new t(`${e.type}-layer:upload-failure`,"Layer does not support glb.",new Error);return a}const v=1e3;export{E as uploadAssets};
