/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.27/esri/copyright.txt for details.
*/
import{h as e}from"./typedArrayUtil.js";import{c as t}from"./mathUtils.js";import{f as s}from"./mat3.js";import{c as i}from"./mat3f64.js";import{c as r}from"./mat4.js";import{c as a}from"./mat4f64.js";import{k as o}from"./vec2.js";import{a as n,f as l}from"./vec2f64.js";import{s as c,d as p,n as f,b as d,e as h,c as u,l as m,z as g,t as v,i as O,a as S}from"./vec3.js";import{c as y,f as A}from"./vec3f64.js";import{c as P,f as b}from"./vec4f64.js";import{c as x}from"./aaBoundingRect.js";import{b as I}from"./BufferView.js";import{d as T}from"./FloatsPassUniform.js";import{n as _}from"./InterleavedLayout.js";import{S as C}from"./ShaderOutput.js";import{H as E}from"./HUD.glsl.js";import{G as j,a as z}from"./GLTextureMaterial.js";import{D as L,b as M,d as w,e as R,p as U,v as D,R as N}from"./Material.js";import{R as V}from"./RenderSlot.js";import{a as H}from"./Util2.js";import{V as G}from"./VertexAttribute.js";import{k as B,l as F,m as X,o as W,p as q,q as Z}from"./DefaultBufferWriter.js";import{H as k,c as J}from"./HUDMaterial.glsl.js";import{V as Y}from"./ViewingMode.js";import{R as Q,S as K,P as $}from"./Program2.js";import{o as ee}from"./OrderIndependentTransparency.js";import{T as te}from"./TransparencyPassType.js";import{f as se,g as ie,e as re}from"./enums3.js";import{b as ae,d as oe,m as ne,a as le}from"./renderState.js";import{_ as ce}from"./tslib.es6.js";import{p as pe}from"./ShaderTechniqueConfiguration.js";import{D as fe}from"./DefaultTechniqueConfiguration.js";class de{constructor(){this.factor=new he,this.factorAlignment=new he}}class he{constructor(){this.scale=0,this.factor=0,this.minPixelSize=0,this.paddingPixels=0}}class ue extends K{initializeConfiguration(e,t){t.spherical=e.viewingMode===Y.Global}initializeProgram(e){return new $(e.rctx,ue.shader.get().build(this.configuration),L)}_setPipelineState(e){const t=this.configuration,s=e===te.NONE,i=e===te.FrontFace,r=this.configuration.hasPolygonOffset?me:null,a=(s||i)&&t.output!==C.Highlight&&(t.depthEnabled||t.occlusionPass)?oe:null;return ne({blending:t.output===C.Color||t.output===C.Alpha||t.output===C.Highlight?s?ge:ee(e):null,depthTest:{func:ie.LEQUAL},depthWrite:a,colorWrite:le,polygonOffset:r})}initializePipeline(){return this._setPipelineState(this.configuration.transparencyPassType)}get primitiveType(){return this.configuration.occlusionPass?re.POINTS:re.TRIANGLES}}ue.shader=new Q(k,(()=>import("./HUDMaterial.glsl.js").then((e=>e.H))));const me={factor:0,units:-4},ge=ae(se.ONE,se.ONE_MINUS_SRC_ALPHA);class ve extends fe{constructor(){super(...arguments),this.output=C.Color,this.screenCenterOffsetUnitsEnabled=E.World,this.transparencyPassType=te.NONE,this.spherical=!1,this.occlusionTestEnabled=!0,this.signedDistanceFieldEnabled=!1,this.vvSize=!1,this.vvColor=!1,this.hasVerticalOffset=!1,this.hasScreenSizePerspective=!1,this.debugDrawLabelBorder=!1,this.binaryHighlightOcclusionEnabled=!0,this.hasSlicePlane=!1,this.hasPolygonOffset=!1,this.depthEnabled=!0,this.pixelSnappingEnabled=!0,this.draped=!1,this.hasMultipassGeometry=!1,this.hasMultipassTerrain=!1,this.cullAboveGround=!1,this.occlusionPass=!1,this.objectAndLayerIdColorInstanced=!1}}ce([pe({count:C.COUNT})],ve.prototype,"output",void 0),ce([pe({count:E.COUNT})],ve.prototype,"screenCenterOffsetUnitsEnabled",void 0),ce([pe({count:te.COUNT})],ve.prototype,"transparencyPassType",void 0),ce([pe()],ve.prototype,"spherical",void 0),ce([pe()],ve.prototype,"occlusionTestEnabled",void 0),ce([pe()],ve.prototype,"signedDistanceFieldEnabled",void 0),ce([pe()],ve.prototype,"vvSize",void 0),ce([pe()],ve.prototype,"vvColor",void 0),ce([pe()],ve.prototype,"hasVerticalOffset",void 0),ce([pe()],ve.prototype,"hasScreenSizePerspective",void 0),ce([pe()],ve.prototype,"debugDrawLabelBorder",void 0),ce([pe()],ve.prototype,"binaryHighlightOcclusionEnabled",void 0),ce([pe()],ve.prototype,"hasSlicePlane",void 0),ce([pe()],ve.prototype,"hasPolygonOffset",void 0),ce([pe()],ve.prototype,"depthEnabled",void 0),ce([pe()],ve.prototype,"pixelSnappingEnabled",void 0),ce([pe()],ve.prototype,"draped",void 0),ce([pe()],ve.prototype,"hasMultipassGeometry",void 0),ce([pe()],ve.prototype,"hasMultipassTerrain",void 0),ce([pe()],ve.prototype,"cullAboveGround",void 0),ce([pe()],ve.prototype,"occlusionPass",void 0),ce([pe()],ve.prototype,"objectAndLayerIdColorInstanced",void 0),ce([pe({constValue:!0})],ve.prototype,"hasSliceInVertexProgram",void 0),ce([pe({constValue:!1})],ve.prototype,"hasVvInstancing",void 0);class Oe extends M{constructor(e){super(e,new Ne),this._configuration=new ve}getConfiguration(e,t){return this._configuration.output=e,this._configuration.hasSlicePlane=this.parameters.hasSlicePlane,this._configuration.hasVerticalOffset=!!this.parameters.verticalOffset,this._configuration.hasScreenSizePerspective=!!this.parameters.screenSizePerspective,this._configuration.screenCenterOffsetUnitsEnabled="screen"===this.parameters.centerOffsetUnits?E.Screen:E.World,this._configuration.hasPolygonOffset=this.parameters.polygonOffset,this._configuration.draped=this.parameters.isDraped,this._configuration.occlusionTestEnabled=this.parameters.occlusionTest,this._configuration.pixelSnappingEnabled=this.parameters.pixelSnappingEnabled,this._configuration.signedDistanceFieldEnabled=this.parameters.textureIsSignedDistanceField,this._configuration.vvSize=!!this.parameters.vvSize,this._configuration.vvColor=!!this.parameters.vvColor,this._configuration.occlusionPass=t.slot===V.OCCLUSION_PIXELS&&this.parameters.occlusionTest&&(e===C.Color||e===C.Alpha),e===C.Color&&(this._configuration.debugDrawLabelBorder=!!T.LABELS_SHOW_BORDER),e===C.Highlight&&(this._configuration.binaryHighlightOcclusionEnabled=this.parameters.binaryHighlightOcclusion),this._configuration.depthEnabled=this.parameters.depthEnabled,this._configuration.transparencyPassType=t.transparencyPassType,this._configuration.hasMultipassGeometry=t.multipassGeometry.enabled,this._configuration.hasMultipassTerrain=t.multipassTerrain.enabled,this._configuration.cullAboveGround=t.multipassTerrain.cullAboveGround,this._configuration}intersect(e,t,i,a,o,n){if(!i.options.selectionMode||!i.options.hud||!e.visible)return;const l=this.parameters;let v=1,O=1;if(s(Ce,t),null!=e.shaderTransformer){const t=e.shaderTransformer(Me);v=t[0],O=t[5],function(e){const t=e[0],s=e[1],i=e[2],r=e[3],a=e[4],o=e[5],n=e[6],l=e[7],c=e[8],p=1/Math.sqrt(t*t+s*s+i*i),f=1/Math.sqrt(r*r+a*a+o*o),d=1/Math.sqrt(n*n+l*l+c*c);e[0]=t*p,e[1]=s*p,e[2]=i*p,e[3]=r*f,e[4]=a*f,e[5]=o*f,e[6]=n*d,e[7]=l*d,e[8]=c*d}(Ce)}const S=e.vertexAttributes.get(G.POSITION),A=e.vertexAttributes.get(G.SIZE),P=e.vertexAttributes.get(G.NORMAL),b=e.vertexAttributes.get(G.AUXPOS1);H(S.size>=3);const x=i.point,I=i.camera,T=J(l);v*=I.pixelRatio,O*=I.pixelRatio;const _="screen"===this.parameters.centerOffsetUnits;for(let e=0;e<S.data.length/S.size;e++){const s=e*S.size;c(be,S.data[s],S.data[s+1],S.data[s+2]),p(be,be,t);const a=e*A.size;Ue[0]=A.data[a]*v,Ue[1]=A.data[a+1]*O,p(be,be,I.viewMatrix);const o=e*b.size;if(c(ze,b.data[o],b.data[o+1],b.data[o+2]),!_&&(be[0]+=ze[0],be[1]+=ze[1],0!==ze[2])){const e=ze[2];f(ze,be),d(be,be,h(ze,ze,e))}const C=e*P.size;if(c(xe,P.data[C],P.data[C+1],P.data[C+2]),this._normalAndViewAngle(xe,Ce,I,Le),this._applyVerticalOffsetTransformationView(be,Le,I,Ae),I.applyProjection(be,Ie),Ie[0]>-1){Ie[0]=Math.floor(Ie[0]),Ie[1]=Math.floor(Ie[1]),_&&(ze[0]||ze[1])&&(Ie[0]+=ze[0],0!==ze[1]&&(Ie[1]+=w(ze[1],Ae.factorAlignment)),I.unapplyProjection(Ie,be)),Ie[0]+=this.parameters.screenOffset[0],Ie[1]+=this.parameters.screenOffset[1],R(Ue,Ae.factor,Ue);const e=we*I.pixelRatio;let t=0;if(l.textureIsSignedDistanceField&&(t=l.outlineSize*I.pixelRatio/2),x&&ye(x,Ie[0],Ie[1],Ue,e,t,l,T)){const e=i.ray;if(p(_e,be,r(je,I.viewMatrix)),Ie[0]=x[0],Ie[1]=x[1],I.unprojectFromRenderScreen(Ie,be)){const t=y();u(t,e.direction);const s=1/m(t);h(t,t,s),n(g(e.origin,be)*s,t,-1,!0,1,_e)}}}}}intersectDraped(e,t,s,i,r,a){const o=e.vertexAttributes.get(G.POSITION),n=e.vertexAttributes.get(G.SIZE),l=this.parameters,c=J(l);let p=1,f=1;if(null!=e.shaderTransformer){const t=e.shaderTransformer(Me);p=t[0],f=t[5]}p*=e.screenToWorldRatio,f*=e.screenToWorldRatio;const d=Re*e.screenToWorldRatio;for(let t=0;t<o.data.length/o.size;t++){const s=t*o.size,h=o.data[s],u=o.data[s+1],m=t*n.size;Ue[0]=n.data[m]*p,Ue[1]=n.data[m+1]*f;let g=0;l.textureIsSignedDistanceField&&(g=l.outlineSize*e.screenToWorldRatio/2),ye(i,h,u,Ue,d,g,l,c)&&r(a.dist,a.normal,-1,!1)}}createBufferWriter(){return new Ge(this)}_normalAndViewAngle(e,t,i,r){return(function(e){return e instanceof Float32Array&&e.length>=16}(a=t)||function(e){return Array.isArray(e)&&e.length>=16}(a))&&(t=s(Ee,t)),v(r.normal,e,t),p(r.normal,r.normal,i.viewInverseTransposeMatrix),r.cosAngle=O(Te,De),r;var a}_updateScaleInfo(e,t,s){const i=this.parameters;null!=i.screenSizePerspective?U(s,t,i.screenSizePerspective,e.factor):(e.factor.scale=1,e.factor.factor=0,e.factor.minPixelSize=0,e.factor.paddingPixels=0),null!=i.screenSizePerspectiveAlignment?U(s,t,i.screenSizePerspectiveAlignment,e.factorAlignment):(e.factorAlignment.factor=e.factor.factor,e.factorAlignment.scale=e.factor.scale,e.factorAlignment.minPixelSize=e.factor.minPixelSize,e.factorAlignment.paddingPixels=e.factor.paddingPixels)}applyShaderOffsetsView(e,t,s,i,r,a,o){const n=this._normalAndViewAngle(t,s,r,Le);return this._applyVerticalGroundOffsetView(e,n,r,o),this._applyVerticalOffsetTransformationView(o,n,r,a),this._applyPolygonOffsetView(o,n,i[3],r,o),this._applyCenterOffsetView(o,i,o),o}applyShaderOffsetsNDC(e,t,s,i,r){return this._applyCenterOffsetNDC(e,t,s,i),null!=r&&u(r,i),this._applyPolygonOffsetNDC(i,t,s,i),i}_applyPolygonOffsetView(e,s,i,r,a){const o=r.aboveGround?1:-1;let n=Math.sign(i);0===n&&(n=o);const l=o*n;if(this.parameters.shaderPolygonOffset<=0)return u(a,e);const c=t(Math.abs(s.cosAngle),.01,1),p=1-Math.sqrt(1-c*c)/c/r.viewport[2];return h(a,e,l>0?p:1/p),a}_applyVerticalGroundOffsetView(e,t,s,i){const r=m(e),a=s.aboveGround?1:-1,o=.5*s.computeRenderPixelSizeAtDist(r),n=h(be,t.normal,a*o);return S(i,e,n),i}_applyVerticalOffsetTransformationView(e,t,s,i){const r=this.parameters;if(!r.verticalOffset||!r.verticalOffset.screenLength){if(r.screenSizePerspective||r.screenSizePerspectiveAlignment){const s=m(e);this._updateScaleInfo(i,s,t.cosAngle)}else i.factor.scale=1,i.factorAlignment.scale=1;return e}const a=m(e),o=r.screenSizePerspectiveAlignment??r.screenSizePerspective,n=D(s,a,r.verticalOffset,t.cosAngle,o);return this._updateScaleInfo(i,a,t.cosAngle),h(t.normal,t.normal,n),S(e,e,t.normal)}_applyCenterOffsetView(e,t,s){const i="screen"!==this.parameters.centerOffsetUnits;return s!==e&&u(s,e),i&&(s[0]+=t[0],s[1]+=t[1],t[2]&&(f(xe,s),S(s,s,h(xe,xe,t[2])))),s}_applyCenterOffsetNDC(e,t,s,i){const r="screen"!==this.parameters.centerOffsetUnits;return i!==e&&u(i,e),r||(i[0]+=t[0]/s.fullWidth*2,i[1]+=t[1]/s.fullHeight*2),i}_applyPolygonOffsetNDC(e,t,s,i){const r=this.parameters.shaderPolygonOffset;if(e!==i&&u(i,e),r){const e=s.aboveGround?1:-1,a=e*Math.sign(t[3]);i[2]-=(a||e)*r}return i}requiresSlot(e,t){if(t===C.Color||t===C.Alpha||t===C.Highlight||t===C.ObjectAndLayerIdColor){if(e===V.DRAPED_MATERIAL)return!0;const{drawInSecondSlot:t,occlusionTest:s}=this.parameters;return e===(t?V.LABEL_MATERIAL:V.HUD_MATERIAL)||s&&e===V.OCCLUSION_PIXELS}return!1}createGLMaterial(e){return new Se(e)}calculateRelativeScreenBounds(e,t,s=x()){return function(e,t,s,i=Pe){o(i,e.anchorPosition),i[0]*=-t[0],i[1]*=-t[1],i[0]+=e.screenOffset[0]*s,i[1]+=e.screenOffset[1]*s}(this.parameters,e,t,s),s[2]=s[0]+e[0],s[3]=s[1]+e[1],s}}class Se extends j{constructor(e){super({...e,...e.material.parameters})}selectProgram(e){return this.ensureTechnique(ue,e)}beginSlot(e){return this.updateTexture(this._material.parameters.textureId),this._material.setParameters(this.textureBindParameters),this.selectProgram(e)}}function ye(e,t,s,i,r,a,o,n){let l=t-r-(n[0]>0?i[0]*n[0]:0),c=l+i[0]+2*r,p=s-r-(n[1]>0?i[1]*n[1]:0),f=p+i[1]+2*r;const d=o.distanceFieldBoundingBox;return o.textureIsSignedDistanceField&&null!=d&&(l+=i[0]*d[0],p+=i[1]*d[1],c-=i[0]*(1-d[2]),f-=i[1]*(1-d[3]),l-=a,c+=a,p-=a,f+=a),e[0]>l&&e[0]<c&&e[1]>p&&e[1]<f}const Ae=new de,Pe=n(),be=y(),xe=y(),Ie=P(),Te=y(),_e=y(),Ce=i(),Ee=i(),je=a(),ze=y(),Le={normal:Te,cosAngle:0},Me=a(),we=1,Re=2,Ue=[0,0],De=A(0,0,1);class Ne extends z{constructor(){super(...arguments),this.renderOccluded=N.Occlude,this.color=b(1,1,1,1),this.texCoordScale=[1,1],this.polygonOffset=!1,this.anchorPosition=l(.5,.5),this.screenOffset=[0,0],this.shaderPolygonOffset=1e-5,this.textureIsSignedDistanceField=!1,this.outlineColor=b(1,1,1,1),this.outlineSize=0,this.vvSizeEnabled=!1,this.vvSize=null,this.vvColor=null,this.vvOpacity=null,this.vvSymbolAnchor=null,this.vvSymbolRotationMatrix=null,this.hasSlicePlane=!1,this.pixelSnappingEnabled=!0,this.occlusionTest=!0,this.binaryHighlightOcclusion=!0,this.centerOffsetUnits="world",this.drawInSecondSlot=!1,this.depthEnabled=!0,this.isDraped=!1}}const Ve=_().vec3f(G.POSITION).vec3f(G.NORMAL).vec2f(G.UV0).vec4u8(G.COLOR).vec2f(G.SIZE).vec4f(G.AUXPOS1).vec4f(G.AUXPOS2),He=Ve.clone().vec4u8(G.OBJECTANDLAYERIDCOLOR);class Ge{constructor(t){this._material=t,this.vertexBufferLayout=e("enable-feature:objectAndLayerId-rendering")?He:Ve}elementCount(e){return 6*e.indices.get(G.POSITION).length}write(e,t,s,i,r){B(s.indices.get(G.POSITION),s.vertexAttributes.get(G.POSITION).data,e,i.position,r,6),F(s.indices.get(G.NORMAL),s.vertexAttributes.get(G.NORMAL).data,t,i.normal,r,6);const a=s.vertexAttributes.get(G.UV0).data;let o,n,l,c;if(null==a||a.length<4){const e=this._material.parameters;o=0,n=0,l=e.texCoordScale[0],c=e.texCoordScale[1]}else o=a[0],n=a[1],l=a[2],c=a[3];l=Math.min(1.99999,l+1),c=Math.min(1.99999,c+1);let p=s.indices.get(G.POSITION).length,f=r;const d=i.uv0;for(let e=0;e<p;++e)d.set(f,0,o),d.set(f,1,n),f+=1,d.set(f,0,l),d.set(f,1,n),f+=1,d.set(f,0,l),d.set(f,1,c),f+=1,d.set(f,0,l),d.set(f,1,c),f+=1,d.set(f,0,o),d.set(f,1,c),f+=1,d.set(f,0,o),d.set(f,1,n),f+=1;X(s.indices.get(G.COLOR),s.vertexAttributes.get(G.COLOR).data,4,i.color,r,6);const h=s.indices.get(G.SIZE),u=s.vertexAttributes.get(G.SIZE).data;p=h.length;const m=i.size;f=r;for(let e=0;e<p;++e){const t=u[2*h[e]],s=u[2*h[e]+1];for(let e=0;e<6;++e)m.set(f,0,t),m.set(f,1,s),f+=1}if(s.indices.get(G.AUXPOS1)&&s.vertexAttributes.get(G.AUXPOS1)?W(s.indices.get(G.AUXPOS1),s.vertexAttributes.get(G.AUXPOS1).data,i.auxpos1,r,6):q(i.auxpos1,r,6*p),s.indices.get(G.AUXPOS2)&&s.vertexAttributes.get(G.AUXPOS2)?W(s.indices.get(G.AUXPOS2),s.vertexAttributes.get(G.AUXPOS2).data,i.auxpos2,r,6):q(i.auxpos2,r,6*p),null!=s.objectAndLayerIdColor&&s.indices.get(G.POSITION)){const e=s.indices.get(G.POSITION).length,t=i.getField(G.OBJECTANDLAYERIDCOLOR,I);Z(s.objectAndLayerIdColor,t,e,r,6)}}}export{Oe as H,de as S};
