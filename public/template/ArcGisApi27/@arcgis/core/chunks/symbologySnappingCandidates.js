/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.27/esri/copyright.txt for details.
*/
import"./typedArrayUtil.js";import{L as t}from"./LRUCache.js";import{o as e}from"./ensureType.js";import{throwIfAborted as n}from"../core/promiseUtils.js";import{j as s}from"./unitUtils.js";import{g as o}from"./unitConversionUtils.js";import{clone as i}from"../core/lang.js";import{n as a}from"./string.js";function r(t=!1,e){if(t){const{elevationInfo:t,alignPointsInFeatures:n,spatialReference:s}=e;return new h(t,n,s)}return new c}class c{async alignCandidates(t,e){return t}notifyElevationSourceChange(){}}class h{constructor(e,n,o){this._elevationInfo=e,this._alignPointsInFeatures=n,this.spatialReference=o,this._alignmentsCache=new t(1024),this._cacheVersion=0,this._metersPerVerticalUnit=s(o)}async alignCandidates(t,e){const n=this._elevationInfo;return null==n||"absolute-height"!==n.mode||n.featureExpressionInfo?this._alignComputedElevationCandidates(t,e):(this._alignAbsoluteElevationCandidates(t,n),t)}notifyElevationSourceChange(){this._alignmentsCache.clear(),this._cacheVersion++}_alignAbsoluteElevationCandidates(t,e){const{offset:n,unit:s}=e;if(null==n)return;const i=n*(o(s??"meters")/this._metersPerVerticalUnit);for(const e of t)switch(e.type){case"edge":e.start.z+=i,e.end.z+=i;continue;case"vertex":e.target.z+=i;continue}}async _alignComputedElevationCandidates(t,s){const o=new Map;for(const n of t)e(o,n.objectId,l).push(n);const[i,a,r]=this._prepareQuery(o),c=await this._alignPointsInFeatures(i,s);if(n(s),r!==this._cacheVersion)return this._alignComputedElevationCandidates(t,s);this._applyCacheAndResponse(i,c,a);const{drapedObjectIds:h,failedObjectIds:u}=c,d=[];for(const e of t){const{objectId:t}=e;h.has(t)&&"edge"===e.type&&(e.draped=!0),u.has(t)||d.push(e)}return d}_prepareQuery(t){const e=[],n=[];for(const[s,o]of t){const t=[];for(const e of o)this._addToQueriesOrCachedResult(s,e.target,t,n),"edge"===e.type&&(this._addToQueriesOrCachedResult(s,e.start,t,n),this._addToQueriesOrCachedResult(s,e.end,t,n));0!==t.length&&e.push({objectId:s,points:t})}return[e,n,this._cacheVersion]}_addToQueriesOrCachedResult(t,e,n,s){const o=d(t,e),i=this._alignmentsCache.get(o);null==i?n.push(e):s.push(new u(e,i))}_applyCacheAndResponse(t,{elevations:e,drapedObjectIds:n,failedObjectIds:s},o){for(const t of o)t.apply();let i=0;const a=this._alignmentsCache;for(const{objectId:o,points:r}of t){if(s.has(o)){i+=r.length;continue}const t=!n.has(o);for(const n of r){const s=d(o,n),r=e[i++];n.z=r,t&&a.put(s,r,1)}}}}class u{constructor(t,e){this.point=t,this.z=e}apply(){this.point.z=this.z}}function d(t,{x:e,y:n,z:s}){return`${t}-${e}-${n}-${s??0}}`}function l(){return[]}class f{filter(t,e){return e}notifyElevationSourceChange(){}}class p{filter(t,e){const{point:n,distance:s}=t,{z:o}=n;if(null==o)return e;if(0===e.length)return e;const i=function(t){return"number"==typeof t?{x:t,y:t,z:t}:t}(s),a=this._updateCandidatesTo3D(e,n,i).filter(g);return a.sort(m),a}_updateCandidatesTo3D(t,e,n){for(const s of t)switch(s.type){case"edge":_(s,e,n);continue;case"vertex":C(s,e,n);continue}return t}}function g(t){return t.distance<=1}function y(t=!1){return t?new p:new f}function _(t,e,{x:n,y:s,z:o}){const{start:i,end:a,target:r}=t;t.draped||function(t,e,n,s){const o=s.x-n.x,i=s.y-n.y,a=s.z-n.z,r=o*o+i*i+a*a,c=(e.x-n.x)*o+(e.y-n.y)*i+a*(e.z-n.z),h=Math.min(1,Math.max(0,c/r)),u=n.x+o*h,d=n.y+i*h,l=n.z+a*h;t.x=u,t.y=d,t.z=l}(r,e,i,a);const c=(e.x-r.x)/n,h=(e.y-r.y)/s,u=(e.z-r.z)/o;t.distance=Math.sqrt(c*c+h*h+u*u)}function C(t,e,{x:n,y:s,z:o}){const{target:i}=t,a=(e.x-i.x)/n,r=(e.y-i.y)/s,c=(e.z-i.z)/o,h=Math.sqrt(a*a+r*r+c*c);t.distance=h}function m(t,e){return t.distance-e.distance}function z(t=!1,e){return t?new b(e):new x}class x{async fetch(){return[]}notifySymbologyChange(){}}class b{constructor(e){this._getSymbologyCandidates=e,this._candidatesCache=new t(1024),this._cacheVersion=0}async fetch(t,e){if(0===t.length)return[];const s=[],o=[],a=this._candidatesCache;for(const e of t){const t=j(e),n=a.get(t);if(n)for(const t of n)o.push(i(t));else s.push(e),a.put(t,[],1)}if(0===s.length)return o;const r=this._cacheVersion,{candidates:c,sourceCandidateIndices:h}=await this._getSymbologyCandidates(s,e);if(n(e),r!==this._cacheVersion)return this.fetch(t,e);const u=[],{length:d}=c;for(let t=0;t<d;++t){const e=c[t],n=j(s[h[t]]),o=a.get(n);o.push(e),a.put(n,o,o.length),u.push(i(e))}return o.concat(u)}notifySymbologyChange(){this._candidatesCache.clear(),this._cacheVersion++}}function j(t){switch(t.type){case"vertex":{const{objectId:e,target:n}=t,s=`${e}-vertex-${n.x}-${n.y}-${n.z??0}`;return a(s).toString()}case"edge":{const{objectId:e,start:n,end:s}=t,o=`${e}-edge-${n.x}-${n.y}-${n.z??0}-to-${s.x}-${s.y}-${s.z??0}`;return a(o).toString()}default:return""}}export{y as a,z as b,r as g};
