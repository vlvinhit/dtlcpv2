/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.27/esri/copyright.txt for details.
*/
import"./typedArrayUtil.js";import{c as t}from"./mathUtils.js";import{f as o}from"./mat3.js";import{c as e}from"./mat3f64.js";import{i,j as s,s as n,m as r,g as l,n as a,r as u,o as f,p as c}from"./mat4.js";import{c as p}from"./mat4f64.js";import{s as S}from"./vec3.js";import{c as d}from"./vec3f64.js";import{m as E}from"./lengthUtils.js";import{_}from"./tslib.es6.js";import v from"../core/Accessor.js";import{property as m}from"../core/accessorSupport/decorators/property.js";import"./ensureType.js";import{subclass as z}from"../core/accessorSupport/decorators/subclass.js";import{N as T}from"./interfaces2.js";import{R as y}from"./Material.js";import{U as I,B as h}from"./ShaderBuilder.js";let R=class extends v{constructor(){super(...arguments),this.SCENEVIEW_HITTEST_RETURN_INTERSECTOR=!1,this.DECONFLICTOR_SHOW_VISIBLE=!1,this.DECONFLICTOR_SHOW_INVISIBLE=!1,this.DECONFLICTOR_SHOW_GRID=!1,this.LABELS_SHOW_BORDER=!1,this.TEXT_SHOW_BASELINE=!1,this.TEXT_SHOW_BORDER=!1,this.OVERLAY_DRAW_DEBUG_TEXTURE=!1,this.OVERLAY_SHOW_CENTER=!1,this.SHOW_POI=!1,this.TESTS_DISABLE_OPTIMIZATIONS=!1,this.TESTS_DISABLE_FAST_UPDATES=!1,this.DRAW_MESH_GEOMETRY_NORMALS=!1,this.FEATURE_TILE_FETCH_SHOW_TILES=!1,this.FEATURE_TILE_TREE_SHOW_TILES=!1,this.TERRAIN_TILE_TREE_SHOW_TILES=!1,this.I3S_TREE_SHOW_TILES=!1,this.I3S_SHOW_MODIFICATIONS=!1,this.LOD_INSTANCE_RENDERER_DISABLE_UPDATES=!1,this.LOD_INSTANCE_RENDERER_COLORIZE_BY_LEVEL=!1,this.EDGES_SHOW_HIDDEN_TRANSPARENT_EDGES=!1,this.LINE_WIREFRAMES=!1}};_([m()],R.prototype,"SCENEVIEW_HITTEST_RETURN_INTERSECTOR",void 0),_([m()],R.prototype,"DECONFLICTOR_SHOW_VISIBLE",void 0),_([m()],R.prototype,"DECONFLICTOR_SHOW_INVISIBLE",void 0),_([m()],R.prototype,"DECONFLICTOR_SHOW_GRID",void 0),_([m()],R.prototype,"LABELS_SHOW_BORDER",void 0),_([m()],R.prototype,"TEXT_SHOW_BASELINE",void 0),_([m()],R.prototype,"TEXT_SHOW_BORDER",void 0),_([m()],R.prototype,"OVERLAY_DRAW_DEBUG_TEXTURE",void 0),_([m()],R.prototype,"OVERLAY_SHOW_CENTER",void 0),_([m()],R.prototype,"SHOW_POI",void 0),_([m()],R.prototype,"TESTS_DISABLE_OPTIMIZATIONS",void 0),_([m()],R.prototype,"TESTS_DISABLE_FAST_UPDATES",void 0),_([m()],R.prototype,"DRAW_MESH_GEOMETRY_NORMALS",void 0),_([m()],R.prototype,"FEATURE_TILE_FETCH_SHOW_TILES",void 0),_([m()],R.prototype,"FEATURE_TILE_TREE_SHOW_TILES",void 0),_([m()],R.prototype,"TERRAIN_TILE_TREE_SHOW_TILES",void 0),_([m()],R.prototype,"I3S_TREE_SHOW_TILES",void 0),_([m()],R.prototype,"I3S_SHOW_MODIFICATIONS",void 0),_([m()],R.prototype,"LOD_INSTANCE_RENDERER_DISABLE_UPDATES",void 0),_([m()],R.prototype,"LOD_INSTANCE_RENDERER_COLORIZE_BY_LEVEL",void 0),_([m()],R.prototype,"EDGES_SHOW_HIDDEN_TRANSPARENT_EDGES",void 0),_([m()],R.prototype,"LINE_WIREFRAMES",void 0),R=_([z("esri.views.3d.support.DebugFlags")],R);const O=new R;var D,A;!function(t){t[t.Undefined=0]="Undefined",t[t.DefinedSize=1]="DefinedSize",t[t.DefinedScale=2]="DefinedScale"}(D||(D={})),function(t){t[t.Undefined=0]="Undefined",t[t.DefinedAngle=1]="DefinedAngle"}(A||(A={}));class L{constructor(t){this.field=t}}class C extends L{constructor(t){super(t),this.minSize=[0,0,0],this.maxSize=[0,0,0],this.offset=[0,0,0],this.factor=[0,0,0],this.type=[D.Undefined,D.Undefined,D.Undefined]}}class N extends L{constructor(t){super(t),this.colors=[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],this.values=[0,0,0,0,0,0,0,0]}}class x extends L{constructor(t){super(t),this.values=[0,0,0,0,0,0,0,0],this.opacityValues=[0,0,0,0,0,0,0,0]}}class H{}function W(t){return null!=t}function U(t){return"number"==typeof t}function V(t){return"string"==typeof t}function g(t,o){t&&t.push(o)}function B(t,o,e,i,s){const n=t.minSize,r=t.maxSize;if(t.expression)return g(s,"Could not convert size info: expression not supported"),!1;if(t.useSymbolValue){const t=i.symbolSize[e];return o.minSize[e]=t,o.maxSize[e]=t,o.offset[e]=o.minSize[e],o.factor[e]=0,o.type[e]=D.DefinedSize,!0}if(W(t.field))return W(t.stops)?2===t.stops.length&&U(t.stops[0].size)&&U(t.stops[1].size)?(F(t.stops[0].size,t.stops[1].size,t.stops[0].value,t.stops[1].value,o,e),o.type[e]=D.DefinedSize,!0):(g(s,"Could not convert size info: stops only supported with 2 elements"),!1):U(n)&&U(r)&&W(t.minDataValue)&&W(t.maxDataValue)?(F(n,r,t.minDataValue,t.maxDataValue,o,e),o.type[e]=D.DefinedSize,!0):"unknown"===t.valueUnit?(g(s,"Could not convert size info: proportional size not supported"),!1):null!=E[t.valueUnit]?(o.minSize[e]=-1/0,o.maxSize[e]=1/0,o.offset[e]=0,o.factor[e]=1/E[t.valueUnit],o.type[e]=D.DefinedSize,!0):(g(s,"Could not convert size info: scale-dependent size not supported"),!1);if(!W(t.field)){if(t.stops&&t.stops[0]&&U(t.stops[0].size))return o.minSize[e]=t.stops[0].size,o.maxSize[e]=t.stops[0].size,o.offset[e]=o.minSize[e],o.factor[e]=0,o.type[e]=D.DefinedSize,!0;if(U(n))return o.minSize[e]=n,o.maxSize[e]=n,o.offset[e]=n,o.factor[e]=0,o.type[e]=D.DefinedSize,!0}return g(s,"Could not convert size info: unsupported variant of sizeInfo"),!1}function F(t,o,e,i,s,n){const r=Math.abs(i-e)>0?(o-t)/(i-e):0;s.minSize[n]=r>0?t:o,s.maxSize[n]=r>0?o:t,s.offset[n]=t-e*r,s.factor[n]=r}function M(t,o,e){t[4*o]=e.r/255,t[4*o+1]=e.g/255,t[4*o+2]=e.b/255,t[4*o+3]=e.a}function b(t,o,e){const i=2===e&&"arithmetic"===t.rotationType;o.offset[e]=i?90:0,o.factor[e]=i?-1:1,o.type[e]=1}class j{constructor(t,o=[1,1,1],e=[1,1,1],i=1,s=[0,0,0],n=[1,1,1],r=[0,0,0]){this.supports=t,this.modelSize=o,this.symbolSize=e,this.unitInMeters=i,this.anchor=s,this.scale=n,this.rotation=r}}function P(t,o,e){if(!t)return null;const i=t.reduce(((t,i)=>{if(!t)return t;if(i.valueExpression)return g(e,"Could not convert visual variables: arcade expressions not supported"),null;switch(i.type){case"size":return o.supports.size?function(t,o,e,i){if(t.normalizationField||t.valueRepresentation)return g(i,"Could not convert size info: unsupported property"),null;if(null!=(s=t.field)&&!V(s))return g(i,"Could not convert size info: field is not a string"),null;var s;if(o.size){if(t.field)if(o.size.field){if(t.field!==o.size.field)return g(i,"Could not convert size info: multiple fields in use"),null}else o.size.field=t.field}else o.size=new C(t.field);let n;switch(t.axis){case"width":return n=B(t,o.size,0,e,i),n?o:null;case"height":return n=B(t,o.size,2,e,i),n?o:null;case"depth":return n=B(t,o.size,1,e,i),n?o:null;case"width-and-depth":return n=B(t,o.size,0,e,i),n&&B(t,o.size,1,e,i),n?o:null;case null:case void 0:case"all":return n=B(t,o.size,0,e,i),n=n&&B(t,o.size,1,e,i),n=n&&B(t,o.size,2,e,i),n?o:null;default:return g(i,`Could not convert size info: unknown axis "${t.axis}""`),null}}(i,t,o,e):t;case"color":return o.supports.color?function(t,o,e){if(t.normalizationField)return g(e,"Could not convert color info: unsupported property"),null;if(V(t.field)){if(!t.stops)return g(e,"Could not convert color info: missing stops or colors"),null;{if(t.stops.length>8)return g(e,"Could not convert color info: too many color stops"),null;o.color=new N(t.field);const i=t.stops;for(let t=0;t<8;++t){const e=i[Math.min(t,i.length-1)];o.color.values[t]=e.value,M(o.color.colors,t,e.color)}}}else{if(!(t.stops&&t.stops.length>=0))return g(e,"Could not convert color info: no field and no colors/stops"),null;{const e=t.stops&&t.stops.length>=0&&t.stops[0].color;o.color={field:null,values:[0,0,0,0,0,0,0,0],colors:[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0]};for(let t=0;t<8;t++)o.color.values[t]=1/0,M(o.color.colors,t,e)}}return o}(i,t,e):t;case"opacity":return o.supports.opacity?function(t,o,e){if(t.normalizationField)return g(e,"Could not convert opacity info: unsupported property"),null;if(V(t.field)){if(!t.stops)return g(e,"Could not convert opacity info: missing stops or opacities"),null;{if(t.stops.length>8)return g(e,"Could not convert opacity info: too many opacity stops"),null;o.opacity=new x(t.field);const i=t.stops;for(let t=0;t<8;++t){const e=i[Math.min(t,i.length-1)];o.opacity.values[t]=e.value,o.opacity.opacityValues[t]=e.opacity}}}else{if(!(t.stops&&t.stops.length>=0))return g(e,"Could not convert opacity info: no field and no opacities/stops"),null;{const e=t.stops&&t.stops.length>=0?t.stops[0].opacity:0;o.opacity={field:null,values:[0,0,0,0,0,0,0,0],opacityValues:[0,0,0,0,0,0,0,0]};for(let t=0;t<8;t++)o.opacity.values[t]=1/0,o.opacity.opacityValues[t]=e}}return o}(i,t,e):null;case"rotation":return o.supports.rotation?function(t,o,e){if(!V(t.field))return g(e,"Could not convert rotation info: field is not a string"),null;if(o.rotation){if(t.field)if(o.rotation.field){if(t.field!==o.rotation.field)return g(e,"Could not convert rotation info: multiple fields in use"),null}else o.rotation.field=t.field}else o.rotation={field:t.field,offset:[0,0,0],factor:[1,1,1],type:[0,0,0]};switch(t.axis){case"tilt":return b(t,o.rotation,0),o;case"roll":return b(t,o.rotation,1),o;case null:case void 0:case"heading":return b(t,o.rotation,2),o;default:return g(e,`Could not convert rotation info: unknown axis "${t.axis}""`),null}}(i,t,e):t;default:return null}}),new H);return!(t.length>0&&i)||i.size||i.color||i.opacity||i.rotation?i&&i.size&&!function(t,o,e){for(let e=0;e<3;++e){let i=o.unitInMeters;t.type[e]===D.DefinedSize&&(i*=o.modelSize[e],t.type[e]=D.DefinedScale),t.minSize[e]=t.minSize[e]/i,t.maxSize[e]=t.maxSize[e]/i,t.offset[e]=t.offset[e]/i,t.factor[e]=t.factor[e]/i}let i;if(t.type[0]!==D.Undefined)i=0;else if(t.type[1]!==D.Undefined)i=1;else{if(t.type[2]===D.Undefined)return g(e,"No size axis contains a valid size or scale"),!1;i=2}for(let o=0;o<3;++o)t.type[o]===D.Undefined&&(t.minSize[o]=t.minSize[i],t.maxSize[o]=t.maxSize[i],t.offset[o]=t.offset[i],t.factor[o]=t.factor[i],t.type[o]=t.type[i]);return!0}(i.size,o,e)?null:i:null}class w{constructor(t,o,e){this.visualVariables=t,this.materialParameters=o,this.requiresShaderTransformation=e}}function G(t,o){if(!t)return null;if(O.TESTS_DISABLE_FAST_UPDATES)return null;const e=P(t.visualVariables,o);return e?new w(e,k(e,o),!!e.size):null}function Y(t,o,e){if(!o||!t)return!1;const i=t.visualVariables,s=P(o.visualVariables,e);return!!s&&!!(X(i.size,s.size,"size")&&X(i.color,s.color,"color")&&X(i.rotation,s.rotation,"rotation")&&X(i.opacity,s.opacity,"opacity"))&&(t.visualVariables=s,t.materialParameters=k(s,e),t.requiresShaderTransformation=!!s.size,!0)}function X(t,o,e){if(!!t!=!!o)return!1;if(t&&t.field!==o?.field)return!1;if(t&&"rotation"===e){const e=t,i=o;for(let t=0;t<3;t++)if(e.type[t]!==i.type[t]||e.offset[t]!==i.offset[t]||e.factor[t]!==i.factor[t])return!1}return!0}class Z extends T{constructor(t){super(),this.vvSize=t?.size??null,this.vvColor=t?.color??null,this.vvOpacity=t?.opacity??null}}function k(t,s){const n=new Z(t);return n.vvSize&&(n.vvSymbolAnchor=s.anchor,i(tt),function(t,o,e,i=p()){const s=t||0,n=o||0,r=e||0;0!==s&&u(i,i,-s/180*Math.PI),0!==n&&f(i,i,n/180*Math.PI),0!==r&&c(i,i,r/180*Math.PI)}(s.rotation[2],s.rotation[0],s.rotation[1],tt),n.vvSymbolRotationMatrix=n.vvSymbolRotationMatrix||e(),o(n.vvSymbolRotationMatrix,tt)),n}function q(o,e,i){if(!o.vvSize)return i;s(K,i);const u=o.vvSymbolRotationMatrix;n(tt,u[0],u[1],u[2],0,u[3],u[4],u[5],0,u[6],u[7],u[8],0,0,0,0,1),r(K,K,tt);for(let i=0;i<3;++i){const s=o.vvSize.offset[i]+e[0]*o.vvSize.factor[i];Q[i]=t(s,o.vvSize.minSize[i],o.vvSize.maxSize[i])}return l(K,K,Q),a(K,K,o.vvSymbolAnchor),K}function $(o,e,i){if(e.vvSize)for(let s=0;s<3;++s){const n=e.vvSize.offset[s]+i[0]*e.vvSize.factor[s];o[s]=t(n,e.vvSize.minSize[s],e.vvSize.maxSize[s])}else S(o,1,1,1)}function J(t,o){const e=null==t?0:o.attributes[t];return"number"==typeof e&&isFinite(e)?e:0}const K=p(),Q=d(),tt=p();class ot extends Z{constructor(){super(...arguments),this.renderOccluded=y.Occlude}}const et=8;class it extends I{constructor(t,o,e){super(t,"vec4",h.Pass,((e,i,s)=>e.setUniform4fv(t,o(i,s))),e)}}class st extends I{constructor(t,o,e){super(t,"float",h.Pass,((e,i,s)=>e.setUniform1fv(t,o(i,s))),e)}}export{j as C,st as F,ot as V,it as a,$ as b,O as d,q as e,J as g,G as i,Y as u,et as v};
