/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.27/esri/copyright.txt for details.
*/
import{e as t,g as e,y as i,z as s}from"./typedArrayUtil.js";import{L as r}from"./Logger.js";import{n,h as o}from"./maybe.js";import{c as a,b as f,u}from"./Texture.js";import{C as h}from"./contextUtils.js";import{B as _,U as c,d as l,D as b}from"./enums3.js";const d=r.getLogger("esri.views.webgl.BufferObject");class x{static createIndex(t,e,i){return new x(t,_.ELEMENT_ARRAY_BUFFER,e,i)}static createVertex(t,e,i){return new x(t,_.ARRAY_BUFFER,e,i)}static createUniform(t,e,i){if(t.type!==h.WEBGL2)throw new Error("Uniform buffers are supported in WebGL2 only!");return new x(t,_.UNIFORM_BUFFER,e,i)}static createPixelPack(t,e=c.STREAM_READ,i){if(t.type!==h.WEBGL2)throw new Error("Pixel pack buffers are supported in WebGL2 only!");const s=new x(t,_.PIXEL_PACK_BUFFER,e);return i&&s.setSize(i),s}static createPixelUnpack(t,e=c.STREAM_DRAW,i){if(t.type!==h.WEBGL2)throw new Error("Pixel unpack buffers are supported in WebGL2 only!");return new x(t,_.PIXEL_UNPACK_BUFFER,e,i)}constructor(t,e,i,s){this._context=t,this.bufferType=e,this.usage=i,this._glName=null,this._size=-1,this._indexType=void 0,t.instanceCounter.increment(l.BufferObject,this),this._glName=this._context.gl.createBuffer(),a(this._context.gl),s&&this.setData(s)}get glName(){return this._glName}get size(){return this._size}get indexType(){return this._indexType}get byteLength(){return this.bufferType===_.ELEMENT_ARRAY_BUFFER?this._indexType===b.UNSIGNED_INT?4*this._size:2*this._size:this._size}get _isVAOAware(){return this.bufferType===_.ELEMENT_ARRAY_BUFFER||this.bufferType===_.ARRAY_BUFFER}dispose(){this._context?.gl?(this._glName&&(this._context.gl.deleteBuffer(this._glName),this._glName=null),this._context.instanceCounter.decrement(l.BufferObject,this),this._context=n(this._context)):this._glName&&d.warn("Leaked WebGL buffer object")}setSize(t,e=null){if(t<=0&&d.error("Buffer size needs to be positive!"),this.bufferType===_.ELEMENT_ARRAY_BUFFER&&null!=e)switch(this._indexType=e,e){case b.UNSIGNED_SHORT:t*=2;break;case b.UNSIGNED_INT:t*=4}this._setBufferData(t)}setData(i){if(!i)return;let s=i.byteLength;this.bufferType===_.ELEMENT_ARRAY_BUFFER&&(t(i)&&(s/=2,this._indexType=b.UNSIGNED_SHORT),e(i)&&(s/=4,this._indexType=b.UNSIGNED_INT)),this._setBufferData(s,i)}_setBufferData(t,e=null){this._size=t;const i=this._context.getBoundVAO();this._isVAOAware&&this._context.bindVAO(null),this._context.bindBuffer(this);const s=this._context.gl;null!=e?s.bufferData(this.bufferType,e,this.usage):s.bufferData(this.bufferType,t,this.usage),a(s),this._isVAOAware&&this._context.bindVAO(i)}setSubData(t,e,i,s){if(!t)return;(e<0||e*t.BYTES_PER_ELEMENT>=this.byteLength)&&d.error("offset is out of range!"),i>=s&&d.error("end must be bigger than start!"),(e+(s-i))*t.BYTES_PER_ELEMENT>this.byteLength&&d.error("An attempt to write beyond the end of the buffer!");const r=this._context.getBoundVAO();this._isVAOAware&&this._context.bindVAO(null),this._context.bindBuffer(this);const n=this._context.gl;if(this._context.type===h.WEBGL2)n.bufferSubData(this.bufferType,e*t.BYTES_PER_ELEMENT,t,i,s-i);else{const r=0===i&&s===t.length?t:t.subarray(i,s);n.bufferSubData(this.bufferType,e*t.BYTES_PER_ELEMENT,r)}a(n),this._isVAOAware&&this._context.bindVAO(r)}getSubData(t,e=0,s,r){if(this._context.type!==h.WEBGL2)return void d.error("Get buffer subdata is supported in WebGL2 only!");if(s<0||r<0)return void d.error("Problem getting subdata: offset and length were less than zero!");const n=i(t)?t.BYTES_PER_ELEMENT:1;if(n*((s??0)+(r??0))>t.byteLength)return void d.error("Problem getting subdata: offset and length exceeded destination size!");e+n*(r??0)>this.byteLength&&d.warn("Potential problem getting subdata: requested data exceeds buffer size!");const o=this._context.gl;this._context.bindBuffer(this,_.COPY_READ_BUFFER),o.getBufferSubData(_.COPY_READ_BUFFER,e,t,s,r),this._context.unbindBuffer(_.COPY_READ_BUFFER)}async getSubDataAsync(t,e=0,i,s){this._context.type===h.WEBGL2?(await this._context.clientWaitAsync(),this.getSubData(t,e,i,s)):d.error("Get buffer subdata is supported in WebGL2 only!")}}const g=r.getLogger("esri.views.webgl.VertexArrayObject");let E=class{constructor(t,e,i,s,r=null){this._context=t,this._locations=e,this._layout=i,this._buffers=s,this._indexBuffer=r,this._glName=null,this._initialized=!1,t.instanceCounter.increment(l.VertexArrayObject,this)}get glName(){return this._glName}get context(){return this._context}get vertexBuffers(){return this._buffers}get indexBuffer(){return this._indexBuffer}get byteSize(){return Object.keys(this._buffers).reduce(((t,e)=>t+this._buffers[e].byteLength),null!=this._indexBuffer?this._indexBuffer.byteLength:0)}get layout(){return this._layout}get locations(){return this._locations}get memoryEstimate(){return this.byteSize+(Object.keys(this._buffers).length+(this._indexBuffer?1:0))*s}dispose(){if(this._context){this._context.getBoundVAO()===this&&this._context.bindVAO(null);for(const t in this._buffers)this._buffers[t]?.dispose(),delete this._buffers[t];this._indexBuffer=o(this._indexBuffer),this.disposeVAOOnly()}else(this._glName||Object.getOwnPropertyNames(this._buffers).length>0)&&g.warn("Leaked WebGL VAO")}disposeVAOOnly(){if(this._glName){const t=this._context?.capabilities?.vao;t.deleteVertexArray(this._glName),this._glName=null}this._context.instanceCounter.decrement(l.VertexArrayObject,this),this._context=n(this._context)}initialize(){if(this._initialized)return;const t=this._context.capabilities.vao;if(t){const e=t.createVertexArray();t.bindVertexArray(e),this._bindLayout(),t.bindVertexArray(null),this._glName=e}this._initialized=!0}bind(){this.initialize();const t=this._context.capabilities.vao;t?t.bindVertexArray(this.glName):(this._context.bindVAO(null),this._bindLayout())}_bindLayout(){const{_buffers:t,_layout:e,_indexBuffer:i}=this;t||g.error("Vertex buffer dictionary is empty!");const s=this._context.gl;for(const i in t){const s=t[i];s||g.error("Vertex buffer is uninitialized!");const r=e[i];r||g.error("Vertex element descriptor is empty!"),f(this._context,this._locations,s,r)}null!=i&&(this._context.capabilities.vao?s.bindBuffer(s.ELEMENT_ARRAY_BUFFER,i.glName):this._context.bindBuffer(i))}unbind(){this.initialize();const t=this._context.capabilities.vao;t?t.bindVertexArray(null):this._unbindLayout()}_unbindLayout(){const{_buffers:t,_layout:e}=this;t||g.error("Vertex buffer dictionary is empty!");for(const i in t){const s=t[i];s||g.error("Vertex buffer is uninitialized!");const r=e[i];u(this._context,this._locations,s,r)}null!=this._indexBuffer&&this._context.unbindBuffer(this._indexBuffer.bufferType)}};export{x as B,E as V};
