/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.27/esri/copyright.txt for details.
*/
import{_ as e}from"./tslib.es6.js";import{b as t}from"./shapingUtils.js";import"../core/Error.js";import"./typedArrayUtil.js";import"./Logger.js";import{c as s,u as r}from"./maybe.js";import{isAbortError as o,throwIfAborted as i}from"../core/promiseUtils.js";import"./ensureType.js";import{subclass as l}from"../core/accessorSupport/decorators/subclass.js";import{d as a,h as m}from"./diffUtils.js";import n from"../geometry/SpatialReference.js";import{j as p}from"./visualVariablesUtils.js";import{b as c}from"./enums4.js";import{a as y,c as u,b as j,M as d,d as h}from"./Matcher.js";import{B as f}from"./BaseProcessor.js";import"./BidiEngine.js";import"./screenUtils.js";import"./mat2d.js";import"./mat2df32.js";import"./vec2.js";import"./common.js";import"./vec2f32.js";import"./alignmentUtils.js";import"./number2.js";import"./Rect.js";import"../core/lang.js";import"./object.js";import"../config.js";import"./string.js";import"./metadata.js";import"./utils.js";import"./tracking.js";import"../core/Accessor.js";import"../core/Handles.js";import"./get.js";import"./ObjectPool.js";import"./ObservableBase.js";import"../core/accessorSupport/decorators/property.js";import"./watch.js";import"./ArrayPool.js";import"../core/scheduling.js";import"./nextTick.js";import"./PooledArray.js";import"../core/Collection.js";import"../core/Evented.js";import"./shared.js";import"./SimpleObservable.js";import"../core/JSONSupport.js";import"./unitUtils.js";import"./jsonMap.js";import"./writer.js";import"./color.js";import"./enums.js";import"./enums3.js";import"./VertexElementDescriptor.js";import"./definitions.js";import"./TileStrategy.js";import"./QueueProcessor.js";import"./Queue.js";import"./aaBoundingRect.js";import"./mathUtils.js";import"./vec3.js";import"./vec3f64.js";import"./vec4.js";import"../geometry/Extent.js";import"../geometry/Geometry.js";import"./reader.js";import"../geometry/Point.js";import"../core/accessorSupport/decorators/cast.js";import"../geometry/support/webMercatorUtils.js";import"./TileInfoView.js";import"./TileKey2.js";import"./tileUtils.js";import"./libtess.js";import"./assets.js";import"../request.js";import"../kernel.js";import"../core/urlUtils.js";import"./MaterialKey.js";import"./cimAnalyzer.js";import"../Color.js";import"./colorUtils.js";import"./fontUtils.js";import"./arcadeOnDemand.js";import"../geometry.js";import"../geometry/Multipoint.js";import"./zmUtils.js";import"../geometry/Polygon.js";import"./extentUtils.js";import"../geometry/Polyline.js";import"./typeUtils.js";import"../geometry/support/jsonUtils.js";import"./OptimizedGeometry.js";import"./GeometryUtils.js";import"../symbols/Font.js";import"./utils7.js";import"../symbols.js";import"../symbols/CIMSymbol.js";import"./enumeration.js";import"../layers/support/fieldUtils.js";import"../symbols/Symbol.js";import"../symbols/ExtrudeSymbol3DLayer.js";import"../symbols/Symbol3DLayer.js";import"./utils2.js";import"../symbols/edges/Edges3D.js";import"./materialUtils.js";import"./opacityUtils.js";import"../symbols/edges/SketchEdges3D.js";import"../symbols/edges/SolidEdges3D.js";import"./Symbol3DMaterial.js";import"../symbols/FillSymbol.js";import"../symbols/SimpleLineSymbol.js";import"../symbols/LineSymbol.js";import"../symbols/LineSymbolMarker.js";import"./lineMarkers.js";import"../symbols/FillSymbol3DLayer.js";import"../symbols/patterns/LineStylePattern3D.js";import"../symbols/patterns/StylePattern3D.js";import"./utils3.js";import"./colors.js";import"./symbolLayerUtils3D.js";import"./aaBoundingBox.js";import"../symbols/IconSymbol3DLayer.js";import"./persistableUrlUtils.js";import"../symbols/LabelSymbol3D.js";import"../symbols/Symbol3D.js";import"./collectionUtils.js";import"../portal/Portal.js";import"../core/Loadable.js";import"../core/Promise.js";import"./locale.js";import"../portal/PortalQueryParams.js";import"../portal/PortalQueryResult.js";import"../portal/PortalUser.js";import"../portal/PortalFolder.js";import"../portal/PortalGroup.js";import"../symbols/LineSymbol3DLayer.js";import"../symbols/LineStyleMarker3D.js";import"../core/Clonable.js";import"../symbols/ObjectSymbol3DLayer.js";import"../symbols/PathSymbol3DLayer.js";import"../symbols/TextSymbol3DLayer.js";import"../symbols/WaterSymbol3DLayer.js";import"../symbols/support/StyleOrigin.js";import"./Thumbnail.js";import"./calloutUtils.js";import"../symbols/callouts/Callout3D.js";import"../symbols/callouts/LineCallout3D.js";import"../symbols/support/Symbol3DVerticalOffset.js";import"../symbols/LineSymbol3D.js";import"../symbols/MarkerSymbol.js";import"../symbols/MeshSymbol3D.js";import"../symbols/PictureFillSymbol.js";import"./urlUtils.js";import"../symbols/PictureMarkerSymbol.js";import"../symbols/PointSymbol3D.js";import"../symbols/PolygonSymbol3D.js";import"../symbols/SimpleFillSymbol.js";import"../symbols/SimpleMarkerSymbol.js";import"../symbols/TextSymbol.js";import"../symbols/WebStyleSymbol.js";import"./callExpressionWithFeature.js";import"./quantizationUtils.js";import"./floatRGBA.js";import"./defaultsJSON.js";import"./GeometryUtils2.js";import"./earcut.js";import"./_commonjsHelpers.js";import"./TurboLine.js";import"./LRUCache.js";import"./MemCache.js";import"./ExpandedCIM.js";import"./devEnvironmentUtils.js";import"./styleUtils.js";import"./featureFlags.js";import"./webStyleSymbolUtils.js";import"../symbols/support/jsonUtils.js";import"./layerUtils.js";import"../core/HandleOwner.js";import"./WatchUpdatingTracking.js";import"../core/reactiveUtils.js";class b{constructor(e){this._remoteClient=e,this._resourceMap=new Map,this._inFlightResourceMap=new Map,this.geometryEngine=null,this.geometryEnginePromise=null}destroy(){}async fetchResource(e,t){const s=this._resourceMap,r=s.get(e);if(r)return r;let i=this._inFlightResourceMap.get(e);if(i)return i;try{i=this._remoteClient.invoke("tileRenderer.fetchResource",{url:e},{...t}),this._inFlightResourceMap.set(e,i),i.then((t=>(this._inFlightResourceMap.delete(e),s.set(e,t),t)))}catch(e){return o(e)?null:{width:0,height:0}}return i}getResource(e){return this._resourceMap.get(e)??null}loadFont(e){return Promise.resolve(null)}}function g(e,t){return(!e.minScale||e.minScale>=t)&&(!e.maxScale||e.maxScale<=t)}function S(e){const t=e.message,r={message:{data:{},tileKey:t.tileKey,tileKeyOrigin:t.tileKeyOrigin,version:t.version},transferList:new Array};for(const e in t.data){const o=e,i=t.data[o];if(r.message.data[o]=null,null!=i){const e=i.stride,t=i.indices.slice(0),l=i.vertices.slice(0),a=i.records.slice(0),m={stride:e,indices:t,vertices:l,records:a,metrics:s(i.metrics,(e=>e.slice(0)))};r.transferList.push(t,l,a),r.message.data[o]=m}}return r}let _=class extends f{constructor(){super(...arguments),this.type="symbol",this._matchers={feature:null,aggregate:null},this._bufferData=new Map,this._bufferIds=new Map}initialize(){this.handles.add([this.tileStore.on("update",this.onTileUpdate.bind(this))]),this._resourceManagerProxy=new b(this.remoteClient)}destroy(){this._resourceManagerProxy.destroy()}get supportsTileUpdates(){return!0}forEachBufferId(e){this._bufferIds.forEach((t=>{t.forEach(e)}))}async update(e,t){const s=t.schema.processors[0];if("symbol"!==s.type)return;const r=a(this._schema,s);(m(r,"mesh")||m(r,"target"))&&(e.mesh=!0,e.why?.mesh.push("Symbology changed"),this._schema=s,this._factory=this._createFactory(s),this._factory.update(s,this.tileStore.tileScheme.tileInfo))}onTileMessage(e,t,s,r){return i(r),this._onTileData(e,t,s,r)}onTileClear(e,t){const s={clear:!0,end:t};return this._bufferData.delete(e.key.id),this._bufferIds.delete(e.key.id),this.remoteClient.invoke("tileRenderer.onTileData",{tileKey:e.id,data:s})}onTileError(e,t,s){const r=s.signal,o={tileKey:e.id,error:t};return this.remoteClient.invoke("tileRenderer.onTileError",o,{signal:r})}onTileUpdate(e){for(const t of e.removed)this._bufferData.has(t.key.id)&&this._bufferData.delete(t.key.id),this._bufferIds.has(t.key.id)&&this._bufferIds.delete(t.key.id);for(const t of e.added)this._bufferData.forEach((e=>{for(const s of e)s.message.tileKey===t.id&&this._updateTileMesh("append",t,S(s),[],!1,!1,null)}))}_addBufferData(e,t){this._bufferData.has(e)||this._bufferData.set(e,[]),this._bufferData.get(e)?.push(S(t))}_createFactory(e){const{geometryType:t,objectIdField:r,fields:o}=this.service,i={geometryType:t,fields:o,spatialReference:n.fromJSON(this.spatialReference)},l=new y(((e,t)=>this.remoteClient.invoke("tileRenderer.getMaterialItems",e,t)),this.tileStore.tileScheme.tileInfo),{matcher:a,aggregateMatcher:m}=e.mesh;return this._store=l,this._matchers.feature=u(a,l,i,this._resourceManagerProxy),this._matchers.aggregate=s(m,(e=>u(e,l,i,this._resourceManagerProxy))),new j(t,r,l)}async _onTileData(e,t,s,r){i(r);const{type:o,addOrUpdate:l,remove:a,clear:m,end:n}=t,p=!!this._schema.mesh.sortKey;if(!l){const t={type:o,addOrUpdate:null,remove:a,clear:m,end:n,sort:p};return this.remoteClient.invoke("tileRenderer.onTileData",{tileKey:e.id,data:t},r)}const c=this._processFeatures(e,l,s,r,t.status?.version);try{const s=await c;if(null==s){const t={type:o,addOrUpdate:null,remove:a,clear:m,end:n,sort:p};return this.remoteClient.invoke("tileRenderer.onTileData",{tileKey:e.id,data:t},r)}const i=[];for(const t of s){let s=!1;const r=t.message.bufferIds,o=e.key.id,l=t.message.tileKey;if(o!==l&&null!=r){if(!this.tileStore.get(l)){this._addBufferData(o,t),i.push(t);continue}let e=this._bufferIds.get(l);e||(e=new Set,this._bufferIds.set(l,e));const a=Array.from(r);for(const t of a){if(e.has(t)){s=!0;break}e.add(t)}}s||(this._addBufferData(o,t),i.push(t))}await Promise.all(i.map((s=>{const i=e.key.id===s.message.tileKey,l=i?t.remove:[],a=i&&t.end;return this._updateTileMesh(o,e,s,l,a,!!t.clear,r.signal)})))}catch(t){this._handleError(e,t,r)}}async _updateTileMesh(e,t,r,o,l,a,m){const n=e,p=r.message.tileKey,c=!!this._schema.mesh.sortKey;p!==t.key.id&&(l=!1);const y={type:n,addOrUpdate:s(r,(e=>e.message)),remove:o,clear:a,end:l,sort:c},u={transferList:s(r,(e=>e.transferList))||[]||[],signal:m};return i(u),this.remoteClient.invoke("tileRenderer.onTileData",{tileKey:p,data:y},u)}async _processFeatures(e,t,s,r,o){if(null==t||!t.hasFeatures)return null;const l={transform:e.transform,hasZ:!1,hasM:!1},a=this._factory,m={viewingMode:"",scale:e.scale},n=await this._matchers.feature,p=await this._matchers.aggregate;i(r);const c=this._getLabelInfos(e,t);return await a.analyze(t.getCursor(),this._resourceManagerProxy,n,p,l,m),i(r),this._writeFeatureSet(e,t,l,c,a,s,o)}_writeFeatureSet(e,t,s,r,o,i,l){const a=t.getSize(),m=this._schema.mesh.matcher.symbologyType,n=new d(e.key.id,{features:a,records:a,metrics:0},m,i,m!==c.HEATMAP,l),p={viewingMode:"",scale:e.scale},y=t.getCursor();for(;y.next();)try{const t=y.getDisplayId(),i=null!=r?r.get(t):null;o.writeCursor(n,y,s,p,e.level,i,this._resourceManagerProxy)}catch(e){}const u=e.tileInfoView.tileInfo.isWrappable;return n.serialize(u)}_handleError(e,t,s){if(!o(t)){const r={tileKey:e.id,error:t.message};return this.remoteClient.invoke("tileRenderer.onTileError",r,{signal:s.signal})}return Promise.resolve()}_getLabelingSchemaForScale(e){const t=this._schema.mesh.labels;if(null==t)return null;if("subtype"===t.type){const s={type:"subtype",classes:{}};let r=!1;for(const o in t.classes){const i=t.classes[o].filter((t=>g(t,e.scale)));r=r||!!i.length,s.classes[o]=i}return r?s:null}const s=t.classes.filter((t=>g(t,e.scale)));return s.length?{type:"simple",classes:s}:null}_getLabels(e,t){if("subtype"===t.type){const s=this.service.subtypeField,o=r(s,"Expected to find subtype Field"),i=e.readAttribute(o);return null==i?[]:t.classes[i]??[]}return t.classes}_getLabelInfos(e,s){const r=this._getLabelingSchemaForScale(e);if(null==r)return null;const o=new Map,i=s.getCursor();for(;i.next();){const e=i.getDisplayId(),s=[],l=p(e),a=l&&1!==i.readAttribute("cluster_count")?"aggregate":"feature",m=this._getLabels(i,r);for(const r of m){if(r.target!==a)continue;const o=i.getStorage(),m=l&&"feature"===a?o.getComputedStringAtIndex(i.readAttribute("referenceId"),r.fieldIndex):o.getComputedStringAtIndex(e,r.fieldIndex);if(!m)continue;const n=t(m.toString()),p=n[0],c=n[1];this._store.getMosaicItem(r.symbol,h(p)).then((e=>{s[r.index]={glyphs:e.glyphMosaicItems??[],rtl:c,index:r.index}}))}o.set(e,s)}return o}};_=e([l("esri.views.2d.layers.features.processors.SymbolProcessor")],_);const D=_;export{D as default};
