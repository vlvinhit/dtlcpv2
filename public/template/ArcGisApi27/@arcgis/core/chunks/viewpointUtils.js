/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.27/esri/copyright.txt for details.
*/
import e from"../Camera.js";import"../geometry.js";import t from"../Graphic.js";import n from"../Viewpoint.js";import{r}from"./asyncUtils.js";import"./typedArrayUtil.js";import{C as a,b as i,c as o}from"./Cyclical.js";import s from"../core/Error.js";import{createResolver as l,eachAlways as c}from"../core/promiseUtils.js";import{f as u,t as f}from"./mat3.js";import{c as m}from"./mat3f64.js";import{c as p}from"./mat4f64.js";import{c as d,C as g,e as h,b as y,a as v,i as x,l as w,n as M,f as R,d as b,A as T,E as z,z as j,s as S,t as G}from"./vec3.js";import{c as C,f as A,e as P}from"./vec3f64.js";import{projectPointToVector as D,projectVectorToVector as E,projectVectorToPoint as U,project as O,projectBuffer as H,computeTranslationToOriginAndRotation as F}from"../geometry/projection.js";import{c as k,k as I,o as L,A as B,v as q,e as W,b as Z,w as J,r as _,q as K}from"./aaBoundingBox.js";import{p as N,c as V,A as X}from"./aaBoundingRect.js";import{o as Y}from"./frustum.js";import{c as $}from"./scaleUtils.js";import{geographicToWebMercator as Q,project as ee,canProject as te}from"../geometry/support/webMercatorUtils.js";import{E as ne}from"./unitUtils.js";import{a as re}from"./Intersector2.js";import{L as ae}from"./Logger.js";import{r as ie,b as oe,d as se,a as le}from"./mathUtils.js";import ce from"../geometry/Point.js";import ue from"../geometry/SpatialReference.js";import{V as fe}from"./ViewingMode.js";import{y as me,o as pe,a as de,C as ge}from"./mat4.js";import he from"../geometry/Extent.js";import{g as ye,a as ve}from"./earthUtils.js";import{g as xe}from"./ElevationProvider.js";import{i as we}from"./spatialReferenceSupport.js";import Me from"../geometry/Geometry.js";function Re(e,t,n,r){return null!=e.renderCoordsHelper.fromRenderCoords(t.eye,Se,r)&&N(n,Se)}function be(e,t){return e.elevationProvider?e.elevationProvider.getElevation(t[0],t[1],t[2],e.renderCoordsHelper.spatialReference,"ground")??0:0}function Te(e,t,n,r){const a=e.state.camera.clone();t&&n&&r&&(a.eye=t,a.center=n,a.up=r),function(e,t,n){let r=je[e.viewingMode];r||(r=re(e.state.viewingMode),r.options.backfacesTerrain=!e.state.isGlobal,r.options.invisibleTerrain=!0,je[e.viewingMode]=r);const{isGlobal:a}=e.state;return!(!e.sceneIntersectionHelper.intersectRay(t,r,n)||ze(e,t.origin,n))||!(!e.renderCoordsHelper.intersectManifold(t,0,n)||ze(e,t.origin,n))||!!a&&function(e,t,n){const r=x(e.origin,e.origin)-n*n,a=r>0?Math.sqrt(r)/3:1;return h(t,e.direction,a/w(e.direction)),v(t,t,e.origin),!0}(t,n,ne(e.spatialReference).radius)}(e,a.ray,Ge)||d(Ge,a.center);const i=e.state.constraints,o=i.minimumPoiDistance;if(g(a.eye,Ge)<o){const t=i.collision.enabled;d(Ce,a.viewForward),h(Ce,Ce,o),t?a.eye=y(Se,Ge,Ce):v(Ge,a.eye,Ce);const n=e.renderCoordsHelper,r=n.getAltitude(a.eye),s=i.collision.elevationMargin;t&&r<s&&(y(Ce,Ge,a.eye),a.eye=n.setAltitude(Se,s,a.eye),v(Ge,a.eye,Ce))}return a.center=Ge,a}function ze(e,t,n){if(!e.state.isGlobal||!e.stateManager.constraintsManager)return!1;const r=be(e,t),a=e.stateManager.constraintsManager.nearFarHeuristic,{far:i}=a.compute(t,n,e.renderDataExtent,r,Ae),o=i*i;return g(t,n)>o}const je={},Se=C(),Ge=C(),Ce=C(),Ae={near:0,far:0},Pe=C(),De=C();function Ee(){return{direction:C(),up:C()}}function Ue(e,t,n,r,a){let i=M(Pe,e),o=x(i,r);const s=o>0;o=Math.abs(o),o>.99&&(o=Math.abs(x(t,r)),o<.99?(d(i,t),s&&h(i,i,-1)):i=null);let l=0;if(i){h(De,r,x(r,i)),y(i,i,De);const e=x(i,a)/(w(i)*w(a));R(De,i,a),l=(x(De,r)>0?1:-1)*ie(oe(e))}const c=ie(oe(-x(r,e)/w(e)));return n?(n.heading=l,n.tilt=c,n):{heading:l,tilt:c}}const Oe=A(0,1,0),He=A(0,0,1),Fe=p(),ke=C(),Ie=C();function Le(e,t,n,r=Ee()){const{direction:a,up:i}=r;return me(Fe,-se(t)),pe(Fe,Fe,se(n)),b(a,He,Fe),h(a,a,-1),b(i,Oe,Fe),r}function Be(e,t,n,r,a){const i=e.renderSpatialReference,o=e.map&&e.spatialReference||t.spatialReference;return D(t,ke,i),D(t,Ie,i),ke[0]-=n/2,Ie[0]+=n/2,ke[1]-=r/2,Ie[1]+=r/2,E(ke,i,ke,o),E(Ie,i,Ie,o),a?(a.xmin=ke[0],a.ymin=ke[1],a.xmax=Ie[0],a.ymax=Ie[1],a.spatialReference=o):a=new he(ke[0],ke[1],Ie[0],Ie[1],o),a}const qe=Object.freeze(Object.defineProperty({__proto__:null,directionToHeadingTilt:function(e,t,n,r){return Ue(t,n,r,He,Oe)},eyeForCenterWithHeadingTilt:function(e,t,n,r){const a=Le(0,n,r),i=C();return h(i,a.direction,-t),v(i,i,e),{up:a.up,eye:i,heading:n,tilt:r}},eyeTiltToLookAtTilt:function(e){return se(e)},headingTiltToDirectionUp:Le,lookAtTiltToEyeTilt:function(e){return ie(e)},toExtent:Be},Symbol.toStringTag,{value:"Module"})),We=A(0,0,1),Ze=M(C(),A(1,1,1)),Je=new a(-180,180),_e=p(),Ke=C(),Ne=C();function Ve(e,t,n,r=Ee()){R(Ke,e,We),0===x(Ke,Ke)&&R(Ke,e,Ze),de(_e,-se(t),e),ge(_e,_e,-se(n),Ke);const{up:a,direction:i}=r;return R(a,Ke,e),M(a,a),b(a,a,_e),M(i,e),T(i,i),b(i,i,_e),r}function Xe(e){const t=e[1];e[1]=-e[2],e[2]=t}function Ye(e,t){const n=Ve(t,e.heading,e.tilt);return e.up=n.up,e}function $e(e,t,n,r,a){let o,s,l,c;const u=t.latitude,f=ne(e.spatialReference).radius,m=t.longitude,p=ye(u,n,f)/2;o=m-p,s=m+p;const d=se(u),g=(1+Math.sin(d))/(1-Math.sin(d)),h=(g+1)*Math.tan(r/f/2),y=h*h;function v(e){const t=Math.PI/2;return(e=i.normalize(e,-t))>t&&(e=Math.PI-e),e}if(l=1.5*Math.PI-2*Math.atan(.5*(h+Math.sqrt(4*g+y))),c=l+r/f,l=v(l),c=v(c),c<l){const e=c;c=l,l=e}if(l=Math.max(ie(l),-90),c=Math.min(ie(c),90),s=Je.monotonic(o,s),s-o>180){const e=(s-o-180)/2;o+=e,s-=e}const x=e.spatialReference&&e.spatialReference.isGeographic?e.spatialReference:ue.WGS84;return a?(a.xmin=o,a.ymin=l,a.xmax=s,a.ymax=c,a.spatialReference=x):a=new he(o,l,s,c,x),e.spatialReference&&e.spatialReference.isWebMercator&&Q(a,!1,a),a}const Qe=Object.freeze(Object.defineProperty({__proto__:null,directionToHeadingTilt:function(e,t,n,r){const a=Ke,i=Ne;return M(a,e),R(Ne,a,We),0===x(Ne,Ne)&&R(Ne,a,Ze),R(i,Ne,a),Ue(t,n,r,a,i)},eyeForCenterWithHeadingTilt:function(e,t,n,r){const a={eye:C(),up:null,tilt:r,heading:n},i=Ke;i[0]=e[0],i[1]=e[2],i[2]=-e[1];const o=t,s=se(n),l=se(r),c=Math.sin(s),u=Math.cos(s),f=Math.sin(l),m=Math.cos(l),p=w(i);let d;if(Math.abs(l)<1e-8)d=o+p;else{const e=p/f,t=le(o/e),n=Math.PI-l-t;d=e*Math.sin(n)}const g=m*o,y=o*o*(f*f),v=u*u*y,x=d-g,M=x*x,R=v*(v+M-i[1]*i[1]);if(R<0)return h(a.eye,i,d/p),a.tilt=0,Ye(a,e);const b=Math.sqrt(R),T=i[1]*x,z=v+M;let j;if(j=u>0?-b+T:b+T,Math.abs(z)<1e-8)return p<1e-8?(a.eye[0]=0,a.eye[1]=0,a.eye[2]=o):h(a.eye,i,d/p),a.tilt=0,Xe(a.eye),Ye(a,e);a.eye[1]=j/z;const S=c*c*y,G=f*o,A=u*G*a.eye[1],P=a.eye[1]*a.eye[1],D=1-P,E=Math.sqrt(D),U=v*P+S-2*A*E*x+D*M;return Math.abs(U)<1e-8?(h(a.eye,i,d/p),a.tilt=0,Xe(a.eye),Ye(a,e)):(a.eye[0]=(D*(d*i[0]-g*i[0])-G*E*(i[0]*a.eye[1]*u+i[2]*c))/U,a.eye[2]=(D*(d*i[2]-g*i[2])-G*E*(i[2]*a.eye[1]*u-i[0]*c))/U,h(a.eye,a.eye,d),Xe(a.eye),Ye(a,e))},eyeTiltToLookAtTilt:function(e,t,n){const r=se(e),a=w(t);return le(n/(a/Math.sin(r)))+r},headingTiltToDirectionUp:Ve,lookAtTiltToEyeTilt:function(e,t,n){const r=w(t),a=Math.sqrt(n*n+r*r-2*n*r*Math.cos(Math.PI-e)),i=le(n/(a/Math.sin(e)));return ie(e-i)},toExtent:$e},Symbol.toStringTag,{value:"Module"})),et=ae.getLogger("esri.views.3d.support.cameraUtils"),tt=39.37,nt=96,rt=1,at=8,it=5,ot=1,st=C(),lt={heading:0,tilt:0},ct=new ce,ut=new a(-20037508.342788905,20037508.342788905),ft=new a(-180,180);var mt;function pt(e){return e.spatialReference||ue.WGS84}function dt(e){return"global"===e.viewingMode?Qe:qe}function gt(e,t,n,r,a){return dt(e).headingTiltToDirectionUp(t,n,r,a)}function ht(e,t){if(null==t)return null;const n=e.renderSpatialReference,r=dt(e).headingTiltToDirectionUp,a=C();if(!D(t.position,a,n))return null;const i=r(a,t.heading,t.tilt);h(i.direction,i.direction,e.state.camera.distance),v(i.direction,i.direction,a);const o=Te(e,a,i.direction,i.up);return o.fov=se(t.fov),o}!function(e){e[e.LOCKED=0]="LOCKED",e[e.ADJUST=1]="ADJUST"}(mt||(mt={}));const yt=C();function vt(t,n,r){const a=t.renderSpatialReference,i=bt(t,n.eye,n.viewForward,n.up,lt);let o=pt(t);return E(n.eye,a,yt,o)||(o=ue.WGS84,E(n.eye,a,yt,o)),null==r?new e(new ce(yt,o),i.heading,i.tilt,ie(n.fov)):(r.position.x=yt[0],r.position.y=yt[1],r.position.z=yt[2],r.position.spatialReference=o,r.heading=i.heading,r.tilt=i.tilt,r.fov=ie(n.fov),r)}function xt(e,t,n){const r=e.state.camera,a=r.width/2/r.pixelRatio;return e.renderCoordsHelper.viewingMode===fe.Global&&null!=n&&(t*=Math.cos(se(n))),t/=e.renderCoordsHelper.unitInMeters,a/(nt*tt/t)/Math.tan(r.fovX/2)}function wt(e,t,n){const r=e.state.camera,a=t*Math.tan(r.fovX/2),i=r.width/2/r.pixelRatio;let o=nt*tt/(i/a);return e.renderCoordsHelper.viewingMode===fe.Global&&null!=n&&(o/=Math.cos(se(n))),o*e.renderCoordsHelper.unitInMeters}function Mt(e,t,n,r,a,i){return Rt(e,t,xt(e,n,t.latitude),r,a,i)}function Rt(e,t,n,r,a,i){if(Ht(i)){const o=new Ot(i.signal);return Tt(e,r.heading,r.tilt,t,n,a,o),void o.resolver.promise.then((t=>{const n=Pt(e,t,r.fov);if(null!=n)return i.resolver.resolve(n);i.resolver.reject()}),(e=>i.resolver.reject(e)))}const o=Tt(e,r.heading,r.tilt,t,n,a);return Pt(e,o,r.fov,i)}function bt(e,t,n,r,a){return dt(e).directionToHeadingTilt(t,n,r,a)}function Tt(e,t,n,r,a,i,o){const s=r&&r instanceof ce?r:null;if(Ht(o))return async function(e,t,n){const r=C();if(t)if(t instanceof ce){if(D(t,r,e.renderSpatialReference),null==t.z&&null!=e.basemapTerrain&&null!=e.elevationProvider){const a=await e.elevationProvider.queryElevation(t.x,t.y,t.z??0,t.spatialReference,"ground",n);return null!=a&&e.renderCoordsHelper.setAltitude(r,a),r}}else d(r,t);else d(r,e.state.camera.center);return r}(e,r,o.signal).then((r=>{zt(e,t,n,s,r,a,i,o)}),(e=>o.resolver.reject(e))),null;const l=function(e,t){const n=C();if(t&&t instanceof ce){if(D(t,n,e.renderSpatialReference),null==t.z&&null!=e.basemapTerrain&&null!=e.elevationProvider){const r=xe(e.elevationProvider,t);null!=r&&e.renderCoordsHelper.setAltitude(n,r)}}else d(n,t||e.state.camera.center);return n}(e,r);return zt(e,t,n,s,l,a,i,o)}function zt(e,t,n,r,a,i,o,s){if(null==r){const t=e.renderSpatialReference;if(null==(r=U(a,t,pt(e))))return null}i=Math.max(i,e.state.constraints.minimumPoiDistance);const l=function(e,t,n,r,a,i){let o=0;return i===mt.ADJUST&&function(e,t,n){const r=e.pointsOfInterest.centerOnSurfaceFrequent.distance;if(Math.log(n/r)/Math.LN2>at)return!0;const a=e.renderSpatialReference,i=pt(e),o=U(t,a,i),s=U(e.pointsOfInterest.centerOnSurfaceFrequent.renderLocation,a,i);if(null==o||null==s)return!1;const l=Math.tan(.5*e.state.camera.fov)*r;return s.distance(o)/l>it}(e,r,a)?(t=0,o=function(e,t,n,r){const a=At(e,r,t,n);if(!e.state.constraints.tilt)return a;const i=e.state.constraints.tilt(t);i.max=Math.min(i.max,.5*Math.PI);const o=i.min*(1-Gt)+i.max*Gt;return Math.min(a,o)}(e,a,n,r)):o=At(e,r,a,n),o=e.state.constraints.clampTilt(a,o),{heading:t,tilt:n=Ct(e,r,a,o)}}(e,t,n,a,i,o),c=(0,dt(e).eyeForCenterWithHeadingTilt)(a,i,l.heading,l.tilt);if(o===mt.ADJUST&&"global"===e.viewingMode&&n>0){const l=()=>{const l=Ct(e,a,i,function(e,t,n,r){let a=At(e,r,t,n);if(!e.state.constraints.tilt)return a;const i=e.state.constraints.tilt(t);return a=Math.min(a,.5*Math.PI),i.min*(1-Gt)+a*Gt}(e,i,n,a));return o=n-l<1?mt.LOCKED:mt.ADJUST,zt(e,t,l,r,a,i,o,s)},u=e.map.ground.navigationConstraint;if(!u||"stay-above"===u.type){if(function(e,t){return!!(e.basemapTerrain&&e.renderCoordsHelper.fromRenderCoords(t,ct,e.spatialReference)&&e.elevationProvider&&(xe(e.elevationProvider,ct)??0)>(ct.z??0)-ot)}(e,c.eye))return l();if(Ht(s))return async function(e,t,n){if(!e.renderCoordsHelper.fromRenderCoords(t,ct,e.spatialReference)||!e.elevationProvider)return!1;const r=ct.z??0;return(await e.elevationProvider.queryElevation(ct.x,ct.y,r,ct.spatialReference,"ground",n)??0)>r-ot}(e,c.eye,s.signal).then((e=>e?l():(s.resolver.resolve({eye:c.eye,up:c.up,center:P(a),heading:c.heading,tilt:c.tilt}),null))),null}}const u=!s||Ht(s)?{center:C(),eye:C(),up:C(),tilt:0,heading:0}:s;return u.eye=c.eye,u.up=c.up,u.center=P(a),u.heading=c.heading,u.tilt=c.tilt,Ht(s)&&s.resolver.resolve(u),u}function jt(e,t,n,r,a,i=null){let o,s,l;if(e.state.isGlobal){if(!we(t.spatialReference,fe.Global))return Ht(i)&&i.resolver.reject(),null;const e=new ce(t.xmin,t.ymin,t.spatialReference),n=new ce(t.xmax,t.ymax,t.spatialReference),r=t.spatialReference.isGeographic?ft:ut;o=new ce({x:r.center(e.x,n.x),y:(n.y+e.y)/2,z:null!=t.zmax&&null!=t.zmin?(t.zmax+t.zmin)/2:void 0,spatialReference:t.spatialReference});const a=ne(t.spatialReference),c=ve(o,e,n);s=c.lon,l=c.lat,r.diff(e.x,n.x)>r.range/2&&(s+=a.halfCircumference),s=Math.min(s,a.halfCircumference),l=Math.min(l,a.halfCircumference)}else{const n=e.renderSpatialReference??t.spatialReference;n.equals(t.spatialReference)||(t=O(t,n)),s=t.xmax-t.xmin,l=t.ymax-t.ymin;const r=null!=t.zmax&&null!=t.zmin?(t.zmax+t.zmin)/2:void 0;o=new ce({x:t.xmin+.5*s,y:t.ymin+.5*l,z:r,spatialReference:n})}const c=null!=t.zmax&&null!=t.zmin?t.zmax-t.zmin:0,u=e.state.camera,f=1/Math.tan(u.fovX/2),m=1/Math.tan(u.fovY/2),p=1/Math.tan(u.fov/2),d=Math.max(.5*s*f,.5*l*m,.5*c*p)/rt;if(Ht(i)){const t=new Ot(i.signal);return Tt(e,n,r,o,d,a,t),void t.resolver.promise.then((t=>{const n=Pt(e,t,e.camera.fov);if(null!=n)return i.resolver.resolve(n);i.resolver.reject()}),(e=>i.resolver.reject(e)))}const g=Tt(e,n,r,o,d,a);return Pt(e,g,e.camera.fov,i)}function St(e,t,n){const r=e.renderSpatialReference,a=U(n,r,pt(e));if(null==a)return null;const i=Math.tan(t.fovX/2),o=Math.tan(t.fovY/2),s=z(t.eye,n),l=2*s*i*rt,c=2*s*o*rt;return"global"===e.viewingMode?$e(e,a,l,c):Be(e,a,l,c)}const Gt=.7;function Ct(e,t,n,r){return dt(e).lookAtTiltToEyeTilt(r,t,n)}function At(e,t,n,r){return dt(e).eyeTiltToLookAtTilt(r,t,n)}function Pt(t,n,r,a){if(null==n)return null;const i=t.renderSpatialReference,o=U(n.eye,i,pt(t));return null==o?null:null!=a?(a.position=o,a.heading=n.heading,a.tilt=n.tilt,a.fov=r,a):new e(o,n.heading,n.tilt,r)}function Dt(e,t){const n=e.basemapTerrain?.tilingScheme;if(n)return n.levelAtScale(t);et.error("#scaleToZoom()","Cannot compute zoom from scale without a tiling scheme")}function Et(e,t){const n=e.basemapTerrain?.tilingScheme;if(n)return n.scaleAtLevel(t);et.error("#zoomToScale()","Cannot compute scale from zoom without a tiling scheme")}function Ut(e,t){return E(t.center,e.renderSpatialReference,st,ue.WGS84),wt(e,t.distance,st[1])}class Ot{constructor(e){this.signal=e,this.resolver=l()}}function Ht(e){return e&&"resolver"in e}function Ft(e){return 360-o.normalize(e)}function kt(e){return o.normalize(360-e)}function It(e){return null!=e&&e.resolver&&e.resolver.reject(),null}function Lt(e,t,n,r=null){if(!t)return It(r);const a=e.spatialReference||ue.WGS84;if(null!=t.camera){const e=ee(t.camera.position,a);if(null==e)return It(r);const n=t.camera.clone();return n.position=e.clone(),function(e,t){return null!=e&&e.resolver&&e.resolver.resolve(t),t}(r,n)}if(null==t.targetGeometry)return It(r);const i=t.get("targetGeometry.spatialReference");if(i&&!te(i,a))return It(r);const o=vt(e,e.state.camera);let s=mt.ADJUST;if(null!=t.rotation&&(o.heading=Ft(t.rotation),s=mt.LOCKED),null!=n&&(o.tilt=n),"point"===t.targetGeometry.type){const n=t.targetGeometry;let a;const i=t.targetGeometry.clone();return a=null!=t.scale?xt(e,t.scale,n.latitude):e.state.camera.distance,Rt(e,i,a,o,s,r)}const l=t.targetGeometry.extent;return l?jt(e,l,o.heading,o.tilt,s,r):It(r)}function Bt(e,t,r=null){return null==r&&(r=new n),Jt(e,null,t.clone(),r)}async function qt(t,r,a){const i=function(e,t){if(!t||!e.spatialReference)return null;const n={target:void 0};return"declaredClass"in t||Array.isArray(t)?n.target=t:(Object.assign(n,t),t.center&&!n.target&&(n.target=t.center)),n}(t,r);if(!i)throw new s("viewpointutils-create:no-target","Missing target for creating viewpoint");const o=new e({fov:t.camera.fov}),l=new n({camera:o});if(i.target instanceof n){const e=await async function(e,t,n,r,a){if(null!=t.camera)return Nt(e,t.camera,a);a.scale=t.scale,a.rotation=t.rotation,a.targetGeometry=null!=t.targetGeometry?t.targetGeometry.clone():null,a.camera=null,null!=n.heading?a.rotation=kt(n.heading):null!=n.rotation&&(a.rotation=n.rotation);const i=Wt(e,n);null!=i&&(a.scale=i);const o=new Ot(r);return Lt(e,a,n.tilt,o),a.camera=await o.resolver.promise,a}(t,i.target,i,a,l);return Xt(e)}if(i.target instanceof e)return Xt(Nt(t,i.target,l));const c=null!=i.scale||null!=i.zoom;if(i.target instanceof he){const e=i.target.xmin===i.target.xmax||i.target.ymin===i.target.ymax;return Xt(c||e?await Vt(t,i,i.target.center,o,a,l):await async function(e,t,n,r,a,i){i.targetGeometry=n.clone(),vt(e,Te(e),r);const o=Zt(r,t)?mt.LOCKED:mt.ADJUST,s=new Ot(a);return jt(e,n,r.heading,r.tilt,o,s),i.camera=await s.resolver.promise,i}(t,i,i.target,o,a,l))}const m={boundingBox:I(),hasZ:!1,screenSpaceObjects:[]},p=c?function(e,t){const n=Wt(e,t);return n?$(n):void 0}(t,i):void 0;if(await Kt(t,i.target,p,m),isFinite(m.boundingBox[0])){let e;if(L(m.boundingBox,Yt),sn.x=Yt[0],sn.y=Yt[1],sn.z=Yt[2],sn.spatialReference=t.spatialReference,isFinite(sn.z)&&m.hasZ?e=q(m.boundingBox):(sn.z=void 0,e=X(B(m.boundingBox,tn))),c||e)return Xt(await Vt(t,i,sn,o,a,l));const n=function(e,t){if(!t.length)return.66;let n=Number.NEGATIVE_INFINITY;for(let e=0;e<t.length;e++){const r=t[e].screenSpaceBoundingRect;n=Math.max(n,Math.abs(r[0]),Math.abs(r[1]),Math.abs(r[2]),Math.abs(r[3]))}return.66-n/Math.min(e.width,e.height)*2}(t,m.screenSpaceObjects);return Xt(await async function(e,t,n,r,a,i,o,s){s.targetGeometry=n.clone();const l=Te(e),c=function(e,t,n,r,a){let i=0;null!=n.z?i=n.z:e.basemapTerrain&&e.elevationProvider&&(i=xe(e.elevationProvider,n)),S(Yt,n.x,n.y,i),F(e.spatialReference,Yt,$t,e.renderSpatialReference),u(Qt,$t),f(Qt,Qt),I(en);const o=[[0,1,2],[3,1,2],[0,4,2],[3,4,2],[0,1,5],[3,1,5],[0,4,5],[3,4,5]];for(let t=0;t<o.length;t++){const n=o[t];let a=r[n[2]];isFinite(a)||(a=i),S(Yt,r[n[0]],r[n[1]],a),E(Yt,e.spatialReference,Yt,e.renderSpatialReference),W(en,G(Yt,Yt,Qt))}const s=J(en),l=_(en),c=K(en),m=1/Math.tan(t.fovX/2),p=1/Math.tan(t.fovY/2),d=.5*Math.sqrt(s*s+c*c)*Math.max(p,m)+.5*l,g=.5*l*p+.5*Math.max(s,c);return Math.max(d,g)/a}(e,l,n,r,a);vt(e,l,i);const m=Zt(i,t)?mt.LOCKED:mt.ADJUST;s.scale=wt(e,c,s.targetGeometry.latitude);const p=new Ot(o);return Mt(e,s.targetGeometry,s.scale,i,m,p),s.camera=await p.resolver.promise,s}(t,i,sn,m.boundingBox,n,o,a,l))}return i.position?Xt(function(e,t,n,r){const a=Te(e);return d(nn,a.viewForward),bt(e,a.eye,nn,a.up,on),n.position=new ce(t.position),n.heading=null!=t.heading?t.heading:on.heading,n.tilt=null!=t.tilt?t.tilt:on.tilt,Jt(e,null,n,r)}(t,i,o,l)):Xt(await async function(e,t,n,r,a){const i=Te(e);return Vt(e,t,U(i.center,e.renderSpatialReference,e.spatialReference),n,r,a)}(t,i,o,a,l))}function Wt(e,t){return null==t.scale&&null!=t.zoom?Et(e,t.zoom):t.scale}function Zt(e,t){let n=!1;return null!=t.heading?(e.heading=t.heading,n=!0):null!=t.rotation&&(e.heading=Ft(t.rotation),n=!0),null!=t.tilt&&(e.tilt=t.tilt,n=!0),null!=t.fov&&(e.fov=t.fov),n}function Jt(e,t,n,r){const a=e.spatialReference||ue.WGS84;return null==(t=null!=t?t:ht(e,n))||(r.targetGeometry=U(t.center,e.renderSpatialReference,a),r.scale=Ut(e,t),r.rotation=kt(n.heading),r.camera=n),r}function _t(e,t,n){const r=()=>new s("viewpointutils:invalid-geometry","The target is missing a valid geometry");if(!t)throw r();if(!te(t.spatialReference,e.spatialReference))throw new s("viewpointutils:incompatible-spatialreference",`Spatial reference (${t.spatialReference?t.spatialReference.wkid:"unknown"}) is incompatible with the view (${e.spatialReference?.wkid})`,{geometry:t});const a=[];if(!t.hasZ&&e.basemapTerrain){let n;switch(t.type){case"point":n=t;break;case"multipoint":case"polyline":n=t.extent?.center;break;case"mesh":n=t.origin;break;case"extent":n=t.center;break;case"polygon":n=t.centroid}n&&null!=e.basemapTerrain.spatialReference&&te(n,e.basemapTerrain.spatialReference)&&e.elevationProvider?Yt[2]=xe(e.elevationProvider,n)??0:Yt[2]=0}(0,ln[t.type])(t,(e=>{a.push(e[0],e[1],e[2])}),Yt);const i=a.length/3;if(0===i)throw r();const o=new Array(a.length);if(H(a,t.spatialReference,0,o,e.spatialReference,0,i)){t.hasZ&&(n.hasZ=!0);for(let e=0;e<o.length;e+=3)t.hasZ?(Yt[0]=o[e],Yt[1]=o[e+1],Yt[2]=o[e+2]):(Yt[0]=o[e],Yt[1]=o[e+1]),W(n.boundingBox,Yt)}}async function Kt(e,n,a,i){if(Array.isArray(n)&&2===n.length){const t=n[0],r=n[1];if("number"==typeof t&&"number"==typeof r)return sn.x=t,sn.y=r,sn.z=void 0,sn.spatialReference=e.spatialReference?.isGeographic?e.spatialReference:ue.WGS84,void _t(e,sn,i)}n&&"map"in n&&"function"==typeof n.map?await c(n.map((t=>Kt(e,t,a,i)))):n instanceof Me?_t(e,n,i):n instanceof t&&await async function(e,t,n,a){const i=await r(e.whenViewForGraphic(t));if(!1===i.ok||null==i.value||!("whenGraphicBounds"in i.value))return void _t(e,t.geometry,a);const o=i.value,s=await r(o.whenGraphicBounds(t,{minDemResolution:n}));if(!1===s.ok)return void _t(e,t.geometry,a);const{screenSpaceObjects:l,boundingBox:c}=s.value;Z(a.boundingBox,c),l&&l.forEach((e=>{a.screenSpaceObjects.push(e)})),isFinite(c[2])&&(a.hasZ=!0)}(e,n,a,i)}function Nt(e,t,n){const r=e.spatialReference,a=ee(t.position,r);return null==a?null:((t=t.clone()).fov=e.camera.fov,t.position=a,Jt(e,null,t,n))}async function Vt(e,t,n,r,a,i){if(null==n)throw new s("createfromcenter","invalid point");i.targetGeometry=n.clone();const o=Te(e);if(t.position)return function(e,t,n,r,a,i){const o=e.renderSpatialReference;return D(n,rn,o),D(t,an,o),i.targetGeometry=new ce(t),a.position=new ce(n),y(nn,an,rn),bt(e,rn,nn,r.up,a),i.scale=wt(e,j(rn,an),i.targetGeometry.latitude),i.rotation=kt(a.heading),i.camera=a,i}(e,i.targetGeometry,t.position,o,r,i);if(t.zoomFactor){const r=o.distance/t.zoomFactor,a=h(Yt,o.viewForward,-r);o.eye=v(Yt,o.center,a),i.scale=wt(e,r,n.latitude)}vt(e,o,r);const l=Zt(r,t)?mt.LOCKED:mt.ADJUST;if(!t.zoomFactor){const s=Wt(e,t);null==s?(D(n,Yt,e.renderSpatialReference),Y(o.frustum,Yt)?i.scale=wt(e,j(o.eye,Yt),n.latitude):i.scale=Ut(e,o)):i.scale=s;const c=new Ot(a);Mt(e,i.targetGeometry,i.scale,r,l,c),i.camera=await c.resolver.promise}return i}function Xt(e){return e&&null!=e.camera&&(e.rotation=kt(e.camera.heading)),e}const Yt=C(),$t=p(),Qt=m(),en=k(),tn=V(),nn=C(),rn=C(),an=C(),on={heading:0,tilt:0},sn=new ce,ln={point(e,t,n){n[0]=e.x,n[1]=e.y,null!=e.z&&(n[2]=e.z),t(n)},polygon(e,t,n){const r=e.hasZ;for(let a=0;a<e.rings.length;a++){const i=e.rings[a];for(let e=0;e<i.length;e++)n[0]=i[e][0],n[1]=i[e][1],r&&(n[2]=i[e][2]),t(n)}},polyline(e,t,n){const r=e.hasZ;for(let a=0;a<e.paths.length;a++){const i=e.paths[a];for(let e=0;e<i.length;e++)n[0]=i[e][0],n[1]=i[e][1],r&&(n[2]=i[e][2]),t(n)}},multipoint(e,t,n){const r=e.points,a=e.hasZ;for(let e=0;e<r.length;e++)n[0]=r[e][0],n[1]=r[e][1],a&&(n[2]=r[e][2]),t(n)},extent(e,t,n){null!=e.zmin&&null!=e.zmax?(t(S(n,e.xmin,e.ymin,e.zmin)),t(S(n,e.xmax,e.ymin,e.zmin)),t(S(n,e.xmin,e.ymax,e.zmin)),t(S(n,e.xmax,e.ymax,e.zmin)),t(S(n,e.xmin,e.ymin,e.zmax)),t(S(n,e.xmax,e.ymin,e.zmax)),t(S(n,e.xmin,e.ymax,e.zmax)),t(S(n,e.xmax,e.ymax,e.zmax))):(t(S(n,e.xmin,e.ymin,n[2])),t(S(n,e.xmax,e.ymin,n[2])),t(S(n,e.xmin,e.ymax,n[2])),t(S(n,e.xmax,e.ymax,n[2])))},mesh(e,t,n){const r=e.vertexAttributes&&e.vertexAttributes.position;if(r)for(let e=0;e<r.length;e+=3)t(S(n,r[e],r[e+1],r[e+2]))}};export{mt as O,ht as a,Dt as b,qt as c,wt as d,Re as e,Bt as f,Te as g,jt as h,vt as i,Tt as j,xt as k,Lt as l,gt as m,Ee as n,bt as o,be as s,St as t,Et as z};
