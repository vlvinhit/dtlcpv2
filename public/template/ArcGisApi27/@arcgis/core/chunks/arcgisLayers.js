/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.27/esri/copyright.txt for details.
*/
import e from"../core/Error.js";import{getFilename as r,urlToObject as a}from"../core/urlUtils.js";import{p as t,f as s}from"./arcgisLayerUrl.js";import{a as l,f as o}from"./fetchService.js";import{t as n}from"./layerUtils.js";import{l as i}from"./lazyLayerLoader.js";import"../core/lang.js";import"./typedArrayUtil.js";import"./Logger.js";import"../config.js";import"./object.js";import"./string.js";import"./maybe.js";import"./persistableUrlUtils.js";import"../request.js";import"../kernel.js";import"../core/promiseUtils.js";const u={FeatureLayer:!0,SceneLayer:!0};async function c(c){const p=c.properties?.customParameters,f=await async function(c,y){let p=t(c);if(null==p&&(p=await async function(e,t){const o=await l(e,{customParameters:t});let n=null,i=null;const u=o.type;if("Feature Layer"===u||"Table"===u?(n="FeatureServer",i=o.id??null):"indexedVector"===u?n="VectorTileServer":o.hasOwnProperty("mapName")?n="MapServer":o.hasOwnProperty("bandCount")&&o.hasOwnProperty("pixelSizeX")?n="ImageServer":o.hasOwnProperty("maxRecordCount")&&o.hasOwnProperty("allowGeometryUpdates")?n="FeatureServer":o.hasOwnProperty("streamUrls")?n="StreamServer":m(o)?(n="SceneServer",i=o.id):o.hasOwnProperty("layers")&&m(o.layers?.[0])&&(n="SceneServer"),!n)return null;const c=null!=i?s(e):null;return{title:null!=c&&o.name||r(e),serverType:n,sublayer:i,url:{path:null!=c?c.serviceUrl:a(e).path}}}(c,y)),null==p)throw new e("arcgis-layers:url-mismatch","The url '${url}' is not a valid arcgis resource",{url:c});const{serverType:f,sublayer:d}=p;let I;const b={FeatureServer:"FeatureLayer",StreamServer:"StreamLayer",VectorTileServer:"VectorTileLayer"};switch(f){case"MapServer":if(null!=d)I="FeatureLayer";else{const e=await async function(e,r){return(await l(e,{customParameters:r})).tileInfo}(c,y);I=e?"TileLayer":"MapImageLayer"}break;case"ImageServer":{const e=await l(c,{customParameters:y}),{tileInfo:r,cacheType:a}=e;I=r?"LERC"!==r?.format?.toUpperCase()||a&&"elevation"!==a.toLowerCase()?"ImageryTileLayer":"ElevationLayer":"ImageryLayer";break}case"SceneServer":{const e=await l(p.url.path,{customParameters:y});if(I="SceneLayer",e){const r=e?.layers;if("Voxel"===e?.layerType)I="VoxelLayer";else if(r?.length){const e=r[0]?.layerType;null!=e&&null!=n[e]&&(I=n[e])}}break}default:I=b[f]}const S="FeatureServer"===f,w={parsedUrl:p,Constructor:null,layerOrTableId:S?d:void 0,sublayerIds:null,tableIds:null};if(u[I]&&null==d){const e=await async function(e,r,a){let t,s=!1;if("FeatureServer"===r){const r=await o(e,{customParameters:a});s=!!r.layersJSON,t=r.layersJSON||r.serviceJSON}else t=await l(e,{customParameters:a});const n=t?.layers,i=t?.tables;return{layerIds:n?.map((e=>e.id)).reverse()||[],tableIds:i?.map((e=>e.id)).reverse()||[],layerInfos:s?n:[],tableInfos:s?i:[]}}(c,f,y);S&&(w.sublayerInfos=e.layerInfos,w.tableInfos=e.tableInfos),1!==e.layerIds.length+e.tableIds.length?(w.sublayerIds=e.layerIds,w.tableIds=e.tableIds):S&&(w.layerOrTableId=e.layerIds[0]??e.tableIds[0],w.sourceJSON=e.layerInfos?.[0]??e.tableInfos?.[0])}return w.Constructor=await async function(e){return(0,i[e])()}(I),w}(c.url,p),d={...c.properties,url:c.url};if(!f.sublayerIds)return null!=f.layerOrTableId&&(d.layerId=f.layerOrTableId,d.sourceJSON=f.sourceJSON),new f.Constructor(d);const I=new(0,(await import("../layers/GroupLayer.js")).default)({title:f.parsedUrl.title});return function(e,r,a){function t(e,t){const s={...a,layerId:e,sublayerTitleMode:"service-name"};return null!=t&&(s.sourceJSON=t),new r.Constructor(s)}r.sublayerIds.forEach((a=>{const s=t(a,y(r.sublayerInfos,a));e.add(s)})),r.tableIds.forEach((a=>{const s=t(a,y(r.tableInfos,a));e.tables.add(s)}))}(I,f,d),I}function y(e,r){return e?e.find((e=>e.id===r)):null}function m(e){return null!=e&&e.hasOwnProperty("store")&&e.hasOwnProperty("id")&&"number"==typeof e.id}export{c as fromUrl};
