/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.27/esri/copyright.txt for details.
*/
import{clone as e}from"../core/lang.js";import{a as t}from"./FeatureLikeLayerView3D.js";import{fixFields as r,unpackFieldNames as n,collectLabelingFields as o,collectFilterFields as i}from"../layers/support/fieldUtils.js";import{_ as s}from"./tslib.es6.js";import l from"../core/Accessor.js";import{L as a}from"./Logger.js";import{r as u}from"./tracking.js";import{property as d}from"../core/accessorSupport/decorators/property.js";import{subclass as c}from"../core/accessorSupport/decorators/subclass.js";import{S as p}from"./watch.js";import{HandleOwner as f}from"../core/HandleOwner.js";import"./ensureType.js";import{i as y}from"./typedArrayUtil.js";import{b as m}from"./maybe.js";import{u as g,a as h,i as b}from"./DefinitionExpressionSceneLayerView.js";import{throwIfAbortError as F,throwIfNotAbortError as w}from"../core/promiseUtils.js";import{whenOnce as I}from"../core/reactiveUtils.js";import{project as E,canProjectWithoutEngine as x,isLoaded as _,load as j}from"../geometry/projection.js";import A from"../views/layers/LayerView.js";const v={setAttribute(){},setGeometry(e){},rollback(){},commit(){}};var U;function N(t,r){const n=r.attributes[t.objectIdField],o=t.sessions.get(n);if(o)return o;const i=e(r.attributes),s=new Set;if(null==n)return v;const l=t.i3sOverrides.createInteractiveEditSession(n),a=new Map;let u=U.EDITING;const d={setAttribute(e,o){if(u!==U.EDITING)return;const i=t.fieldsIndex.get(e);if(!i)return;const d=t.attributeStorageInfo.findIndex((e=>e.name===i.name));if(d<0)return;l.setAttribute(d,o);const c=t.attributeStorageInfo[d];let p=!1;s.add(e),t.forEachNode(((e,i)=>{const s=((e,t)=>{const r=a.get(e);if(null==r){const r=t.indexOf(n);return a.set(e,r),r}return r})(e,i);if(-1===s)return;const l=t.getAttributeData(e.index);if(l){const n=l[c.name];n&&(n[s]=o,t.setAttributeData(e.index,l,r),p=!0)}})),p&&t.clearMemCache()},setGeometry(e){u===U.EDITING&&l.setGeometry(e)},rollback(){if(u===U.EDITING){for(const e of s)this.setAttribute(e,i[e]);l.rollback(),u=U.ROLLED_BACK,t.sessions.delete(n)}},commit(){u===U.EDITING&&(l.commit(),u=U.COMMITTED,t.sessions.delete(n))}};return t.sessions.set(n,d),d}function O(e,r){const n=e.fieldsIndex,o=e.objectIdField,i=e.globalIdField;if(null==i)return;const s=new Map,l=D(r.addedFeatures),a=r.edits.addFeatures,u=M(r.updatedFeatures),d=r.edits.updateFeatures,c=function(e,r,n,o){const i=new Map;if(!o)return i;for(const s of o){let o=null,l=null;"attributes"in s?(o=t(e,s.attributes,r),l=t(e,s.attributes,n)):(o=s.objectId,l=s.globalId),null!=l&&null!=o&&i.set(l,o)}return i}(n,o,i,r.edits?.deleteFeatures),p=M(r.deletedFeatures,c),f=r.edits.deleteFeatures;if(null!=a&&a.length>0)for(const e of a){const r=t(n,e.attributes,i),o=l.get(r);null!=e.geometry&&"mesh"===e.geometry.type&&null!=o&&s.set(o,e.geometry)}if(null!=d&&d.length>0)for(const e of d){const r=t(n,e.attributes,o);null!=e.geometry&&"mesh"===e.geometry.type&&u.has(r)&&s.set(r,e.geometry)}if(null!=f&&f.length>0)for(const e of f){let r=null;r="attributes"in e?t(n,e.attributes,o):e.objectId,null!=r&&p.has(r)&&s.set(r,null)}for(const[t,r]of s)e.i3sOverrides.updateGeometry(t,r)}function S(e,r){const n=function(e,r){const n=r.edits.updateFeatures;if(!n||0===n.length)return new C;const o=M(r.updatedFeatures),i=new C,s=new Map;for(let t=0;t<e.attributeStorageInfo.length;t++)s.set(e.attributeStorageInfo[t].name,t);const l=e.fieldsIndex,a=e.objectIdField,u=n.filter((e=>{const r=t(l,e.attributes,a);return o.has(r)}));return e.forEachNode(((r,n)=>{const o=new Set(n);for(const s of u){const u=t(l,s.attributes,a);if(!o.has(u))continue;const d=n.indexOf(u);for(const t in s.attributes){const n=e.fieldsIndex.normalizeFieldName(t),o=L(i,r.index,n),l=s.attributes[t];o.push({featureIndex:d,featureId:u,value:l})}}})),i}(e,r),o=function(e,{edits:r,addedFeatures:n}){const o=new Map,i=r.addAssetFeatures,{fieldsIndex:s,globalIdField:l}=e;if(!i||0===i.length||null==l)return o;const a=D(n);for(const e of i){const r=t(s,e.attributes,l),n=a.get(r);null!=e.geometry&&"mesh"===e.geometry.type&&null!=n&&o.set(n,e)}return o}(e,r);if(0===n.size&&0===o.size)return;const i=new Map;for(let t=0;t<e.attributeStorageInfo.length;t++)i.set(e.attributeStorageInfo[t].name,t);let s=!1;n.forEach(((t,r)=>{const n=e.getAttributeData(r);let o=!1;t.forEach(((t,r)=>{const l=null!=n?n[r]:null,a=i.get(r);for(const{featureIndex:r,value:n,featureId:i}of t)l&&(l[r]=n,o=!0,s=!0),e.i3sOverrides.updateAttributeValue(i,a,n)})),o&&e.setAttributeData(r,n,null)})),s&&e.clearMemCache();const{fieldsIndex:l,i3sOverrides:a,objectIdField:u,globalIdField:d}=e,c=a.layer.associatedLayer?.infoFor3D,p=new Set(c?[...Object.values(c.assetMapFieldRoles),...Object.values(c.transformFieldRoles)]:[]);for(const[e,t]of o){a.featureAdded(e);const{attributes:r}=t;for(const t in r){if(t!==u&&t!==d&&p.has(t))continue;const n=l.normalizeFieldName(t),o=null!=n?i.get(n):null;if(null==o)continue;const s=r[t];a.updateAttributeValue(e,o,s)}}}function L(e,t,r){const n=function(e,t){const r=e.get(t);if(r)return r;const n=new T;return e.set(t,n),n}(e,t),o=null!=r&&n.get(r);if(o)return o;const i=new Array;return n.set(r,i),i}function D(e){const t=new Map;if(!e)return t;for(const r of e)null!=r.globalId&&null!=r.objectId&&null==r.error&&t.set(r.globalId,r.objectId);return t}function M(e,t=null){const r=new Set;if(!e)return r;for(const n of e)if(null==n.error)if(null!=n.objectId&&-1!==n.objectId)r.add(n.objectId);else if(null!=n.globalId&&null!=t){const e=t.get(n.globalId);null!=e&&r.add(e)}return r}!function(e){e[e.EDITING=0]="EDITING",e[e.ROLLED_BACK=1]="ROLLED_BACK",e[e.COMMITTED=2]="COMMITTED"}(U||(U={}));const T=Map,C=Map;function R(){return{requiredFields:{type:[String],readOnly:!0},availableFields:{type:[String],readOnly:!0,get:function(){const{layer:e,layer:{fieldsIndex:t},requiredFields:o}=this;return e.outFields?r(t,[...n(t,e.outFields),...o]):r(t,o)}}}}const q=e=>{let t=class extends e{constructor(){super(...arguments),this._numUpdating=0,this._asyncUpdateState=new Map}get updating(){return this._numUpdating>0}autoUpdateAsync(e,t){return function(e,t){const r=()=>{if(!n||o)return t();n.clear(),o=!0;const e=u(n,t);return o=!1,e};let n=new p((()=>{n&&!o&&e(r)})),o=!1;return e(r),{remove:()=>{n&&(n.destroy(),n=null)}}}((t=>this._updateAsync(e,t)),t)}async _updateAsync(e,t){if(!this._startAsyncUpdate(e)){try{const r=await t();this._set(e,r)}catch(t){a.getLogger(this).warn(`Async update of "${String(e)}" failed. Async update functions should not throw exceptions.`)}this._endAsyncUpdate(e)&&this._updateAsync(e,t)}}_startAsyncUpdate(e){const t=this._asyncUpdateState.get(e)??V.None;return t&V.Updating?(this._asyncUpdateState.set(e,t|V.Invalidated),!0):(++this._numUpdating,this._asyncUpdateState.set(e,t|V.Updating),!1)}_endAsyncUpdate(e){--this._numUpdating;const t=(this._asyncUpdateState.get(e)??V.None)&~V.Updating;return t&V.Invalidated?(this._asyncUpdateState.set(e,t&~V.Invalidated),!0):(this._asyncUpdateState.set(e,t),!1)}};return s([d({readOnly:!0})],t.prototype,"updating",null),s([d()],t.prototype,"_numUpdating",void 0),t=s([c("esri.core.AsyncUpdate")],t),t};var V;!function(e){e[e.None=0]="None",e[e.Updating=1]="Updating",e[e.Invalidated=2]="Invalidated"}(V||(V={}));let k=class extends(q(l)){};k=s([c("esri.core.AsyncUpdate")],k);const G="esri.views.3d.layers.support.SceneLayerViewRequiredFields";let P=class extends(q(f)){get layer(){return this.layerView.layer}get requiredFields(){const{layerView:{layer:{fieldsIndex:e},definitionExpressionFields:t},rendererFields:n,labelingFields:o,viewFilterFields:i}=this;return r(e,[...t??[],...n??[],...o??[],...i??[]])}constructor(e){super(e)}initialize(){this.handles.add([this.autoUpdateAsync("rendererFields",(async()=>{const{fieldsIndex:e,renderer:t}=this.layer;return t?z((r=>t.collectRequiredFields(r,e))):null})),this.autoUpdateAsync("labelingFields",(async()=>{const{layer:e}=this;return e.labelsVisible?z((t=>o(t,e))):null})),this.autoUpdateAsync("viewFilterFields",(()=>{const{layer:e,filter:t}=this.layerView;return z((r=>i(r,e,t)))}))])}};async function z(e){const t=new Set;try{return await e(t),Array.from(t).sort()}catch(e){return a.getLogger(G).error(e),null}}s([d()],P.prototype,"layerView",void 0),s([d()],P.prototype,"layer",null),s([d()],P.prototype,"requiredFields",null),s([d()],P.prototype,"rendererFields",void 0),s([d()],P.prototype,"labelingFields",void 0),s([d()],P.prototype,"viewFilterFields",void 0),P=s([c(G)],P);const B="esri.views.layers.SceneLayerView",K=a.getLogger(B);let H=class extends A{constructor(){super(...arguments),this.layer=null,this.filter=null,this._geometryEngine=null,this._projectionEngineLoaded=!1,this._abortController=new AbortController}get availableFields(){return[]}get maximumNumberOfFeatures(){return 0}set maximumNumberOfFeatures(e){throw new Error("Not implemented")}get maximumNumberOfFeaturesExceeded(){return!1}get layerFilter(){return g(this._layerFilter)}get _layerFilter(){const e=this.layer.filter;if(null==e||e.geometries.length<1)return null;const t=this._geometryEngine;if(null==t||!this._projectionEngineLoaded&&this._filterNeedsProjectionEngine)return h;const r=e.geometries.at(0).spatialReference,n=e.geometries.toArray().map((e=>{try{e=t.simplify(e)}catch(e){return K.warnOncePerTick("Failed to simplify scene filter mask polygon. Polygon will be ignored."),null}if(null==e)return null;if(e.spatialReference.equals(r))return e;try{return E(e,r)}catch(e){return K.warnOncePerTick("Failed to project scene filter mask polygon. Polygon will be ignored."),null}})).filter(y).sort(((e,t)=>e.extent.xmin-t.extent.xmin)),o=new Set,i=new Array,s=new Array;for(let e of n){const r=e.extent.xmin;if(i.length=0,o.forEach((n=>{if(r>=n.extent.xmax)return s.push(n),void o.delete(n);e.extent.ymin<=n.extent.ymax&&e.extent.ymax>=n.extent.ymin&&t.intersects(e,n)&&i.push(n)})),i.length>0){i.push(e);try{e=t.union(i)}catch(e){K.warnOncePerTick("Failed to unify filter mask polygons. Polygon will be ignored.");continue}i.pop(),i.forEach((e=>o.delete(e)))}o.add(e)}return o.forEach((e=>s.push(e))),s.length>0?{spatialRelationship:e.spatialRelationship,geometries:s}:null}get _filterNeedsProjectionEngine(){const e=this.layer.filter;if(null==e||e.geometries.length<=1)return!1;const t=e.geometries.at(0).spatialReference;return e.geometries.some((({spatialReference:e})=>!e.equals(t)&&!x(e,t)))}get layerFilterUpdating(){return b(this._layerFilter)}initialize(){const{signal:e}=this._abortController;I((()=>this.destroyed||!this._geometryEngine&&this.layer?.filter?.geometries?.length),e).then((async()=>{F(e),this._geometryEngine=await import("../geometry/geometryEngine.js")})).catch(w),this._projectionEngineLoaded=_(),I((()=>this.destroyed||!this._projectionEngineLoaded&&this._filterNeedsProjectionEngine),e).then((async()=>{F(e),await j(),this._projectionEngineLoaded=!0})).catch(w)}destroy(){this._abortController=m(this._abortController)}highlight(e){throw new Error("Not implemented")}queryFeatures(e,t){throw new Error("Not implemented")}queryObjectIds(e,t){throw new Error("Not implemented")}queryFeatureCount(e,t){throw new Error("Not implemented")}createQuery(){throw new Error("Not implemented")}queryExtent(e,t){throw new Error("Not implemented")}};s([d()],H.prototype,"layer",void 0),s([d()],H.prototype,"availableFields",null),s([d()],H.prototype,"maximumNumberOfFeatures",null),s([d({readOnly:!0})],H.prototype,"maximumNumberOfFeaturesExceeded",null),s([d()],H.prototype,"filter",void 0),s([d({readOnly:!0})],H.prototype,"layerFilter",null),s([d({readOnly:!0})],H.prototype,"_layerFilter",null),s([d()],H.prototype,"_geometryEngine",void 0),s([d()],H.prototype,"_projectionEngineLoaded",void 0),s([d()],H.prototype,"_filterNeedsProjectionEngine",null),s([d()],H.prototype,"layerFilterUpdating",null),H=s([c(B)],H);const Q=H;export{P as S,S as a,Q as b,N as c,R as d,O as p};
