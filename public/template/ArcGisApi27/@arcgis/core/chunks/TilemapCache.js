/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.27/esri/copyright.txt for details.
*/
import{_ as e}from"./tslib.es6.js";import t from"../request.js";import i from"../core/Accessor.js";import{B as a}from"./ByteSizeUnit.js";import r from"../core/Error.js";import{b as l}from"./utils.js";import{L as s}from"./LRUCache.js";import{P as o}from"./PooledArray.js";import{onAbort as n,createAbortError as h,isAbortError as c,isAborted as p}from"../core/promiseUtils.js";import{watch as m,initial as f}from"../core/reactiveUtils.js";import{waitTicks as u}from"../core/scheduling.js";import{objectToQuery as v}from"../core/urlUtils.js";import{property as d}from"../core/accessorSupport/decorators/property.js";import"./ensureType.js";import{N as y,t as w,u as b}from"./typedArrayUtil.js";import{subclass as g}from"../core/accessorSupport/decorators/subclass.js";import{T as _}from"./TileKey.js";import{clone as T}from"../core/lang.js";class A{constructor(e){this._validateJSON(e);const{location:t,data:i}=e;this.location=Object.freeze(T(t));const a=this.location.width,r=this.location.height;let l=!0,s=!0;const o=function(e,t=!1){return e<=y?t?new Array(e).fill(0):new Array(e):new Uint32Array(e)}(Math.ceil(a*r/32));let n=0;for(let e=0;e<i.length;e++){const t=e%32;i[e]?(s=!1,o[n]|=1<<t):l=!1,31===t&&++n}s?(this._availability="unavailable",this.byteSize=40):l?(this._availability="available",this.byteSize=40):(this._availability=o,this.byteSize=40+w(o))}getAvailability(e,t){if("unavailable"===this._availability||"available"===this._availability)return this._availability;const i=(e-this.location.top)*this.location.width+(t-this.location.left),a=i%32,r=i>>5,l=this._availability;return r<0||r>l.length?"unknown":l[r]&1<<a?"available":"unavailable"}static fromDefinition(e,i){const a=e.service.request||t,{row:l,col:s,width:o,height:n}=e,h={query:{f:"json"}};return i=i?{...h,...i}:h,a(function(e){let t;if(e.service.tileServers?.length){const i=e.service.tileServers;t=`${i&&i.length?i[e.row%i.length]:e.service.url}/tilemap/${e.level}/${e.row}/${e.col}/${e.width}/${e.height}`}else t=`${e.service.url}/tilemap/${e.level}/${e.row}/${e.col}/${e.width}/${e.height}`;const i=e.service.query;return i&&(t=`${t}?${i}`),t}(e),i).then((e=>e.data)).catch((e=>{if(e&&e.details&&422===e.details.httpStatus)return{location:{top:l,left:s,width:o,height:n},valid:!0,data:b(o*n,0)};throw e})).then((e=>{if(e.location&&(e.location.top!==l||e.location.left!==s||e.location.width!==o||e.location.height!==n))throw new r("tilemap:location-mismatch","Tilemap response for different location than requested",{response:e,definition:{top:l,left:s,width:o,height:n}});return A.fromJSON(e)}))}static fromJSON(e){return Object.freeze(new A(e))}_validateJSON(e){if(!e||!e.location)throw new r("tilemap:missing-location","Location missing from tilemap response");if(!1===e.valid)throw new r("tilemap:invalid","Tilemap response was marked as invalid");if(!e.data)throw new r("tilemap:missing-data","Data missing from tilemap response");if(!Array.isArray(e.data))throw new r("tilemap:data-mismatch","Data must be an array of numbers");if(e.data.length!==e.location.width*e.location.height)throw new r("tilemap:data-mismatch","Number of data items does not match width/height of tilemap")}}function j(e){return`${e.level}/${e.row}/${e.col}/${e.width}/${e.height}`}var O;let D=O=class extends i{constructor(e){super(e),this._pendingTilemapRequests={},this.request=t,this.size=32,this._prefetchingEnabled=!0}initialize(){this._tilemapCache=new s(2*a.MEGABYTES),this.addHandles([m((()=>{const{layer:e}=this;return[e?.parsedUrl,e?.tileServers,e?.apiKey,e?.customParameters]}),(()=>this._initializeTilemapDefinition()),f)])}get effectiveMinLOD(){return this.minLOD??this.layer.tileInfo.lods[0].level}get effectiveMaxLOD(){return this.maxLOD??this.layer.tileInfo.lods[this.layer.tileInfo.lods.length-1].level}fetchTilemap(e,t,i,a){if(!this.layer.tileInfo.lodAt(e)||e<this.effectiveMinLOD||e>this.effectiveMaxLOD)return Promise.reject(new r("tilemap-cache:level-unavailable",`Level ${e} is unavailable in the service`));const l=this._tmpTilemapDefinition,s=this._tilemapFromCache(e,t,i,l);if(s)return Promise.resolve(s);const o=a&&a.signal;return a={...a,signal:null},new Promise(((e,t)=>{n(o,(()=>t(h())));const i=j(l);let r=this._pendingTilemapRequests[i];if(!r){r=A.fromDefinition(l,a).then((e=>(this._tilemapCache.put(i,e,e.byteSize),e)));const e=()=>delete this._pendingTilemapRequests[i];this._pendingTilemapRequests[i]=r,r.then(e,e)}r.then(e,t)}))}getAvailability(e,t,i){if(!this.layer.tileInfo.lodAt(e)||e<this.effectiveMinLOD||e>this.effectiveMaxLOD)return"unavailable";const a=this._tilemapFromCache(e,t,i,this._tmpTilemapDefinition);return a?a.getAvailability(t,i):"unknown"}fetchAvailability(e,t,i,a){return!this.layer.tileInfo.lodAt(e)||e<this.effectiveMinLOD||e>this.effectiveMaxLOD?Promise.reject(new r("tile-map:tile-unavailable","Tile is not available",{level:e,row:t,col:i})):this.fetchTilemap(e,t,i,a).catch((e=>e)).then((a=>{if(a instanceof A){const l=a.getAvailability(t,i);if("unavailable"===l)throw new r("tile-map:tile-unavailable","Tile is not available",{level:e,row:t,col:i});return l}if(c(a))throw a;return"unknown"}))}fetchAvailabilityUpsample(e,t,i,a,r){a.level=e,a.row=t,a.col=i;const l=this.layer.tileInfo;l.updateTileInfo(a);const s=this.fetchAvailability(e,t,i,r).catch((e=>{if(c(e))throw e;if(l.upsampleTile(a))return this.fetchAvailabilityUpsample(a.level,a.row,a.col,a,r);throw e}));return this._fetchAvailabilityUpsamplePrefetch(a.id,e,t,i,r,s),s}async _fetchAvailabilityUpsamplePrefetch(e,t,i,a,r,s){if(!this._prefetchingEnabled||null==e)return;const o=`prefetch-${e}`;if(this.hasHandles(o))return;const n=new AbortController;s.then((()=>n.abort()),(()=>n.abort()));let h=!1;const c=l((()=>{h||(h=!0,n.abort())}));if(this.addHandles(c,o),await u(10,n.signal).catch((()=>{})),h||(h=!0,this.removeHandles(o)),p(n))return;const m=new _(e,t,i,a),f={...r,signal:n.signal},v=this.layer.tileInfo;for(let e=0;O._prefetches.length<O._maxPrefetch&&v.upsampleTile(m);++e){const e=this.fetchAvailability(m.level,m.row,m.col,f);O._prefetches.push(e);const t=()=>{O._prefetches.removeUnordered(e)};e.then(t,t)}}_initializeTilemapDefinition(){if(!this.layer.parsedUrl)return;const{parsedUrl:e,apiKey:t,customParameters:i}=this.layer;this._tilemapCache.clear(),this._tmpTilemapDefinition={service:{url:e.path,query:v({...e.query,...i,token:t??e.query?.token}),tileServers:this.layer.tileServers,request:this.request},width:this.size,height:this.size,level:0,row:0,col:0}}_tilemapFromCache(e,t,i,a){a.level=e,a.row=t-t%this.size,a.col=i-i%this.size;const r=j(a);return this._tilemapCache.get(r)}get test(){const e=this;return{get prefetchingEnabled(){return e._prefetchingEnabled},set prefetchingEnabled(t){e._prefetchingEnabled=t},hasTilemap:(t,i,a)=>!!e._tilemapFromCache(t,i,a,e._tmpTilemapDefinition)}}};D._maxPrefetch=4,D._prefetches=new o({initialSize:O._maxPrefetch}),e([d({constructOnly:!0})],D.prototype,"layer",void 0),e([d({constructOnly:!0})],D.prototype,"minLOD",void 0),e([d({constructOnly:!0})],D.prototype,"maxLOD",void 0),e([d({constructOnly:!0})],D.prototype,"request",void 0),e([d({constructOnly:!0})],D.prototype,"size",void 0),D=O=e([g("esri.layers.support.TilemapCache")],D);export{D as T};
